{"posts":[{"title":"adb原理及命令","text":"介绍abd原理及adb常用操作命令。 原理 adb构成 client端，在电脑，负责发送adb命令 daemon守护进程adbd，在手机端，负责接受和执行adb命令 server端，在电脑上，负责管理client和daemon之间的通信 adb工作原理 client-&gt;server-&gt;daemon(执行返回结果)-&gt;server-&gt;client 命令 adb help adb version adb start-server 启动server adb kill-server 停止server adb devices adb install xxx.apk 安装应用 adb install -r xxx.apk 覆盖安装 adb uninstall 包名 adb push xxx xxx 推送文件到手机 adb push xxx.apk ./sdcard/yyy adb pull xxx xxx 拉取手机文件到电脑上并改名 adb pull xxx 拉取整个文件夹 adb shell 进入到手机linux控制台 去除wife感叹号 adb shell settings put global captive_portal_mode 0 adb -s 设备名 shell（多个设备是使用） 超级adb才能用 adb root adb remount 挂载分区为可读写 adb disable-verity 关闭分区检测功能","link":"/2023/08/01/android1/"},{"title":"刷机","text":"介绍刷机基础，使用设备GooglePiexlXL 代号(marlin)，安卓版本 10.0。 1.刷机包分类 线刷包 后续编译的安卓系统都使用线刷包 刷机包组成 flash-all.bat内容：使用fastboot刷入bl radio image 卡刷包 2.刷机过程 线刷 进入bootloader双击flash-all.bat运行 进入bootloader使用fastboot命令进行刷机 卡刷 进入recovery使用手机sd卡内保存的卡刷包刷机 进入recovery使用adb sideload 推送刷机包 3.刷机命令（常用） adb adb devices 检测设备是否连接上电脑 adb reboot 重启 adb reboot recovery/bootloader 重启进入recovery/bootloader adb sideload &lt;刷机包地址&gt; 在recovery模式启用adb调试推送刷机包 fastboot fastboot devices 检测设备是否连接上电脑 fastboot reboot 重启 fastboot reboot recovery 重启进入recovery fastboot flash &lt;分区&gt; &lt;分区对应刷机包&gt; 刷入刷机包命令","link":"/2023/08/01/android2/"},{"title":"查看包名","text":"查看安卓包名的方法 反编译查看清单文件 通过shell命令获取包名和入口类名 adb shell dumpsys window | grep mFocusedApp (mac下这个可以看到) adb shell dumpsys window | grep mCorrentFocus adb shell dumpsys window windows |grep mFocusedApp windows环境下将grep替换为findstr 查看入口类 adb shell dumpsys package 包名 | grep LAUNCHER 打印进程信息 Android8之前 ps Android8之后 ps -A pm list packages /data/data /data/app","link":"/2023/08/07/android3/"},{"title":"查看日志","text":"logcat命令，As查看日志 logcat命令 adb logcat -help 查看帮助 adb logcat 常规显示 adb logcat -c 清除日志 adb logcat -g 显示缓冲区大小 adb logcat -G 256M 修改缓冲区大小 adb logcat -v time 设置不同的显示格式 adb logcat -v color 带颜色的显示 过滤方法 根据tag过滤日志 adb logcat -s xxx 根据pid过滤日志 获取进程pid ps -A｜grep 包名 adb logcat ｜findstr(win, mac(grep)) pid 根据自定义标签过滤 adb logcat｜findstr 自定义标签 AS中查看Logcat package:mine 用当前运行的应用包名进行过滤 level:DEBUG 显示调试级别以上信息 tag:xxx 过滤xxx的标签 -tag:xxx xxx的标签除外 message:xxx 过滤包含xxx关键字的信息","link":"/2023/08/13/android4/"},{"title":"安卓常见目录","text":"安卓常见目录 /data/data 存放用户app数据的目录，每个app都有自己的目录，以包名命名，这是一个私有目录，app只能访问各自的目录，除非app有root权限，该目录下的文件要pull到电脑上来，通常先拷贝到sdcard目录 /data/app 用户安装的app存放在这个目录下，里面还有当前版本的base.apk安装包 /data/local/tmp 临时目录，权限很大 /system/app 目录：存放系统自带的app /system/lib 存放app用到的系统so文件 /system/lib64 存放app用到的系统so文件 /system/bin 存放shell命令 /system/framework 安卓系统所用到框架，一些jar文件 sd卡目录 不管手机里有没有储存卡都有这个目录，app操作sd卡目录需要申请权限，不同系统版本要求还不同 软连接 /sdcard /storage/self/primary /mnt/sdcard /storage/emulated/0","link":"/2023/10/23/android5/"},{"title":"Apk结构","text":"安卓版本和安卓应用结构 apk在进行反编译后 use-sdk android minSdkVersion='xx'xx表示最小支持sdk版本 android10 —sdk 29 android 13 —sdk 33 Android历史版本 4.4 以前使用dalvik/dvm虚拟机，libdvm.so 4.4 使用dvm和art虚拟机，可以切换libdvm.so、libart.so 5.0 之后采用art虚拟机，安卓系统开始分32位和64位 apk基本结构 assets 资源文件（图片、音频、数据库、网页、配置文件、dll、so等） res 资源文件（编译后到布局文件、程序图标） lib 各种平台下使用的对应的so文件 META-INF 签名文件 resources.arsc 资源加密（语言包） AndroidManifest.xml 清单文件（图标、界面、权限、代码执行入口） classes.dex java源代码需要反编译","link":"/2023/10/24/android6/"},{"title":"抓包工具(一)","text":"介绍抓包工具Charles的安装和使用，Proxifie的设置。 抓包工具分类 全局抓包工具 代理抓包 Charles Fiddler BurpSuite（渗透用） 手机抓包 tcpdump HttpCanary（vpn） 流量转发工具 Proxifier socksdroid postern lamda r0Capture eCapture 网卡抓包 WireShark Charles 为了应对网页跳转时，打开一个新网页，使用开发者工具没办法抓包。 为了应对网页跳转时，打开一个新网页，开发者工具会把前面的响应丢掉。 Charles注册码 ：https://zzzmode.com/mytools/charles/ 配置Proxy Settings 解密SSL -&gt; 安装证书 抓取https数据包 关闭Charles原因是Proxifie的Rules默认将全部流量转发到127.0.0.1:8889端口，即使关闭了也不会改变，可以将Default的Action改为Direct直连。 抓取Python程序发出的数据包开启Charles代理后对Python爬虫程序发出的数据包进行抓取需要添加代理 代理地址为Charles设置的地址和端口 123456789101112131415import requests#消除警告import urllib3urllib3.disable_warnings()url = 'https://www.eloancn.com/'headers = {}# 设置代理proxies={'https':'http://127.0.0.1:8888'}resp = requests.get(url=url,headers=headers,proxies=proxies,verify=False)resp.encoding='utf-8'print(resp.text) Proxifie Proxifier是socks5客户端，可以让不支持通过代理服务器工作的网络程序能通过HTTPS或SOCKS代理或代理链,将pc端端流量强制转发到代理服务器上。 开启Charles的SOCKS代理服务器，根据Proxifie的规则，将数据包先转发到127.0.0.1:8889端口，在发送到Charles由其发送出去。","link":"/2023/08/01/charles/"},{"title":"抓包工具(二)","text":"charles使用 修改请求和响应，替换文件 charles 修改请求和响应 对网站起始进行Focus方便观察 下断点，选择要修改的请求链接下断点 charles会对该链接的请求和响应进行拦截 Edit Request 修改请求内容 Edit Response 修改响应内容 修改完后Execute执行 charles 修改文件 对需要修改的文件选择map local 添加Map to 中的本地替换文件","link":"/2023/08/28/charles1/"},{"title":"Css基础","text":"改变页面样式 使用Canvas绘画 改变页面样式12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;这是标题&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;url&quot;&gt; &lt;style&gt; &lt;!--标签选择器：修改input样式--&gt; input{ 属性名:值; 属性名:值; } &lt;!--类选择器--&gt; .textEdit{ 属性名:值; 属性名:值; } .box{ 属性名:值; 属性名:值; } &lt;!--id选择器--&gt; #id{ 属性名:值; 属性名:值; } &lt;!--通配符选择器--&gt; *{ 属性名:值; 属性名:值; } &lt;/style&gt; &lt;/head&gt;&lt;body&gt; username &lt;input class=&quot;textEdit box&quot; type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;提示输入&quot; /&gt;&lt;br /&gt; username2 &lt;input class=&quot;textEdit&quot; type=&quot;text&quot; name=&quot;username2&quot; placeholder=&quot;提示输入&quot; /&gt;&lt;br /&gt; username3 &lt;input id=&quot;id&quot; type=&quot;text&quot; name=&quot;username3&quot; placeholder=&quot;提示输入&quot; /&gt;&lt;br /&gt; username4 &lt;input id=&quot;id&quot; type=&quot;text&quot; name=&quot;username4&quot; placeholder=&quot;提示输入&quot; style=&quot;bored : red 1px solid&quot; /&gt;&lt;br /&gt;&lt;/body&gt;&lt;/html&gt; 使用Canvas绘画，处理验证码图片位置混淆123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;这是标题&lt;/title&gt;&lt;/head&gt;&lt;!-- 使用canvas画布重绘制图片 设置画布大小 边框--&gt;&lt;canvas id=&quot;myCanvas&quot; width=&quot;260&quot; height=&quot;116&quot; style=&quot;border: red 1px solid;&quot; &gt;&lt;/canvas&gt;&lt;!-- 通过js代码导入图片 --&gt;&lt;script&gt; let img = new Image(); img.src = &quot;./css图片.png&quot;; // 绑定事件 图片加载完成时运行 img.onload = function(){ console.log(&quot;图片加载完成&quot;); let cv = document.getElementById(&quot;myCanvas&quot;); // 2d 二维图片 let ctx = cv.getContext('2d'); // drawImage(ImgUrl,pxX（网站混淆的坐标）,pxY,styleX（原本设定的样式）,styleY,绘画横坐标,绘画纵坐标,styleX,styleY) // 手动添加坐标，后续使用for处理坐标 ctx.drawImage(img,234,25,13,25,0,0,13,25); ctx.drawImage(img,143,25,13,25,13,0,13,25); ctx.drawImage(img,65,75,13,25,26,0,13,25); console.log(cv); }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2023/10/25/css1/"},{"title":"SQlite数据库","text":"SQlite是一个软件库，实现自给自足，无服务器，零配置、事务性的SQl数据库引擎 是一个进程内的库，使用python，sqlite3模块集成 增删改查123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import sqlite3&quot;&quot;&quot;数据库 test.db 游标 cursorSQL数据库语言， 使用ORM封装后commit提交&quot;&quot;&quot;db = sqlite3.connect('test.db') cursor = db.cursor()cursor.execute(&quot;&quot;&quot; create table if not exists Study( id integer primary key autoincrement, name varchar(10) not null );&quot;&quot;&quot;)# 插入表格# cursor.execute(&quot;&quot;&quot;# insert into Study(id,name) values(1,&quot;hello&quot;)# &quot;&quot;&quot;)# # # 不提交不会插入数据# db.commit()# cursor.execute(&quot;&quot;&quot;# insert into Study(name) values(&quot;hello2&quot;)# &quot;&quot;&quot;)# db.commit()# 删# cursor.execute(&quot;&quot;&quot;# delete from Study where id=1;# &quot;&quot;&quot;)# db.commit()# 改# cursor.execute(&quot;&quot;&quot;# update Study set name='hello3' where id =1;# &quot;&quot;&quot;)# db.commit()# 查results = cursor.execute(&quot;&quot;&quot; select * from Study;&quot;&quot;&quot;)# 返回一个列表包元组print(results.fetchall())cursor.close()db.close()","link":"/2023/10/23/database1/"},{"title":"TinyDB数据库","text":"面向文档，类似MongoDB 表示为字典的任何文档存入 纯python 小型数据库 增删改查1234567891011121314151617181920212223242526272829303132333435from tinydb import TinyDB,Query db = TinyDB(&quot;tiny.db&quot;)query= Query()# 增# db.insert({&quot;name&quot;: &quot;a&quot;, &quot;value&quot;:&quot;100&quot;})# db.insert_multiple(# [{&quot;name&quot;: &quot;b&quot;, &quot;value&quot;:&quot;123&quot;},# {&quot;name&quot;: &quot;c&quot;, &quot;value&quot;:&quot;qew&quot;}]# )# 输出内容# print(db.all())# for line in db:# print(line)# 搜索 query.name==query['name']# result = db.search(query.name==&quot;c&quot;)# print(result)# 更新db.insert_multiple( [{&quot;name&quot;: &quot;b&quot;, &quot;value&quot;:&quot;123&quot;}, {&quot;name&quot;: &quot;c&quot;, &quot;value&quot;:&quot;qew&quot;}])# 把name为b的value改为qewdb.update({&quot;value&quot;: &quot;qew&quot;},query.name==&quot;b&quot;)print(db.all())# 删除db.remove(query.name==&quot;c&quot;)# 全删db.truncate()print(db.all())","link":"/2023/10/23/database2/"},{"title":"使用Fiddler转发数据","text":"Fiddler抓包工具转发数据 Fiddler Script 使用Fiddler进行自动转发 适用window环境下的Fiddler软件进行转发数据包 在本地开启接受数据的端口 12345678910111213141516171819202122import uvicornfrom fastapi import FastAPIfrom typing import Dict app = FastAPI() # post发送@app.post(&quot;/sendData&quot;)async def post_info1(request_data: Dict): print(request_data) return 'ok' @app.get(&quot;/&quot;)async def get_infos(): print(&quot;test&quot;) return 'ok' if __name__ == '__main__': # host='127.0.0.1'本机地址 # host ='0.0.0.0' 局域网下其他机器可引访问本机 uvicorn.run(app=app, host='0.0.0.0', port=8000) 改写Fiddler script 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960static function OnBeforeResponse(oSession: Session) { if (m_Hide304s &amp;&amp; oSession.responseCode == 304) { oSession[&quot;ui-hide&quot;] = &quot;true&quot;; } //Contains 过滤包含xx网站的数据 if (oSession.fullUrl.Contains(&quot;fangdi.com.cn/service/index/getWriteDict.action&quot;)) { var html = oSession.GetResponseBodyAsString() if(html.Contains(&quot;listWriteDict&quot;)){ //数据统计开始：把内容通过ajax http发送其它地方 var _xhr = new ActiveXObject('Microsoft.XMLHTTP'); var url = 'http://192.168.3.9:8000/sendData'; //发送的数据参数 var jsonString = oSession.GetResponseBodyAsString(); var requestHeaders = oSession.oRequest.headers.ToString(); var responseHeaders=oSession.oResponse.headers.ToString(); var str='{}';//构造自己的JSON http请求的信息及返回的结果 var data = Fiddler.WebFormats.JSON.JsonDecode(str); data.JSONObject[&quot;requestHeaders&quot;]=requestHeaders; data.JSONObject[&quot;responseHeaders&quot;]=responseHeaders; data.JSONObject[&quot;responseBody&quot;] = jsonString; data.JSONObject[&quot;url&quot;] = oSession.fullUrl; data.JSONObject[&quot;response_code&quot;] = oSession.responseCode; if(oSession.oRequest.headers.Exists(&quot;Cookie&quot;)){ data.JSONObject[&quot;requestCookie&quot;] = oSession.oRequest.headers['Cookie']; }else{ data.JSONObject[&quot;requestCookie&quot;] = 'request no Cookie'; }; if(oSession.oResponse.headers.Exists(&quot;Cookie&quot;)){ data.JSONObject[&quot;responseCookie&quot;] = oSession.oResponse.headers['Cookie']; }else{ data.JSONObject[&quot;responseCookie&quot;] = 'response no Cookie'; }; jsonString = Fiddler.WebFormats.JSON.JsonEncode(data.JSONObject) //FiddlerObject.log(jsonString); _xhr.onreadystatechange=function(){ if (_xhr.readyState==4){ FiddlerObject.log(_xhr.responseText); } }; _xhr.open('POST', url, true); _xhr.send(jsonString); //----数据统计结束----- }else{ //弹窗报错 FiddlerObject.alert(&quot;抓取出错！&quot;); } // if end } // if controll end }","link":"/2024/01/18/forward1/"},{"title":"使用RPC转发数据","text":"RPC转发数据 使用浏览器自带的WebSocket对象连接服务器转发数据 123456var ws=new WebSocket(&quot;ws://localhost:8899&quot;);ws.onmessage=function (e) { console.log(e) return xxx} 开启本地服务接受数据 12345678910111213141516171819202122import asyncioimport websocketsasync def echo(websocket): while True: await asyncio.sleep(2) print('发送.') await websocket.send('') data=await websocket.recv() print('data:',data) #我的爬虫代码 #xxxxasync def main_process(websocket,path): await echo(websocket)loop=asyncio.get_event_loop()loop.run_until_complete(websockets.serve(main_process,'localhost',8899))loop.run_forever()print('开启服务')","link":"/2024/01/18/forward2/"},{"title":"Html基础","text":"一种用于创建网页的标准标签语言 基本语法 HTML标签 双标签 &lt;head&gt;&lt;/head&gt; 单标签 &lt;br /&gt; 不区分大小写 基本结构 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;!--注意最后保存文档时的编码 --&gt; &lt;title&gt;这是标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--这是注释 --&gt; &lt;br /&gt;&lt;!--换行 --&gt; &lt;a href=&quot;url&quot; target=&quot;_self&quot;&gt;我是文本，从当前页面打开&lt;/a&gt;&lt;!--超链接 --&gt; &lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt;我是文本，新开页面打开&lt;/a&gt;&lt;!--超链接 --&gt; &lt;img src=&quot;url&quot; alt=&quot;加载不出来显示&quot; width=&quot;20&quot; height=&quot;30&quot;/&gt;&lt;!--加载图片,alt如果url加载不了显示alt --&gt; &lt;div&gt; &lt;span&gt;&lt;!--做布局 --&gt;&lt;/body&gt; &lt;/html&gt; Html字符实体 空格&amp;nbsp; 半角的空格&amp;ensp 全角的空格&amp;emsp Js代码添加在Html网页中1.script标签中 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;!--注意最后保存文档时的编码 --&gt; &lt;title&gt;这是标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; console.log(&quot;js代码&quot;);&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2.文件引入 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;!--注意最后保存文档时的编码 --&gt; &lt;title&gt;这是标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;./demo.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.绑定事件中引入 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;!--注意最后保存文档时的编码 --&gt; &lt;title&gt;这是标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;普通按钮&quot; onclick=&quot;console.log('nihao')&quot; /&gt;&lt;br /&gt; &lt;a href=&quot;javascript:alert(&quot;点击&quot;)&quot; target=&quot;_self&quot; &gt;我是文本，从当前页面打开&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 4.网站地址栏里 javascript:alert(&quot;点击&quot;)","link":"/2023/10/26/html1/"},{"title":"JavaScript基础（一）","text":"数据类型 操作符 显示输出 数据类型数据类型 值类型 String Number Boolean （true,false） Null Undefined 表示这个变量不含有值 Symbol（ES6：表示独一无二的值） 对象类型（引用数据类型） Object {} Array [] Function {} RegExp（正则） Date 使用 typeof 查看类型 声明新的变量时可以使用new &lt;变量类型&gt; 类型隐式转换 +- 转换为Number，如果无法转换返回NaN +- 字符串时 强制转换为字符串拼接 &gt;&lt; 比较时非数值转换为数值，字符串比较时转换为Unicode编码 常量 使用const const a = 0; 命名：大驼峰AppleApple 小驼峰appleApple 下划线apple_Apple 区分小写 Myfunction != myFunction 常数 Number 0123 字符串 String ‘a’ “ab” ‘asd’ 数组 Array [1,2,3,’a’,’’bsda] 对象 Object {name:adb,age:123} 函数 Function function myfn(a,b){} 变量 使用var声明1234var length = 6var length1 = 6,length2 = 6,length3 = '6'var length4 //未赋值的变量默认为undefined//允许重复声明后声明的覆盖前面的 let和var区别 let是ES6新增的语法声明变量作用在块级作用域 let 声明的变量不会提前，var会提前作用在整个window let不能重复定义 操作符 + - * / = ==(比较时先转换类似后比较) ===(全等包括数据类型) != 不等 &lt; &gt; &lt;&lt; &gt;&gt; 位运算 &amp;&amp; || 有0则0，有1则1 ?? 和 || 的用法相同，都是前后是值，中间用符号连接，根据前面的值来判断最终是返回前面的值还是后面的值 One ?? Two 使用 ?? 时，只有One为 null 或者 undefined 时才会返回 two; One || Two 使用 || 时，One会先转化为布尔值判断，为true时返回One , false 返回Two NaN 不等于 NaN 三元运算符 表达式1？表达式2:表达式3 表达式1成立返回2，否则返回3 特殊错误 12345let age = 100;// 写法有问题但不会报错let retval = 10 &lt; age &lt; 50;console.log(retval);结果为true 显示输出 浏览器环境 window.alert(‘弹出警告框’); document.write() console.log() innerHTML document.getElementById(‘demo’).innerHTML = ‘nihao’ //向id为demo的Html元素输出nihao","link":"/2023/10/26/js1/"},{"title":"JavaScript基础（二）","text":"分支结构 函数 分支结构if 同绝大数语言的if结构 if后如果只有一句可以省略{} 1234567const a = 2;if (a===3){ console.log('yes');}else { console.log('no')} switch 对比if，switch没法做区间判断 case 用于选择，case在做比较的时候进行===的比较不做类型转换。 switch case后要加break，不然会发生穿透效应 case语句顺序无所谓 default 用于没有case匹配的结果 case 结果类型可以是string number boolean object array 1234567891011121314const a = 8;switch (a) { case 1: console.log(1); break; case 2: console.log(2); break; case 3: console.log(3); break; default: console.log(4)} 循环结构while while先判断后循环12345let a = 8;while (a){ console.log(a); a--;} do…while先循环一边再判断12345let a = 8;do{ console.log(a); a--;}while (a) for123456- for(变量初始化;循环条件表达式;循环后操作)- ';'不能省略，条件可以写到别处- 循环条会转换为booleanfor(let i = 0;i&lt;10;i++){ console.log(i);} 数组遍历使用 for in for of 结束循环关键字 break 跳出当前循环 continue 跳过本次循环 return 跳出整个函数返回一个任意类型的值（也可以什么都不返回） 函数函数定义方式 函数声明1function fu(){} 函数表达式1const fn1 = function(){} 箭头函数1const fn2 = ()=&gt;{} 在（）内传参，只有一个时可以省略括号 返回值const fn2 = ()=&gt;a+b 只有函数声明可以提前，其他不能提前。 函数参数 形参 形式上的参数，写在定义函数时 实参 实际传入的参数，写在调用时 默认值 一般指定最后一个参数默认值 function fu(a,b=100){} 没有对应参数传入时使用默认值 a为undefined b为100 传参数量 实参多于形参，多余的不会使用 形参多于实参，多余的按照默认undefined 函数返回值 return 单独使用跳出循环结束函数 后根返回值（任意类型）只能有一个 返回多个返回值，先放入数组或对象中再返回 匿名函数 定义 1let fn = function(){} 作用 赋值给变量、赋值给对象的属性 作为参数传入函数，类似回调函数 作为返回值返回 作为命名空间，定义完直接调用 调用三种方式 匿名函数如果不赋值给变量，也不作为返回值或者参数传入，则必须在声明时直接调用，且只能调用一次。 一般使用时用前两中方式调用 12345678function fn1(){var a = 1;} fn1();//调用三种方式//加个（）表示调用;(function(){})();;(function(){}());!function(){}();//传参!function(a,b){console.log(a+b);}(100,200); 作用域 全局作用域 不包含在任何函数内部的代码，都在全局作用域中 全局作用域在程序启动时创建，程序结束时销毁 定义在全局作用域中的变量，就是全局变量，在任何地方都能访问它 函数作用域 定义在函数作用域的变量参数就是局部变量，函数外不能访问 函数作用域在调用函数时创建，函数执行完毕时销毁 每调用一次函数就会创建一个新的作用域，相互独立 没有以关键词定义的变量，在任何位置都是全局变量，不建议不写关键词去定义全局变量 在函数中还可以定义函数 使用函数声明方式定义的函数，没有块级作用域，会声明提前到作用域开始处 使用var来接收函数或箭头函数，该函数没有块级作用域 使用let来接收函数或箭头函数，该函数具有块级作用域 块级作用域 指作用域范围在局部代码块中 使用let声明变量 块级作用域可以嵌套在全局作用域、函数作用域或者其他块级作用域中 作用域链 函数嵌套时，各个作用域嵌套为一条作用域链，访问变量时先在当前作用域找，找不到就去上一级找 同一个作用域中let不能重名，使用var可以重名（本质是修改同一个变量）","link":"/2023/10/26/js2/"},{"title":"JavaScript基础（三）","text":"对象Object window对象 Object 对象的创建123let obj = new Object();let obj = Object();let obj = {};//隐式创建 对象属性的相关操作 对象中可以存储各种类型数据，对象中存储的数据称为属性。1234567891011//对象属性的创建obj.name = 'abc';obj.age = 2;//对象的属性可以随时创建，并且前面不能加let/var//对象属性的访问let nn = obj.name;//对象属性的修改obj.name = 'def';//对象属性的删除delete obj.name; 属性的两种访问方式12345678//点语法访问obl.name = &quot;nihao&quot;;//中括号访问obj[&quot;name&quot;] = &quot;nihao&quot;;let a = 'y';obj[&quot;x&quot;+a]=&quot;nihao&quot;;//中括号访问时，属性名就是个字符串，因此可以拼接//属性名与关键字重名，需要使用上述方式定义，否则在IE6，7引擎上会报错 使用symbol作为属性名12345678//使用Symbol()创建唯一标识，可以用来防止冲突//每次创建的都不一样，因此创建时需要赋值给变量保存，否则后续无法访问let s1 = Symbol();let s2 = Symbol();obj[s1] = 100;obj[s2] = 200;console.log(obj,obj[s1],obj[s2]);//使用symbol作为属性名无法被遍历 属性的值可以是任意的，也可以是一个对象123456let obj ={};obj.xxx = 100;obj.yyy = {};obj.yyy.zzz = 200;//检查对象中是否包含某个属性console.log(&quot;name&quot; in obj); 对象字面量12345//结构：{属性名：属性值，属性名：属性值}let obj = {x:1,y:1};let obj2 ={&quot;x&quot;:1,&quot;y&quot;:2};//两个一样的console.log(obj,obj2); 对象属性的遍历 for in123456let obj = {x:1,y:1};let i = 0;for(i in obj){ console.log(i);};//不是所有属性都可以变量，使用符号作为属性名的属性，属性描述符设置为不可枚举的属性（symbol） 对象的方法123456789101112131415//函数以赋值的形式给对象时，通常将该函数称为对象方法//定义obj.test = function(a,b){ console.log(a+b);};//调用obj.test(100,100);function fn(){};let obj = { //三种写法 test:function(){}, //ES6简写 fn, abc(){}} 对象的解构1234567891011121314//对象解构：其实就是利用 JS 解构赋值的特性，使用与对象匹配的结构来实现对象的属性赋值（即将对象的属性值提取出来）let obj ={name:&quot;nihao&quot;,age:40};//分开写let name,age;({name,age}=obj);let {name,age} = obj;console.log(name,age);//nihao 40//解构使用的变量名与属性名不一致时使用如下写法let {name:a,age:b} = obj;console.log(a,b);//nihao 40 对象作为函数参数 传参机制 原始类型（值传递）：形参的任何改变不影响实参 对象类型（引用传递）：对形参指向的对象进行改变，会影响实参 1234567function test(obj){ obj.name=&quot;buhao&quot;;};let obj1 = {name:&quot;nihao&quot;};test(obj1);console.log(obj1);//{ name: 'buhao' } 1234567//对象作为函数返回值function test(){ return{x:100,y:200};};console.log(test().x);console.log(test().y); window对象window对象 浏览器提供的一个全局对象，可以直接访问 window对象代表的是浏览器窗口，通过该对象可以对浏览器窗口进行各种操作 window对象还存储Js中的内置对象和浏览器的宿主对象 window对象的属性可以通过window对象访问，也可以直接访问 在浏览器环境中，window就是全局对象 在浏览器环境中的全局作用域中，可以使用this引用window 全局对象的特点 在全局作用域中，var声明的变量（不使用关键字声明），function声明的函数都是全局对象的属性和方法 在全局作用域中，使用let声明变量，不会存在window中","link":"/2023/10/26/js3/"},{"title":"JavaScript基础（四）","text":"globalThis this call方法，apply方法 bind方法 严格模式 globalThis 在window环境中全局对象为this 在nodejs环境中全局对象为global，this指代空对象 在V8引擎中全局对象为this globalThis：提供一个标准的方式来获取不同环境下的全局对象 this 在全局作用域中引用this，this是全局对象 以函数形式调用，this是全局对象 以方法形式调用，this是调用方法的对象 箭头函数没有自己的this，由外层作用域决定，无法通过call，apply，bind修改this，对象的方法、事件回调一般不使用箭头函数 通过call和apply调用的函数，第0个参数就是this（无法修改） 构造函数中this是新建的对象 call方法，apply方法 bind方法 作用：调用函数 xxx.call() xxx.apply() call和apply的第0个参数就是函数中this call的第一个参数是可变参数，可以将函数的实参一个个传递进去 apply的第一个参数是数组，可以将函数的实参放入数组后传递 bind方法创建一个新函数 bind可以为新函数绑定this 改变this指向 12345function fn(a,b){console.log(this,a,b);};//此时this为windowfn(100,200);let obj = {xxx:100};let newFn = fn.bind(obj);//此时this为objnewFn(300,400); 12let newFn = fn.bind(obj,100);//可以绑定第0个参数newFn(400);//前面绑定了参数只要传一个就行 严格模式 在代码签名加一行 &quot;use strict&quot; 变量声明不可以没有关键字 this 在全局作用域中指代window function函数中this，以函数形式调用，this为indefined function函数中this，以方法形式调用，谁调用它this就指代谁 隐藏属性方法全局调用123456789101112131415161718192021222324252627//全局作用域内可以访问test函数（不可以使a和test暴露在全局作用域中）(function(){ let a = 5; function test(){ console.log(a); }})();//第一种let _test;(function(){ let a = 5; function test(){ console.log(a); } _test = test;})();_test();//第二种let _test = (function(){ let a = 5; function test(){ console.log(a); } return test;})();_test(); 123456789101112131415161718192021222324252627282930313233//全局作用域内可以访问a和test函数（不可以使a和test暴露在全局作用域中）(function(){ let a = 5; function test(){ console.log(a); }})();//第一种使用objlet obj ={};//或者直接用window var window = globalThis；(function(){ let a = 5; function test(){ console.log(a);}obj.num = a;obj._test = test})();console.log(obj.num);obj._test();//第二种let obj = (function(){ let a = 5; function test(){ console.log(a);}return{ a:a, test:test}})();console.log(obj.a);obj.test();","link":"/2023/10/26/js4/"},{"title":"JavaScript基础（五）","text":"类，类的属性和方法 类 为什么需要类 使用Object创建对象，无法区分出不同类型的对象 使用Object创建对象，不方便批量创建对象 类的作用 类是对象模版，可以将对象中的属性和方法定义在类中 通过类来创建对象，创建出来的对象自动拥有类中的属性和方法，无需额外赋值 类的声明 class Person{} const Person = class {} 通过类创建对象 new Person(); new Person; 使用instanceof来检查一个对象是否由某个类创建 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 123let Dog = class{};let dog = new Dog;console.log(dog instanceof Dog); 类的属性和方法 在类的代码块中，JS以严格模式运行。 属性 12345class Person { name;//实例属性，通过对象来访问，每个对象都有一份 age = 20;//可以指代默认值 static abc = 100;//静态属性/类属性，通过类来访问} 方法 123456789101112131415class Person { name=&quot;nihao&quot;; test = function(){ console.log(this); console.log(this.name); };//实例方法，通过实例调用，this指代当前实例 static fn2(){ console.log(this);//打印这个this指向 console.log(this.name);//打印这个类名 };//类方法，通过类来调用，this指代当前类 }let a = new Person();a.test();Person.fn2(); 1234Person { name: 'nihao', test: [Function: test] }nihao[class Person]Person 构造函数1234567891011class Person { name;age;//可以省略 constructor(name,age){//可以不传参 this.name = name; this.age = age; //this指代创建出来的新对象 //不用写返回值，写了也没有用 //构造函数有且只有一个 }}const p1 = new Person(&quot;nihao&quot;,15);","link":"/2024/01/18/js5/"},{"title":"JavaScript基础（六）","text":"类的三大特性 封装 对象就像是一个用来存储不同属性的容器 数据直接赋值给对象的属性，并不安全，对象创建后可以被任意修改 将属性私有化，提供getter，setter方法操作属性，对传入的值进行检查或者控制属性读写权限 12345678910111213141516171819class Person{ #name;#age; //私有属性必须先声明，不可省略 constructor(name,age){ this.#name = name; this.#age = age; } getname(){ return this.#name; } setname(name){ this.#name = name; }}const p1 = new Person(&quot;nihao&quot;,23);console.log(p1.name);//私有属性不可访问console.log(p1.getname());//使用getname方法获取属性p1.setname(&quot;buhao&quot;);console.log(p1.getname()); 继承 继承可以提高代码复用性，避免书写很多重复的代码 1234567891011121314class Person{ #name;#age; //私有属性必须先声明，不可省略 constructor(name,age){ this.#name = name; this.#age = age; } getname(){ return this.#name; }}class Teacher extends Person{};class Student extends Person{}; 重写Object的toString方法 Object是所有类的基类，任何类都会继承Object，因此任何类都可以使用Object类里的方法 每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型。 方法的重写/覆盖 子类使用同名方法重写父类方法，重写后调用的就是自类自己的方法 super super代表父类对象的引用，用于访问父类对象的实例方法、构造方法 在类内部，可以通过this.xxx访问自身实例方法 在类内部，可以通过super.xxx访问父类实例方法 使用super访问方法，如果父类没有则会像爷爷类找 在类内外都可以通过 类名.xxx访问静态方法 重写构造函数 重写构造函数时，第一行代码必须是super(),否则无法创建父类对象 多态 多态就是指同一个方法，由于对象不同会有不同的行为 1234567891011class Demo { sayHello(){console.log(&quot;nihao&quot;);}}class Test extends Demo{ sayHello(){console.log(&quot;buhao&quot;);}}function abc(obj){ obj.sayHello();}abc(new Demo);abc(new Test); 多态主要体现在灵活，传入对象需要类型一致，Js解释器不做类型检查，任意类型都可以作为实参传入，Js中需要自己做额外检查。 123456789function abc(obj){ obj &amp;&amp; obj.sayHello &amp;&amp; obj.sayHello();}function abc(obj){ if(obj instanceof Demo){ obj.sayHello(); }}","link":"/2024/01/18/js6/"},{"title":"JavaScript基础（七）","text":"原型对象，原型链，旧类 原型对象 作用：每次实例化一个对象都要新开辟空间创建方法，将这些方法定义在原型链上，就不用开辟新空间。新创建的对象原型都是一致的，直接调用原型对象上的即可。 调用 实例名.proto Object.getPrototypeOf(obj) 类名.prototype 对象中储存属性的区域 自身 obj.xxx 添加属性 类中：xxx =y 添加属性 原型对象 类中通过xxx(){} 添加方法 原型链 最终都指向null demo.__protp__.__protp__.__protp__.__protp__ 使用demo.prototype 查看原型类型 旧类 ES6以前，如果直接调用xxx（），就是一个普通函数，如果通过new xxx（），就是一个构造函数。 类的定义 12345function People(name){this.name = name}//构造函数中可以添加自身函数People.prototype.xxx =function(){}//原型对象中添加方法,实例调用People.xxx = xxx;//类上添加静态属性People.xxxx = function(){}//类上添加静态方法let p1 = new People(); 类的继承 1234function Animal(){}function People(){}People.prototype = new Animal();let p1 = new People();","link":"/2024/01/18/js7/"},{"title":"Js密码学(一)","text":"介绍常见的编码方式。使用CryptoJS包进行Hex，Base64编码操作。 编码方式 ASCII 128个字符，每个占1个字节 UTF8 字母数字1个字节，汉字3-4个字节 Unicode 字母数字汉字都2个字节 GBK 字母1个字节，汉字2个字节 ANSI win通用字符，根据地区不同改变 Hex 密钥和密文的编码 用0123456789abcdef表示 可以进行修改 4个bit位对应一个字符，2个十六进制字符代表一个字节 ，结果原文2倍 URL 本质是Hex编码，在每一个字节前面加了% 主要是对汉字进行编码 一个汉字转换为%xx%xx%xx Base64 用64个字符表示任意二进制数据 6个bit位对应一个字符，结果比原文多1/3 RSA密钥，图片，密文 为了数据传输安全，通常会将Base64数据进行URL编码，或将+/替换位-_（+服务器接收到后会变成一个空格） A-Z a-z 0-9 +/ 共64 Hex编码 utf8转Hex后长度变为两倍123456789//导文件let CryptoJS = require('./CryptoJS');//不能直接传string 要转换为wordArray//每四个字符转换为wrods中一个数字let ninao = CryptoJS.enc.Utf8.parse('nihaonihao');console.log(ninao)console.log(CryptoJS.enc.Hex.stringify(ninao))//还原 tostring默认hex编码，可以指定为utf8console.log(CryptoJS.enc.Hex.parse('6e6968616f6e6968616f').toString(CryptoJS.enc.Utf8)); Base64编码 utf8转base64 大概5/812345678//hex和b64编码之间的转换都要先转换位wordArray，再进行编码let CryptoJS = require('./CryptoJS');let nihao_wordArray = CryptoJS.enc.Utf8.parse('nihaonihao');let nihao_b64 = CryptoJS.enc.Base64.stringify(nihao_wordArray)console.log(nihao_b64);let nihao_wordArray2 = CryptoJS.enc.Base64.parse(nihao_b64);let nihao_hex = CryptoJS.enc.Hex.stringify(nihao_wordArray);console.log(nihao_hex);","link":"/2023/08/01/jsencrypt1/"},{"title":"Js密码学(二)","text":"介绍消息摘要算法,MD5，SHA，HMAC（MD5，SHA）SM3使用。 消息摘要算法 MD5 SHA1，256，512 HmacMD5 HmacSHA1 HmacSHA256 HmacSHA512 RIPEMD160 HmacRIPEMD160 PBKDF2 EvpKDF SM3 单向散列，哈希算法（rename） 输入长度不固定，输出长度固定，密文不可逆 散列后结果唯一（绝大多数）（MD5，sh1有这问题） 用于校验数据完整性，签名 MD5 SHA MD5 散列后为16个字节，转换为Hex后为32个字符 输入无限长度 1234567let CryptoJS = require('./CryptoJS');//直接用，可以转换为wordArray也可以不转换let nihao_MD5 = CryptoJS.MD5('nihaonihao');//默认输出Hexconsole.log(nihao_MD5+ '');//转Base64console.log(nihao_MD5.toString(CryptoJS.enc.Base64)); SHA sha1散列后为20个字节，转换为Hex后为40个字符 sha1，sha2输入为有限长度 sha3输入为无限长度1234let CryptoJS = require('./CryptoJS');let wordArray = CryptoJS.enc.Utf8.parse('nihaonihao');console.log(CryptoJS.SHA1(wordArray)+'');console.log(CryptoJS.SHA256(wordArray)+''); 1234567891011 //第二种写法//创建一个MD5或SHA，压入数据，加密let md5 = CryptoJS.algo.MD5.create();md5.update('nihaonihao');//分段压入md5.update('nihao');//清空压入数据md5.reset();md5.update('nihao');let cipherText = md5.finalize()+'';console.log(cipherText); HMAC 多了个密钥 密文长度和对应的MD5，SHA一致 123456let CryptoJS = require('./CryptoJS');//默认Hex编码console.log(CryptoJS.HmacMD5('nihao','key')+'');console.log(CryptoJS.HmacSHA1('nihao','key')+'');//转Base64console.log(CryptoJS.HmacSHA1('nihao','key').toString(CryptoJS.enc.Base64)); 1234//第二种写法let hmacSHA1 = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA1.create(),'key');hmacSHA1.update('nihao');console.log(hmacSHA1.finalize()+'') SM3类似于SHA256算法密文长度32个字节，hex编码后64导入sm3文件 1234567//这一步是先将输入数据转成utf-8编码的字节流，然后再转成16进制可见字符var dataBy = Hex.utf8StrToBytes('nihao');var sm3 = new SM3Digest();sm3.update(dataBy,0,dataBy.length); //数据很多的话，可以分多次updatevar sm3Hash = sm3.doFinal(); //得到的数据是个byte数组var sm3HashHex = Hex.encode(sm3Hash,0,sm3Hash.length); //编码成16进制可见字符console.log(sm3HashHex);","link":"/2023/08/01/jsencrypt2/"},{"title":"Js密码学(三)","text":"介绍对称加密算法，DES，3DES，AES，SM4的使用，以及加密模式和填充方式。 对称加密算法 DES，3DES，AES，SM4 加密解密使用相同密钥 可以还原 加密方式（密钥位数） 序列加密 RCA 1-256字节 分组加密 DES 8字节 3DES 24字节 AES 16 24 32字节 SM4 16字节 加密模式和填充方式 加密模式 ECB模式 8个字符加密一次，再拼接起来 CBC模式（包括一个iv向量） 前8个字符和iv异或一次再加密，再和下一段异或，最后拼接起来 填充方式 填充的是字节不是字符，再不满足一个分组时填充满一个分组，刚好满一个分组时在填充一个分组 NoPaddding PKcs7（5） DES 密钥长度64bit 分组长度64bit 实际使用的56个字节 每一个密钥转换为8bit的最后一位不用 1234567891011121314151617181920212223let CryptoJS = require('./CryptoJS');let text = CryptoJS.enc.Utf8.parse('nihao');let key = CryptoJS.enc.Utf8.parse('12345678');let iv = CryptoJS.enc.Utf8.parse('12345678');//没有传cfg默认使用CBC模式Pkcs7填充var cfg ={ iv:iv, //ECB不用iv mode:CryptoJS.mode.CBC, //mode:CryptoJS.mode.ECB, padding:CryptoJS.pad.Pkcs7};let cipherObj = CryptoJS.DES.encrypt(text,key,cfg);console.log(cipherObj.toString())//Base64console.log(cipherObj.ciphertext.toString())//Hex// 9bb1965d9e71548c//解密 只能接受Base64数据let en_text = CryptoJS.enc.Hex.parse('9bb1965d9e71548c').toString(CryptoJS.enc.Base64);let cipherobj = CryptoJS.DES.decrypt(en_text,key,cfg).toString(CryptoJS.enc.Utf8);console.log(cipherobj); 3DES 密钥 24位 前八位加密，中间八位解码，后八位加密 使用方法和DES一样 把DES替换为TrioleDES AES 密钥长度不同 AES128， AES192，AES156 iv长度128位 使用方和DES一样改一下key和iv format和自动生成key iv format 密文/明文的自定义输出（cfg种指定format） CryptoJS自动生成key iv salt ，不需要传iv，cfg，只需要传key，他会自动生成iv 每次生成的key iv salt 均不同 12345678910111213let CryptoJS = require('./CryptoJS');//加密let cipherObj = CryptoJS.AES.encrypt('nihao','12345678');console.log(cipherObj);let cipherText = cipherObj.toString();console.log(cipherText);console.log(cipherObj.key.toString());console.log(cipherObj.iv.toString());console.log(cipherObj.salt.toString());//解密let plainObj = CryptoJS.AES.decrypt(cipherText,'12345678');console.log(plainObj.toString(CryptoJS.enc.Utf8)); SM4 国密算法 密钥128位16字节 使用SM4文件调用SM4算法 123456789101112131415161718function sm4_encrypt_ecb() { let inputBytes = Hex.decode('0123456789abcdeffedcba9876543210'); let key = Hex.decode('0123456789abcdeffedcba9876543210'); let sm4 = new SM4(); let cipher = sm4.encrypt_ecb(key, inputBytes); console.log(Hex.encode(cipher, 0, cipher.length));}function sm4_encrypt_cbc() { let inputBytes = Hex.decode('0123456789abcdeffedcba9876543210'); let key = Hex.decode('0123456789abcdeffedcba9876543210'); let iv = Hex.decode('0123456789abcdeffedcba9876543210'); let sm4 = new SM4(); let cipher = sm4.encrypt_cbc(key, iv, inputBytes); console.log(Hex.encode(cipher, 0, cipher.length));}sm4_encrypt_ecb();sm4_encrypt_cbc(); 其他算法 RIPEMD160 and HmacRIPEMD160(多个密钥) PBKDF2 文本 密钥 keySize iterations（迭代次数） EvpKDF 同上 RC4 RC4Drop 同AES Rabbit RabbitLegacy 流密码","link":"/2023/08/01/jsencrypt3/"},{"title":"Js密码学(四)","text":"介绍非对称加密算法，RSA，SM2和数字加密算法库的使用。 非对称加密算法 RSA SM2 加密解密使用不同密钥的算法 用于加密比较短的数据 公钥和私钥成对生成 公钥加密私钥解密，私钥加密公钥解密 常用1024位，2048位 私钥内包含公钥 密钥格式 PKCS1格式的密钥 前缀 —–BEGIN RSA PRIVATE KEY—– 后缀 —–END RSA PRIVATE KEY—– PKCS8格式的密钥 前缀 —–BEGIN PRIVATE KEY—– 后缀 —–END PRIVATE KEY—– 填充方式 PKCS1Padding 明文最大字节数为密钥字节数-11 密文和密钥是等长的 每次填充不一样结果不一样 NOPadding 明文最大字节数为密钥字节数 密文和密钥是等长的 填充字节为0，加密后密文不变 RSA加密库使用 使用jsencrypt.js文件 使用python可以生成公钥和私钥1234567891011121314151617function getEncrypt(password, publickey){ //实例化一个JSEncrypt对象 var jsEncrypt = new JSEncrypt(); //调用setPublicKey设置公钥 jsEncrypt.setPublicKey(publickey); //调用encrypt方法加密明文 return jsEncrypt.encrypt(password);}var publicKeyBase64 = &quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDxRQHxL/8xZ1EaNmQBGZnpMiCY&quot; + &quot;7gRzog6nDjfBJacytEiVJnJRuq1V/D+JKaXDwetsCnSUaz65LCFHU09OSEYee5oC&quot; + &quot;iI0ql21EA306c91oT/fQpPngQGZHLUtDOUdJVlAKnicCvmR24NqyNKFuY8L0cnB1&quot; + &quot;zcax73Rf+Ctf/lxAOwIDAQAB&quot;;console.log(getEncrypt(&quot;nihaonihaonihaonihaonihaonihaonihaonihaonihaonihaonihaonihaonihao&quot;, publicKeyBase64));//采用PKCS1Padding填充，每次填充不同，结果会变化 返回的是Base64编码的结果 使用RSA.js文件 12345678910111213let password = 'a12345678';function test(password) { setMaxDigits(129); //传入加密指数和加密模数，中间一般没有 var key_to_encode = new RSAKeyPair(&quot;010001&quot;, &quot;&quot;, &quot;978C0A92D2173439707498F0944AA476B1B62595877DD6FA87F6E2AC6DCB3D0BF0B82857439C99B5091192BC134889DFF6&quot;\\ &quot;0C562EC54EFBA4FF2F9D55ADBCCEA4A2FBA80CB398ED501280A007C83AF30C3D1A142D6133C63012B90AB26AC60C898FB6&quot;\\ &quot;6EDC3192C3EC4FF66925A64003B72496099F4F09A9FB72A2CF9E4D770C41&quot;); //传入密钥和明文返回Hex编码的结果动态变化 return encryptedString(key_to_encode, password);}console.log(test(password)); SM2算法库 sm2Test.html vscode安装live serve 右下角Go live运行html文件 数字加密算法（多种算法结合） 随机生成AES密钥AESKey AESKey密钥用于AES加密数据，得到数据密文cipherText 使用RSA对AESKey加密，得到密钥密文cipherKey 提交密钥密文cipherKey和数据密文cipherText给服务器 使用数字加密算法库jsshuziqianming.js1234567891011121314var signData = &quot;nihao&quot;;//PKCS1格式的密钥 前缀 -----BEGIN RSA PRIVATE KEY----- 后缀 -----END RSA PRIVATE KEY-----//PKCS8格式的密钥 前缀 -----BEGIN PRIVATE KEY----- 后缀 -----END PRIVATE KEY-----//必须将完整的密钥传入告诉他是那种密钥格式var privateKeyBase64 = &quot;-----BEGIN PRIVATE KEY-----MIICdwIBADANBgkq&quot; + &quot;此处省略密钥内容&quot;+ &quot;FAmhvYQwwLnifrw=-----END PRIVATE KEY-----&quot;;//使用私钥进行签名，结果不变function doSign() { var signature = KEYUTIL.getKey(privateKeyBase64); var hSig = signature.signString(signData, &quot;sha256&quot;);//小写sha256 return hex2b64(hSig);}console.log(doSign());","link":"/2023/08/01/jsencrypt4/"},{"title":"Js逆向分析(一)","text":"一般Js逆向分析调试思路 首先明确需要逆向的数据是什么类型，一般登陆类型的数据大多以login名为首的数据包，而网页内容数据加密往往可以通过下一页等进行请求，观察数据包，找到数据包是第一步。 观察数据包载荷内容和请求方式 载荷内容 多次尝试对比各个数据变化情况 有部分数据被藏在html页面中 有部分数据是每次请求新的页面中自带的 部分点击登陆前要验证码，验证码验证成功后会产生一个新的数据在点击登陆时一起提交 sign加密算法 token一般是在前面验证码post请求后返回的 请求方式 xhr 下xhr断点，查看调用堆栈，一个一个往前找 点击启动器找可疑的程序（xhr启动器的第一个一般都是sent()不用考虑） 部分提交后密码框会将加密的数据再次提交到密码框，可以在密码框照绑定事件 document 在页面中找点击登陆或者密码框元素进行检查，找到绑定事件，进行搜索 找登陆，密码框元素的id进行全局搜索下断点 搜submit( script 点击启动器找可疑的程序 找到加密代码处理 扒加密代码进行改写 加密代码不一定都在一个文件中，有可能吧部分拆了放在其他文件中，通过单步调试可以找到 如果加密代码中明显定义了4个10字符的数，大概率是hash算法 改写匿名函数，导出全局接口 rsa加密方式，找实例对象函数，设置公钥函数，加密函数一般在一起 使用本地加密包 加密和解密 加密数据在sent()函数之前找 解密函数在sent()函数之后找 注意传入数据的编码格式是Hex还是Base42，也可能是wordArray","link":"/2024/01/18/jsfx/"},{"title":"Js混淆(一)","text":"常见混淆手法，编码混淆、异或混淆、数组混淆 利用Js调用函数的两种形式12console.log(&quot;hello world&quot;);console['log'](&quot;hello world&quot;); 将字符串使用十六进制编码表示12345678910function hexEnc(code){ for(var hexStr = [],i=0,s;i&lt;code.length;i++){ s = code.charCodeAt(i).toString(16); hexStr += &quot;\\\\x&quot;+s; } return hexStr;}console.log(hexEnc('log'));// \\x6c\\x6f\\x67console['\\x6c\\x6f\\x67'](&quot;hello world&quot;); 将字符串使用Unicode编码表示1234567891011function unicodeEnc(str){ var value = ''; for (var i = 0; i &lt; str.length; i++){ value += '\\\\u' + (&quot;0000&quot; + parseInt(str.charCodeAt(i)).toString(16)).substr(-4); } return value;}console.log(unicodeEnc('console'));// \\u0063\\u006f\\u006e\\u0073\\u006f\\u006c\\u0065//console.log(&quot;hello world&quot;);就变成这样了\\u0063\\u006f\\u006e\\u0073\\u006f\\u006c\\u0065['\\x6c\\x6f\\x67'](&quot;hello world&quot;); 将字符串使用ASCII码表示12345678910111213141516171819function stringToByte(str) { var byteArr = []; for(var i = 0; i &lt; str.length; i++) { byteArr.push(str.charCodeAt(i)); } return byteArr;}console.log(stringToByte('console.log(&quot;hello&quot;)'));// [// 99, 111, 110, 115, 111, 108,// 101, 46, 108, 111, 103, 40,// 34, 104, 101, 108, 108, 111,// 34, 41// ]console.log('x'.charCodeAt(0));console.log(String.fromCharCode(120,121));console.log(String.fromCharCode(99, 111, 110, 115, 111, 108,101, 46, 108, 111, 103, 40,34, 104, 101,108, 108, 111,34, 41));//使用eval将代码运行eval(String.fromCharCode(99, 111, 110, 115, 111, 108,101, 46, 108, 111, 103, 40,34, 104, 101,108, 108, 111,34, 41)); 字符串base64加密123456789101112console.log(btoa(&quot;hello&quot;));//aGVsbG8=console.log(atob(&quot;aGVsbG8=&quot;));//字符串拼接console.log(btoa(&quot;hello&quot;));console.log(btoa(&quot;world&quot;));//aGVsbG8=//d29ybGQ=var a = 'aGVsbG8=';var b = 'd29ybGQ=';console.log(atob(a)+atob(b)); 异或加密常量1234console.log(10086^10000);// 118// 当我们要输出10086可以console.log(118^10000); 使用数组进行混淆123var arr = ['console','log','hello','world',118];globalThis[arr[0]][arr[1]](arr[2]+arr[3],arr[4]^10000);//helloworld 10086 打乱数组123456789101112131415161718192021222324252627var arr = ['console','log','hello','world',118];//打乱数组(function(arr,num) { var shuffle = function(num) { while(--num) { arr.unshift(arr.pop()); } }; shuffle(++num);}(arr,0x20));console.log(arr);//还原数组(function(arr,num) { var shuffle = function(num) { while(--num) { arr.push(arr.shift()); } }; shuffle(++num);}(arr,0x20));console.log(arr);globalThis[arr[0]][arr[1]](arr[2]+arr[3],arr[4]^10000);//[ 'world', 118, 'console', 'log', 'hello' ]//[ 'console', 'log', 'hello', 'world', 118 ]//helloworld 10086","link":"/2023/08/21/jshunxiao1/"},{"title":"混淆处理思路","text":"一般混淆处理思路，快速定位关键代码 分析混淆代码12_0x5bd8cd[_0x1bcb4d(0x60d, ')XMs')](_0x3a0095[_0x1bcb4d(0xfb, 'acaL')], _0x304f48[_0x1bcb4d(0x115, 'WwBk')], !![]), _0x5bd8cd['send'](_0x366b73); 将_0x1bcb4d(0x60d, ')XMs')输入控制台得到open 同样的方法处理后就得到 12XMLHttpRequest['open'](&quot;post&quot;, &quot;https://api.superbed.cn/upload&quot;,true);XMLHttpRequest['send'](FormData{}); 处理_0x3a0095加密取值函数中包含大量明文数据 1234567891011121314_0x3a0095 = { &quot;DPbSh&quot;: &quot;上传结束&quot;, &quot;iXJWT&quot;: &quot;/token&quot;, &quot;BkkNb&quot;: &quot;.login&quot;, &quot;KiFgN&quot;: &quot;vggaa&quot;, &quot;RhRik&quot;: &quot;upload&quot;, &quot;sXvtO&quot;: &quot;IGeNd&quot;, &quot;RgDgb&quot;: &quot;LDuyL&quot;, &quot;VBgTQ&quot;: &quot;token&quot;, &quot;ahVPu&quot;: &quot;-*-&quot;, &quot;YFkhX&quot;: &quot;nonce&quot;, &quot;tcFUl&quot;: &quot;sign&quot;, &quot;weBfW&quot;: &quot;_xsrf&quot;} 可以看出它将加密的字符串解密后存入一个对象中，然后根据对象的key获取对应的值 &quot;tcFUl&quot;: &quot;sign&quot; 找到对应的加密字符串 定位到字符串加密函数，在return处下条件断点 根据条件断点进行单步调试找关键加密代码 通过加密字符串全局去找在那使用过下断点 注意关键词CryptoJS、AES、encrypt、decrypt、append…","link":"/2024/01/20/jshunxiao3/"},{"title":"Mongodb(一)","text":"Mongodb安装 基本操作 安装 brew tap mongodb/brew brew install mongodb-community 安装信息： 配置文件：**/usr/local/etc/mongod.conf** 日志文件路径：**/usr/local/var/log/mongodb** 数据存放路径：**/usr/local/var/mongodb** brew 启动： 1brew services start mongodb-community 查看http://127.0.0.1:27017/ 显示It looks like you are trying to access MongoDB over HTTP on the native driver port.表示开启 brew 停止： 1brew services stop mongodb-community 一个数据库包含多个集合，一个集合包含多个文档，一个文档为一句JSON键值对 数据类型：null，布尔型，数字，字符串，数组，二进制，日期，代码 基本操作 进入数据库：1mongosh 创建数据库：1use datademo 展示数据库：1show dbs 展示数据库集合：1show collections 删除数据库：1db.dropDatabase() 插入数据：1db.datatest.insert({&quot;name&quot;:&quot;test&quot;}) 插入多条数据：1db.datatest.insertMany([{&quot;name1&quot;:&quot;test1&quot;},{&quot;name2&quot;:&quot;test2&quot;}]) 读取数据：123db.datatest.findOne()db.datatest.find()db.datatest.find().pretty() 美化 更新数据库：12db.datatest.updateOne({&quot;name&quot;:&quot;test&quot;},{$set:{&quot;name&quot;:&quot;test3&quot;}})db.datatest.updateOne(db.datatest.findOne({&quot;name&quot;:&quot;test&quot;}),{$set:{&quot;name&quot;:&quot;test3&quot;}}) 删除数据：1db.datatest.remove({&quot;name&quot;:&quot;test3&quot;}) 删除所有符合条件的数据 删除数据库：1db.datatest.drop()","link":"/2023/11/13/mongo1/"},{"title":"Js混淆(二)","text":"常见混淆手法，花指令、jsfuck、流程平坦化、逗号表达式混淆、eval处理 花指令 添加一些无用代码123456789var a = 100;var b = 200;function test(a,b){ return func(a,b);}function func(a,b){ return a+b;}console.log(test(a,b)); jsfuck 使用、+！[]表示任意字符 根据()分段放入浏览器中运行测试，再将运行结果进行替换 流程平坦化 使用switch case语句123456789function test(){ var a = 100; var b = a+200; var c = b+300; var d = c+400; var e = d+500; return e;}console.log(test()); 使用switch case改写12345678910111213141516171819202122232425function test2(){var index = 0;while(true){ switch(++index){ case 3: var c = b+300; break; case 1: var a = 100; break; case 5: var e = d+500; break; case 2: var b = a+200; break; case 4: var d = c+400; break; case 6: return e; }}}console.log(test2()); 定义arr数组切割传入switch1234567891011121314151617181920212223242526function test3(){ var arr = 'd|e|q|g|h|c'.split('|'); var index = 0; while(true){ switch(arr[index++]){ case 'q': var c = b+300; break; case 'd': var a = 100; break; case 'h': var e = d+500; break; case 'e': var b = a+200; break; case 'g': var d = c+400; break; case 'c': return e; } }}console.log(test3()); 逗号表达式混淆12345678910function test(a,b,c,d,e){//return 只会返回最后一个表达式的值 return a = 100,b = a+200,c = b+300,d = c+400,e = d+500,e;}console.log(test());function test2(a,b,c,d,e){ return e=(e=(d=(c=(b=(a=100,a+200),b+300),c+400),d+500));}console.log(test2()); return 不光可以返回一个值，还可以返回一个函数 123var a = 100;var b = (b=200,add)(a,b);console.log(b); eval加密 加密字符串放入eval中解密后执行 解密将eval改为console.log就可以了 检测代码是否格式化 原理：利用正则匹配，检测代码是否被格式化，当检测到代码被格式化后进行内存爆破 内存爆破：利用死循环不断写入内存知道内存溢出","link":"/2023/08/22/jshunxiao2/"},{"title":"Mongodb(二)","text":"mongodb的ID 特殊查询 pymongo mongodb的ID 每插入一条文档都有一个默认ID，而且必须存在 属于Objectid类型，有12个字节空间，共24个十六进制数字 0 1 2 3 时间戳，提供秒级别的唯一，能够按照时间顺序插入 4 5 6 机器标识符 7 8 不同进程PID 9 10 11 计数器：相同进程累加 mongdb查询 全部返回 1db.datatest.find() 查询条件小于等于5的 lt小于gt大于 1db.datatest.find({_id:{$lt:10}}) 查询条件在1，2，3里面的 1db.datatest.find({_id:{$in:[1,2,3]}}) 查询存在某项条件的 1db.datatest.find({id:{$exists:true}}) 查询显示：0为不显示，1为显示 1db.datatest.find({},{_id:0}) pymongo123456789101112131415161718192021222324252627282930313233343536import pymongo# link to mongodbclient=pymongo.MongoClient(&quot;mongodb://127.0.0.1:27017&quot;)# select databasedb=client['datademo']# select collectioncol=db['test']mydict={&quot;name&quot;:&quot;python&quot;}# insert datares=col.insert_one(mydict)print(res)# insert_many datamylist=[ {&quot;name&quot;:&quot;C++&quot;},{&quot;name&quot;:&quot;Lua&quot;}]# res=col.insert_many(mylist)# print(res)for num,i in enumerate(mylist): i['id']=num col.insert_one(i)# findres=col.find({},{&quot;_id&quot;:0})for r in res: print(r)# updatacol.update_one(mydict,{&quot;$set&quot;:{&quot;name&quot;:&quot;python3&quot;}})# deletecol.delete_many({})","link":"/2023/11/13/mongo2/"},{"title":"MySql(一)","text":"MySql在mac上启动不了执行命令 数据库基本用法 MySql启动不了执行命令-sudo chown -RL root:mysql /usr/local/mysql-sudo chown -RL mysql:mysql /usr/local/mysql/data-sudo /usr/local/mysql/support-files/mysql.server start 关闭MySql mysql.server stop mysql -uroot -p 登陆 修改密码为root ALTER USER 'root'@'localhost' IDENTIFIED BY 'root'; 数据库操作 显示数据库mysql&gt; show databases; 创建数据库mysql&gt; create database test1; 使用数据库mysql&gt; use test1; 先使用数据库再展示数据库的表mysql&gt; use test1; 删除数据库mysql&gt; drop database test1; 表操作 创建表 创建表名为user 内有name age date属性mysql&gt; create table user(name varchar(10),age int(2),date date); 查看表格式mysql&gt; desc user; 查看详细描述mysql&gt; show create table user; 修改表 修改 修改name为varchar（20）mysql&gt; alter table user modify name varchar(20); 改名 修改age为age1 int（4）mysql&gt; alter table user change age age1 int(4); 新增 新增test行mysql&gt; alter table user add column test varchar(10); 删除 删除test行mysql&gt; alter table user drop column test; 表名 修改整个表名mysql&gt; alter table user rename user1; 删除表mysql&gt; drop table user;","link":"/2023/10/25/mysql1/"},{"title":"异步爬虫使用","text":"异步爬虫爬取图片 异步验证proxy 异步爬虫爬取图片 调用DownloadImage，List形式传入要下载的图片url 对于图片后缀suffix默认jpg 需要其他的再加12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import asyncioimport aiohttpfrom aiohttp import TCPConnectorimport osdef DownloadImage(urls='',address='',suffix='jpg',): async def download_image(url,address,suffix,tmp,): async with aiohttp.ClientSession(connector=TCPConnector(ssl=False)) as session: print('正在下载{}'.format(url)) response = await session.get(url) tmps = str(tmp) if response.status == 200: image_data = await response.read() if address =='': if not os.path.exists('images'): os.makedirs('images') print(&quot;文件夹已成功创建！&quot;) else: pass # 将获取到的图片数据保存为文件 if suffix == 'jpg': file_path = 'images'+'/'+url.split('/')[-1]+tmps+'.jpg' # 设置保存路径及名称 elif suffix == 'png': file_path = 'images'+'/'+url.split('/')[-1]+tmps+'.png' elif suffix == 'jpeg': file_path = 'images'+'/'+url.split('/')[-1]+tmps+'.jpeg' with open(file_path, 'wb') as f: f.write(image_data) print('{}图片已保存'.format(file_path)) else : if not os.path.exists(address): os.makedirs(address) print(&quot;文件夹已成功创建！&quot;) else: pass if suffix == 'jpg': file_path = address + '/'+url.split('/')[-1]+tmps+'.jpg' # 设置保存路径及名称 elif suffix == 'png': file_path = address + '/'+url.split('/')[-1]+tmps+'.png' elif suffix == 'jpeg': file_path = address + '/'+url.split('/')[-1]+tmps+'.jpeg' with open(file_path, 'wb') as f: f.write(image_data) print('{}图片已保存'.format(file_path)) else: print('无法下载图片') # 定义要下载的图片URL列表 urls = urls loop = asyncio.get_event_loop() tasks = [] tmp = 1 for url in urls: task = loop.create_task(download_image(url,address,suffix,tmp)) tasks.append(task) tmp += 1 loop.run_until_complete(asyncio.wait(tasks)) loop.close() 异步验证proxy1234567891011121314151617181920212223def Proxy_test(proxies): tasks = [] enable_proxy = [] test_url = 'https://httpbin.org/ip' async def get_status_code(test_url,my_proxy): async with aiohttp.ClientSession(connector=TCPConnector(ssl=False),) as session: try: response = await session.get(url=test_url,proxy=my_proxy,timeout=10) if response.status == 200: print('{}代理可用'.format(my_proxy)) enable_proxy.append(my_proxy) except: print('{}代理不可用'.format(my_proxy)) pass loop = asyncio.get_event_loop() for my_proxy in proxies: task = loop.create_task(get_status_code(test_url,my_proxy)) tasks.append(task) loop.run_until_complete(asyncio.wait(tasks)) loop.close()","link":"/2024/01/16/myaio/"},{"title":"MySql(三)","text":"存储引擎 MySQL事务 表连接 存储引擎 MySql的存储引擎是插件式的，支持多种引擎 5.0支持 MyISAM InnoDB BDB MEMORY等 InnoDB BDB是事务性安全表 5.5之后默认为InnoDB，之前均为MyISAM mysql&gt; show engines;查看支持引擎 mysql&gt; alter table xx engine=myisam;修改引擎 MyISAM 不支持事务，优点是速度快 如果主要以select，insert为主的可以使用 InnoDB 提供事务（提交，回滚，崩溃恢复） 比MyISAM速度慢，磁盘占用多 MEMORY 使用内存中的数据来建表，数据放在内存中，速度很快，服务关闭时数据丢失 MySQL事务 四大特性 原子性：一个事务中的所有操作，要么全部完成要么全部不完成，出现错误会回滚到事务开始之前。 一致性：在事务开始之前和结束之后，数据库的完整性没有被破坏，表示写入数据必须完全符合所有预设规则。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的操作，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。 持久性：事务结束后，对数据的修改是永久的。 操作 mysql&gt; start transaction; 开启事务 mysql&gt; commit; 提交内容 mysql&gt; rollback; 回滚 mysql&gt; commit and chain; 提交并开启新事务 表锁：进行表锁后只能有一个线程去操作表，其他线程会被阻塞 mysql&gt; lock table xxx write；xxx表的写权限上锁，其他不受影响 mysql&gt; unlock tables; 解锁 表连接 通常多个表之间的数据会有联系，同时选择多个关联的表 内连接：选出两张表中相匹配的记录，本质上是找两个表的相同部分 select xxx,xxx,xxx from 表1，表2 where 表1.xxx=表2.xxx; 外连接：本质上是包含某一个表的全部信息 左外链接：包含所有左边表的记录，右表没有和他匹配的为NULL select xxx,xxx,xxx from 表1 left join 表2 on 表1.xxx=表2.xxx; 右外连接：包含所有右边表的记录，左表没有和他匹配的为NULL select xxx,xxx,xxx from 表2 right join 表1 on 表1.xxx=表2.xxx; 子查询 当进行查询的时候，查询条件需要另一个SQL命令的结果 子查询需要两张表的字段名字一致 alter table 表1名 change xxx yyy int 把表1中xxx改为yyy select * from 表1 where xxx in (select xxx from xxx); in可以用=替代 select * from 表1 where xxx = (select xxx from xxx limit 1);","link":"/2023/11/07/mysql3/"},{"title":"MySql(二)","text":"表操作 数据类型 表操作 插入数据 insert into user1 values(“nihao”,”20”,”2021-01-29”); 向user1插入(“nihao”,”20”,”2021-01-29”) insert into user1(name) values(“buhao”),(“test”); 向user1的name属性插入(“buhao”),(“test”)，其他属性为NULL 查询数据 select * from user1; 查询全部user1数据 select * from user1 where age1=”20”; 查询全部user1数据中age1条件为20的所有数据 select name,age1 from user1; 查找user1数据中所有name，age1的数据 更新数据 update user1 set age1=30 where name=”buhao”; 更新name条件为buhao的数据的age1为30 删除数据 delete from user1 where age1=30; 删除age1条件为30的全部数据 数据类型 tinyint int bigint float double bit int(5)指的是具体宽度显示，插入超过数据宽度不会被截断 默认int宽度为10，使用zerofill 用0填充 alter table t1 modify id2 int(5) zerofill; 如果用int会直接改为10宽度 修改查询bit数据的显示方式，以hex显示，以bin显示 select id3,hex(id3),bin(id3) from t1; 字符串类型 char 0-255 varchar 0-65535 text 0-65535字节 mediumtext 0-167772150字节 longtext 0-4294967295字节 二进制字符串 binary varbinary（大一些） 检索时char会删除尾部空格 length（）计算长度 concat（）查询时连接一个标志 mysql&gt; select length(v1),concat(“biaozhi”) from vc; 日期类型 类型 date 年月日 datetime 年月日时分秒 默认 now() timestamp 年月日时分秒 默认 current_timestamp() time 时分秒 year 年份 插入默认 now() current_timestamp() mysql&gt; insert into dd values(now(),now(),now(),now(),now()); 设置默认 mysql&gt; alter table dd modify d2 datetime default now(); mysql&gt; alter table dd modify d3 timestamp default current_timestamp(); date time year 没有默认值，但是可以自行设置一个固定的默认值方法同上。","link":"/2023/11/07/mysql2/"},{"title":"MySql(四)","text":"pymysql 使用python多线程操作数据库 使用python操作MySql1234567891011121314151617181920212223242526import pymysqldb = pymysql.connect(host='localhost', user='root', password='root', database='test1', port=3306)# 游标cursor = db.cursor()# 搜索数据cursor.execute('show tables')data = cursor.fetchall()print(data)# 插入数据 如果你的表的引擎是Innodb事务# 默认吧事务开起来 所以需要提交try: cursor.execute(&quot;insert into vc values('123','123')&quot;) cursor.execute(&quot;select * from vc&quot;) data = cursor.fetchall() print(data) #提交 #cursor.execute(&quot;commit&quot;) db.commit()except: db.rollback()cursor.close()db.close() 使用多线程操作数据库 pymysql不支持并发，需要使用锁123456789101112131415161718192021222324252627282930313233343536373839404142import pymysqlimport threadingfrom threading import Locklock = Lock()db = pymysql.connect(host='localhost', user='root', password='root', database='test1', port=3306)# 写入数据def write_con(): try: print(&quot;写入数据&quot;) # 获取游标 cursor = db.cursor() lock.acquire() cursor.execute(&quot;insert into vc values('321','321')&quot;) db.commit() lock.release() except: db.rollback()# 查询数据def read_con(): try: print(&quot;查询数据&quot;) cursor = db.cursor() lock.acquire() cursor.execute(&quot;select * from vc&quot;) data = cursor.fetchall() print(data) lock.release() except: db.rollback()t1 = threading.Thread(target=write_con)t2 = threading.Thread(target=read_con)t1.start()t2.start()t1.join()t2.join()print(&quot;over&quot;)db.close()","link":"/2023/11/07/mysql4/"},{"title":"MySql(五)","text":"sqlalchemy使用 基础使用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, Integer, String,Date,UnicodeTextfrom sqlalchemy.orm import sessionmakerfrom sqlalchemy import create_enginefrom datetime import datetime# 引擎engine = create_engine(&quot;mysql+pymysql://root:root@127.0.0.1:3306/test1&quot;)#创建表Base = declarative_base()class User(Base): __tablename__ = 'user' id = Column(Integer, primary_key=True)#主键 索引 不需要你添加 id 自增 name = Column(String(32)) age = Column(Integer,nullable=True)#可以为空 date=Column(Date,default=datetime.now())#默认 desc=Column(UnicodeText,nullable=True)#定义初始化数据库函数def init_db(): Base.metadata.create_all(engine)#顶固删除数据库函数def drop_db(): Base.metadata.drop_all(engine)drop_db()init_db()Session = sessionmaker(bind=engine) #创建sessionsession = Session()# 增obj = User(name=&quot;nihao&quot;, age=30,desc=&quot;nihao&quot;) #添加单条session.add(obj) #加入到队列session.add_all([ #添加多条 User(name=&quot;lry&quot;), User(name=&quot;abu&quot;),])session.commit() # 添加到sql#删session.query(User).filter(User.id &gt;1).delete()session.commit()#改 修改内容为字典session.query(User).filter(User.name=='xjb').update({&quot;name&quot; : &quot;xjb2&quot;,&quot;age&quot;:100})session.commit()#查ret = session.query(User).all() # 查询所有print(ret[0].name,ret[0].desc)ret = session.query(User.name, User.age).all()ret = session.query(User).filter(User.age&gt;10).all()ret = session.query(User).filter(User.age&gt;10).first()# ret是一个对象列表。这个对象可以通过 “对象[索引].字段”来获取对应的值ret = session.query(User).all() #查询列表所有数据#print(ret[0].name) #结果为元组，可通过下标的形式for i in ret: #循环元组， print(i.name,i.age,i.desc,i.date) 多线程数据库连接池1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import threadingfrom sqlalchemy.orm import sessionmakerfrom sqlalchemy import create_engine# User表from User import Userfrom threading import Threadengine = create_engine( &quot;mysql+pymysql://root:root@127.0.0.1:3306/test1&quot;, max_overflow=3, # 超过连接池大小外最多创建的连接 pool_size=10, # 连接池大小 pool_timeout=30, # 池中没有线程最多等待的时间，否则报错)Session = sessionmaker(bind=engine)def task_add(): # 去连接池中获取一个连接 session = Session() try: # 向表内添加线程信息 user=User(name=threading.currentThread().getName()) session.add(user) session.commit() print(threading.currentThread().getName()) except: session.rollback() # 将连接交还给连接池 session.close()def task_query(): # 去连接池中获取一个连接 session = Session() try: user=session.query(User).all() print(threading.currentThread().getName(),user) except: session.rollback() # 将连接交还给连接池 session.close()threads=[]for i in range(10): t=Thread(target=task_add) threads.append(t)for j in range(10): t=Thread(target=task_query) threads.append(t)for t in threads: t.start() t.join() 储存json123456789101112131415161718192021222324252627282930313233343536373839404142from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, Integer, String,Date,UnicodeText,JSONfrom sqlalchemy.orm import sessionmaker,relationshipfrom sqlalchemy import create_engine,ForeignKeyfrom datetime import datetimeengine = create_engine(&quot;mysql+pymysql://root:root@127.0.0.1:3306/test1&quot;)#创建表Base = declarative_base()class JData(Base): __tablename__ = 'jdata' id = Column(Integer, primary_key=True)#主键 索引 不需要你添加 id 自增 data=Column(JSON)#定义初始化数据库函数def init_db(): Base.metadata.create_all(engine)#顶固删除数据库函数def drop_db(): Base.metadata.drop_all(engine)drop_db()init_db()Session = sessionmaker(bind=engine) #创建sessionsession = Session()# 增# 以字典的形式添加session.add_all([ #添加多条 JData(data={&quot;name&quot;:&quot;python&quot;,&quot;time&quot;:1}), JData(data={&quot;name&quot;:&quot;go&quot;,&quot;time&quot;:2}),])session.commit() # 添加到sqlret = session.query(JData).all() #查询列表所有数据for i in ret: #循环元组， print(i.id,i.data) 通过外键进行多表查询 通过（ForeignKey）外键关联两张表 通过relationship定义两表相互访问时的名字123456789101112131415161718192021222324252627from sqlalchemy.orm import sessionmaker,relationshipfrom sqlalchemy import create_engine,ForeignKeyclass Myclass(Base): __tablename__ = 'class' id = Column(Integer, primary_key=True)#主键 索引 不需要你添加 id 自增 name = Column(String(32)) #通过relationship定义两表相互访问时的名字 students=relationship('User',back_populates='myclass') def __str__(self): return f'id{self.id} name:{self.name}'class User(Base): __tablename__ = 'user' id = Column(Integer, primary_key=True)#主键 索引 不需要你添加 id 自增 name = Column(String(32)) age = Column(Integer,nullable=True) date=Column(Date,default=datetime.now()) desc=Column(UnicodeText,nullable=True) # 通过外键关联ForeignKey class_id=Column(Integer,ForeignKey(Myclass.id)) myclass=relationship(&quot;Myclass&quot;,back_populates='students')ret = session.query(Myclass).all() #查询列表所有数据for i in ret: #循环元组， print(i.id,i.name,i.students)","link":"/2023/11/07/mysql5/"},{"title":"Python密码学(一)","text":"介绍使用python实现消息摘要算法，MD5，SHA，HMAC（MD5，SHA）和SM3算法 消息摘要算法 消息摘要算法是一种可以将文本或其他信息压缩成简短的字符串的算法。这些字符串被称为消息摘要算法或散列值。 作用：验证文件的完成性，在加密数据库中存储密码 MD和SHA（哈希函数） 给定输入，返回相同的输出 输出长度固定，输入长度不同 不可逆 MD51234567from Crypto.Hash import MD5word = MD5.new(b'nihao')print(word.hexdigest())word2 = MD5.new()word2.update(b'ni')word2.update(b'hao')print(word2.hexdigest()) SHA1234567from Crypto.Hash import SHA256,SHA3_256word3 = SHA256.new(b'nihao')word4 = SHA256.new()word4.update(b'ni')word4.update(b'hao')print(word3.hexdigest())print(word4.hexdigest()) HMAC hash算法的进阶版，在hash计算过程中混入了key（加盐），防止彩虹表破解 选择一种hash函数，SHA1，SHA256 生成密钥，并将其与消息一起输入 12345678910111213import hmacfrom Crypto.Random import get_random_bytesfrom Crypto.Hash import MD5,SHA512data = '你好'.encode()key = get_random_bytes(16)#key = b'123456789'#加盐后的res = hmac.new(key,msg=data,digestmod=MD5).hexdigest()print('hmac',res)# 原版md5res2 = MD5.new(data).hexdigest()print('md5',res2) SM3 SM国密算法 SM31234567#sm3的使用 约等于SHA256from gmssl import sm3data = 'nihao'.encode()result = sm3.sm3_hash(sm3.bytes_to_list(data=data))print(result)print(len(result))","link":"/2023/08/01/pycrypt1/"},{"title":"Python密码学(二)","text":"介绍使用python实现对称加密算法，DES，3DES，AES，RC4和SM4算法。 对称加密算法 加密mode ECB模式：将明文简单的按照128bit为一个分块进行切割，在把每个分块进行AES加密，然后将密文拼接，如果长度不足128位，则会补全。 CBC模式：先对第一个明文块加密，之后每一个与前一个密文进行异或后再加密，每个密文块都依赖前面所以明文块。第一个明文块要用到IV，在CBC模式下IV要先与第一个明文块进行异或得到第一个明文块，在对后续加密。 OFB模式 CTR模式 CFB模式 DES，3DES DES 对称加密 64bit 8个字节（有效长度为56bit） 16轮迭代加密 56位密钥对64位明文进行加密 不安全 使用的模式mode和AES一致5种 12345678910111213141516171819202122232425from Crypto.Cipher import DESfrom Crypto.Util.Padding import pad,unpadfrom Crypto.Random import get_random_byteskey = get_random_bytes(8)def encrypt_des(data): # 模式和AES一样的用法 des = DES.new(key,DES.MODE_ECB) res = des.encrypt(pad(data,8)) print('加密结果',res) return resdef decrypt_des(data): # 模式和AES一样的用法 des = DES.new(key,DES.MODE_ECB) res = des.decrypt(data) print('解密结果',unpad(res,8).decode()) return unpad(res,8)if __name__ == '__main__': data = '你好'.encode() res = encrypt_des(data) decrypt_des(res) 3DES 三倍56位加密 前56位加密，中间56位解密，后56位加密 123456789101112131415161718192021222324from Crypto.Cipher import DES,DES3from Crypto.Util.Padding import pad,unpadfrom Crypto.Random import get_random_byteskey = get_random_bytes(24)def encrypt_des(data): # 模式和AES一样的用法 des = DES3.new(key,DES3.MODE_ECB) res = des.encrypt(pad(data,8)) print('加密结果',res) return resdef decrypt_des(data): # 模式和AES一样的用法 des = DES3.new(key,DES3.MODE_ECB) res = des.decrypt(data) print('解密结果',unpad(res,8).decode()) return unpad(res,8)if __name__ == '__main__': data = '你好'.encode() res = encrypt_des(data) decrypt_des(res) AES AES是一种常用的对称加密算法，使用密钥加密，使用密钥解密 特点： 速度快，安全 长度128位，192位，256位 模式 ECB模式：将明文简单的按照128bit为一个分块进行切割，在把每个分块进行AES加密，然后将密文拼接，如果长度不足128位，则会补全。 1234567891011121314151617181920212223242526from Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad,unpadfrom base64 import b64decode,b64encodekey = get_random_bytes(16)# 加密def encrypt_ecb(data): aes=AES.new(key,AES.MODE_ECB) res=aes.encrypt(pad(data,16)) print(b64encode(res).decode()) return b64encode(res).decode()# cBUc8RKHih7RkWRG2e9C2Q==# 解密def decrypt_ecb(data): aes=AES.new(key,AES.MODE_ECB) res=aes.decrypt(b64decode(data.encode())) print(unpad(res,16).decode()) if __name__=='__main__': data = '你好'.encode() res=encrypt_ecb(data) decrypt_ecb(res) CBC模式：先对第一个明文块加密，之后每一个与前一个密文进行异或后再加密，每个密文块都依赖前面所以明文块。第一个明文块要用到IV，在CBC模式下IV要先与第一个明文块进行异或得到第一个明文块，在对后续加密 12345678910111213141516171819202122232425from Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad,unpadfrom base64 import b64decode,b64encodekey = get_random_bytes(16)iv = get_random_bytes(16)# 加密def encrypt_cbc(data): aes=AES.new(key,AES.MODE_CBC,iv=iv) res=aes.encrypt(pad(data,16)) print(b64encode(res).decode()) return b64encode(res).decode()# R3jIvRc7SZx88iRa3yEMfw==# 解密def decrypt_cbc(data): aes=AES.new(key,AES.MODE_CBC,iv=iv) res=aes.decrypt(b64decode(data.encode())) print(unpad(res,16).decode()) if __name__=='__main__': data = '你好'.encode() res=encrypt_cbc(data) decrypt_cbc(res) OFB模式 12345678910111213141516171819202122232425from Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad,unpadfrom base64 import b64decode,b64encodekey = get_random_bytes(16)iv = get_random_bytes(16)# 加密def encrypt_ofb(data): aes=AES.new(key,AES.MODE_OFB,iv=iv) res=aes.encrypt(pad(data,16)) print(b64encode(res).decode()) return b64encode(res).decode()# SoNsyX8HqZrHxAlUtFA34w==# 解密def decrypt_ofb(data): aes=AES.new(key,AES.MODE_OFB,iv=iv) res=aes.decrypt(b64decode(data.encode())) print(unpad(res,16).decode()) if __name__=='__main__': data = '你好'.encode() res=encrypt_ofb(data) decrypt_ofb(res) CTR模式 1234567891011121314151617181920212223242526from Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad,unpadfrom base64 import b64decode,b64encodekey = get_random_bytes(16)nonce = get_random_bytes(8)# 加密def encrypt_ctr(data): aes=AES.new(key,AES.MODE_CTR,nonce=nonce) res=aes.encrypt(pad(data,16)) print(b64encode(res).decode()) return b64encode(res).decode()# UW9GRltpxIrUF1M80gI/sw==# 解密def decrypt_ctr(data): aes=AES.new(key,AES.MODE_CTR,nonce=nonce) res=aes.decrypt(b64decode(data.encode())) print(unpad(res,16).decode()) if __name__=='__main__': data = '你好'.encode() res=encrypt_ctr(data) decrypt_ctr(res) CFB模式 12345678910111213141516171819202122232425from Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad,unpadfrom base64 import b64decode,b64encodekey = get_random_bytes(16)iv = get_random_bytes(16)# 加密def encrypt_cfb(data): aes=AES.new(key,AES.MODE_CFB,iv=iv) res=aes.encrypt(pad(data,16)) print(b64encode(res).decode()) return b64encode(res).decode()# nwqQbIwBjQ/VfumOJk6KEg==# 解密def decrypt_cfb(data): aes=AES.new(key,AES.MODE_CFB,iv=iv) res=aes.decrypt(b64decode(data.encode())) print(unpad(res,16).decode()) if __name__=='__main__': data = '你好'.encode() res=encrypt_cfb(data) decrypt_cfb(res) RC4 字节流加密—-以此加密明文中每一个字节，解密也是如此 RC4密钥长度1-256字节，最好128位以上，安全 12345678910111213141516171819from Crypto.Cipher import ARC4from Crypto.Random import get_random_bytesdata = '你好'.encode()key = get_random_bytes(16)def encrypt_arc4(data,key): arc = ARC4.new(key) res = arc.encrypt(data) print(res) return resdef decrypt_arc4(data,key): arc = ARC4.new(key) res = arc.decrypt(data) print(res.decode()) return resif __name__ == '__main__': res = encrypt_arc4(data,key) decrypt_arc4(res,key) SM4 SM4对称加密算法 123456789101112131415161718192021222324#ecb模式from gmssl import sm4from Crypto.Random import get_random_bytes#加密mode = 0def encrypt_sm4(data): SM4 = sm4.CryptSM4() SM4.set_key(key,mode=0) res = SM4.crypt_ecb(data) print('加密结果',res) return res#解密mode =1def decrypt_sm4(data): SM4 = sm4.CryptSM4() SM4.set_key(key,mode=1) res = SM4.crypt_ecb(data) print('解密结果',res.decode()) return resif __name__ == '__main__': key = get_random_bytes(16) data = '你好'.encode() res = encrypt_sm4(data) decrypt_sm4(res) 12345678910111213141516171819202122232425#cbc模式from gmssl import sm4from Crypto.Random import get_random_bytes#加密mode = 0def encrypt_sm4(data): SM4 = sm4.CryptSM4() SM4.set_key(key,mode=0) res = SM4.crypt_cbc(iv,data) print('加密结果',res) return res#解密mode =1def decrypt_sm4(data): SM4 = sm4.CryptSM4() SM4.set_key(key,mode=1) res = SM4.crypt_cbc(iv,data) print('解密结果',res.decode()) return resif __name__ == '__main__': key = get_random_bytes(16) iv = get_random_bytes(16) data = '你好'.encode() res = encrypt_sm4(data) decrypt_sm4(res)","link":"/2023/08/01/pycrypt2/"},{"title":"Python密码学(三)","text":"介绍使用python实现非对称加密算法，RSA，SM2，数字签名算法。 非对称加密算法RSA 两个不同密钥，一个用来加密一个用来解密 安全性强与AES但速度慢 先生成密钥对在调用加密器PKCS1_OAEP再进行加密 1234567891011121314151617181920212223242526from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEP#生成密钥key = RSA.generate(2048)public_key = key.public_key().export_key()private_key = key.export_key()#加密def encrypt_rsa(data): my_key = RSA.import_key(public_key) rsa = PKCS1_OAEP.new(my_key) res = rsa.encrypt(data) print('加密结果',res) return res#解密 def decrypt_rsa(data): my_key = RSA.import_key(private_key) rsa = PKCS1_OAEP.new(my_key) res = rsa.decrypt(data) print('解密结果',res.decode()) return resif __name__=='__main__': data = &quot;你好&quot;.encode() print(data) res = encrypt_rsa(data) de_res = decrypt_rsa(res) 将密码存入文件中读写 1234567891011from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEP#生成密钥key = RSA.generate(2048)with open('python/public.pem','wb')as f: public_key = key.public_key().export_key() f.write(public_key)with open('python/private.pem','wb')as f: private_key = key.export_key() f.write(private_key) 12345678910111213141516171819202122from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEP#加密def encrypt_rsa(data): my_key = RSA.import_key(open('python/public.pem','rb').read()) rsa = PKCS1_OAEP.new(my_key) res = rsa.encrypt(data) print('加密结果',res) return res#解密 def decrypt_rsa(data): my_key = RSA.import_key(open('python/private.pem','rb').read()) rsa = PKCS1_OAEP.new(my_key) res = rsa.decrypt(data) print('解密结果',res.decode()) return resif __name__=='__main__': data = &quot;你好&quot;.encode() print(data) res = encrypt_rsa(data) de_res = decrypt_rsa(res) SM2 密钥对需要专门的SM密钥生成器生成 使用gmsll库进行加密 12345678910111213141516171819202122from gmssl import sm2private_key = 'f379721d08cc34bcbb37f76343043ca3c614ce39a23c7cacd0b9ab75fbddf301'public_key = 'be4bea1224719c10ebf550ee66a24c7e7fbe94329749ce32651b666a32474e0953b5f29'\\ '6c14d29d853e85e8f724de20028050d69409de13e6b42f1f2107e3e3e'key=sm2.CryptSM2(private_key,public_key)# 加密def encrypt_sm2(data): res = key.encrypt(data) print('加密结果',res) return res#解密def decrypt_sm2(data): res = key.decrypt(data) print('解密结果',res.decode()) return resif __name__ == '__main__': data = '你好'.encode() res = encrypt_sm2(data) de_res = decrypt_sm2(res) 也可以实现数字签名算法 12345678910111213141516171819202122232425262728#签名from gmssl import sm2private_key = 'f379721d08cc34bcbb37f76343043ca3c614ce39a23c7cacd0b9ab75fbddf301'public_key = 'be4bea1224719c10ebf550ee66a24c7e7fbe94329749ce32651b666a32474e0953b5f296c14d29d'\\ '853e85e8f724de20028050d69409de13e6b42f1f2107e3e3e'key=sm2.CryptSM2(private_key,public_key)# 加密def encrypt_sm2(data): res = key.encrypt(data) signature = key.sign(data,private_key) print('加密结果',res) print('签名',signature) return res,signature#解密def decrypt_sm2(data,signature): res = key.decrypt(data) print('解密结果',res.decode()) verify = key.verify(signature,res) print('签名结果',verify) return res,if __name__ == '__main__': data = '你好'.encode() res,signature = encrypt_sm2(data) de_res = decrypt_sm2(res,signature) 数字签名算法 公钥用于签名验证，私钥用于签名生成 过程如下 签名过程：消息的Hash值被用作数字签名，然后使用私钥加密，生成数字签名。 验证过程：将数字签名用于公钥解密，并与消息的Hash值比较，如果两个值相同，则证明数字签名是合法的 数字签名的目的是为了保证数据的完整性和发送者的身份验证 保证数据在传输过程中没有被篡改 身份验证 不可抵赖性，认证 12345678910111213141516171819202122232425262728293031323334353637383940from Crypto.PublicKey import RSA,DSA,ECCfrom Crypto.Cipher import PKCS1_OAEPfrom Crypto.Signature import pkcs1_15from Crypto.Hash import SHA512myPublic_key = RSA.import_key(open('python/public.pem','rb').read())myPrivate_key = RSA.import_key(open('python/private.pem','rb').read())#加密def encrypt_rsa(data): digest = SHA512.new(data) signature = pkcs1_15.new(myPrivate_key).sign(digest) rsa = PKCS1_OAEP.new(myPublic_key) res = rsa.encrypt(data) print('加密结果',res) return res,signature#解密 def decrypt_rsa(data,signature): rsa = PKCS1_OAEP.new(myPrivate_key) res = rsa.decrypt(data) print('解密结果',res.decode()) digeat = SHA512.new(res) try: pkcs1_15.new(myPublic_key).verify(digeat,signature) print('签名以通过') except: print('签名未通过') return resif __name__=='__main__': data = &quot;你好&quot;.encode() print(data) res,signature = encrypt_rsa(data) de_res = decrypt_rsa(res,signature)","link":"/2023/08/01/pycrypt3/"},{"title":"Python基础(一)","text":"多线程，多进程，进程间数据通信 Python多线程 一个进程至少包含一个主线程（守护线程），也可以包含许多子线程（非守护线程）。 Python程序为了线程安全，每一个进程设有一个全局解释器锁，不同的操作系统对线程的占用时间时有限的，当Python程序执行时每一个线程都需要排队去申请解锁，在有限的占用时间后还锁，这就造成Python多线程程序同一时刻只能有一个线程在运行，但由于操作系统切换线程速度太快，就看似是一种并发的状态，但其实是伪并发。 Python要实现真并发，可以使用多进程。 对于爬虫来说主要在等待I/O的请求时间，所以多线程完全可以使用。 threading，多线程包 基础使用 设置线程 开启线程 其他：设置守护线程，查看线程状态 12345678910111213141516171819202122232425262728293031323334import threadingdef print1(): for i in range(100): print(&quot;1&quot;)def print2(): for i in range(100): print(&quot;2&quot;)#target=函数名，args=传入参数x1=threading.Thread(target=print1,args=())x2=threading.Thread(target=print2,args=())#设置为守护线程# x1.daemon=True# x2.daemon=True#开启线程#主线程接受不影响非守护线程x1.start()x2.start()#判断是否为守护线程# print('x1',x1.daemon)# print('x2',x2.daemon)print(&quot;主线程结束&quot;)#查看线程状态#print(threading.current_thread())#查理主线程状态#print(threading.main_thread()) 上锁 使用 threading.Lock() 进行上锁等待，上文说到在有限的的时间内会将锁还回去（但保留运行数据，再次轮到后继续进行），任务开始使用 .acquire获取锁，可以强制等待任务执行完毕后使用 .release 再还锁。 .join()的作用，主线程任务结束后进入阻塞状态，会一直等待调用了join子线程任务执行结束后主线程才会终止。 用时间换安全 使用一个循环加一减一的例子说明 1234567891011121314151617181920212223242526272829303132import threadingLock=threading.Lock()num = 0def print1(): global num for i in range(100): Lock.acquire() num+=1 Lock.release()def print2(): global num for i in range(100): Lock.acquire() num-=1 Lock.release()#target=函数名，args=传入参数x1=threading.Thread(target=print1)x2=threading.Thread(target=print2)x1.start()x2.start()x1.join()x2.join()print(num) Python多进程 multiprocessing包 基本使用 设置线程–启动线程–给每个线程添加等待 12345678910111213141516171819202122import multiprocessingimport time# 查看电脑线程数# print(multiprocessing.cpu_count())def num(name): print('run process{}'.format(name)) time.sleep(3) print('end process{}'.format(name))if __name__ == '__main__': # 设置线程--启动线程--给每个线程添加等待 processes=[] for i in range(5): p1=multiprocessing.Process(target=num,args=(i,)) processes.append(p1) p1.start() for i in processes: i.join() print('进程结束') 进程池构建 在一开始创建一个进程池，那个空闲用那个，用完自动还回去 123456789101112if __name__ == '__main__'： Pools=multiprocessing.Pool(3) for i in range(9): #Pools.apply(func=num,args=(i,))#apply同步 Pools.apply_async(func=num,args=(i,))#apply_async异步(主要使用异步) Pools.close()#使用结束后关闭全部进程池 Pools.join() print('进程结束') 多进程数据共享 原理：使用代理 Manager 使用代理复制一份数据进行同步更改 不是共享内存 123456789101112131415161718192021222324252627282930import multiprocessingimport timedef push(li): print(id(li)) while True: print(&quot;存数据&quot;) li.append('a') time.sleep(1)def pop(li): print(id(li)) while True: if li: print('拿数据'+str(li.pop())) time.sleep(1)def main(): #设置代理Manager（列表） li = multiprocessing.Manager().list() print(id(li)) p1 = multiprocessing.Process(target=push,args=(li,)) p2 = multiprocessing.Process(target=pop, args=(li,)) p1.start() p2.start() p1.join() p2.join()if __name__ == '__main__': main()","link":"/2023/08/06/python1/"},{"title":"Python基础(二)","text":"异步协程 异步:在单线程中利用IO等待时间去执行其他任务 携程:一个个没有并发起来的任务，协程本身不会多个并发需要我们包装成任务 注意: 如果不加await 则任务只是一个声明不会运行，await + 等待执行的任务 在等待程序前面加上asyncio表示这是个异步程序 123456789101112131415161718192021222324import asyncioasync def num(name): print('{}start'.format(name)) await asyncio.sleep(2) print('{}end'.format(name))async def main(): t1=[asyncio.create_task(num(1)), asyncio.create_task(num(2)), asyncio.create_task(num(3))] await asyncio.wait(t1)#两种写法效果一样# async def main():# t1 = [num(1),# num(2),# num(3)]# await asyncio.gather(*t1)if __name__ == '__main__': #声明协程对象 并不会直接运行 #await运行协程任务 等待 会一直阻塞到任务结果返回 asyncio.run(main())","link":"/2023/08/06/python2/"},{"title":"Python基础(三)","text":"python基础语法 python编译原理 .py文件—编译器—pyCodeObject(内存)/.pyc(磁盘)—虚拟机VM—解释执行—机器码PC 数据类型 str int float bool list dict tuple set str “”12345#字符串 和引号无关str_a='nihao'str_b=&quot;nihao&quot;str_c=&quot;&quot;&quot;nihao&quot;&quot;&quot;print(str_a,str_b,str_c) int float1234int_a=123456float_a=3.1415926print(int_a,float_a)print(type(int_a)) bool123bool_a=Trueprint(type(bool_a),bool_a)print(0==False) list []1234567list_a=[1,2,3,3.14,'nihao','buhao',[5,6,7]]print(list_a)list_a[4]='你好'print(list_a)#删除del list_a[0]print(list_a) dict {key:value}123456dict_a={'name':'xxx','age':100,'port':8000}print(dict_a['name'])dict_a['name']='nihao'print(dict_a)del dict_a['age']print(dict_a) tuple ()1234#类似列表 不能更改 ()tuple_a=('human',99,55,22)print(tuple_a,type(tuple_a))print(tuple_a[0]) set {}123456#集合，过滤重复元素 {}list_b=[1,2,3,5,4,2]set_a=set()for i in list_b: set_a.add(i)print(set_a) 基本语法 break 跳出当前循环 ,continue 继续下一次循环 if else123456username=input(&quot;请输入用户名：&quot;)if username=='nihao': print('登陆成功') breakelse: print('用户名错误,请重新输入') 循环123456789#while死循环-结束条件while True: username=input(&quot;请输入用户名：&quot;) if username=='xjb': print('登陆成功') break else: print('用户名错误,请重新输入')print('程序结束') 123456789#for计次for i in range(10): username=input(&quot;请输入用户名：&quot;) if username=='xjb': print('登陆成功') break else: print('用户名错误,请重新输入')print('程序结束') 循环计数123456789# 循环时候计数enumerateli=['nihao','nihao2','nihao3']for num,item in enumerate(li): print(num+1,item)# 1 nihao# 2 nihao2# 3 nihao3 1234567891011#多个序列打包循环 zipli=[1,2,3,4]li2=[4,5,6,7]li3=[4,5,6,7]for i,j,z in zip(li,li2,li3): print(i,j,z)# 1 4 4# 2 5 5# 3 6 6# 4 7 7 定义函数1234567def add(a,b): print(a+b) # 不写return默认返回None return a+b tmp=add(5,3)print(tmp) 错误处理123456789101112def add(a,b): try: c=a+b print('a+b=',c) # except：可以指定错误类型 except Exception as e: print('发生错误了！',e) finally: #不管正确与否都执行finally print('执行finally')add(1,3)","link":"/2023/08/07/python3/"},{"title":"Python基础(四)","text":"类，装饰器，文件操作 类123456789101112131415161718192021222324252627282930#参数叫属性#函数叫方法class Human: # 初始化 def __init__(self,name): # 指针指向self内存地址 # self 放在内存里的一个Human对象 self.name=name print('self-&gt;',self) # 像调用函数一样调用类 def __call__(self, *args, **kwargs): print('call 被调用',args,kwargs) #call 被调用 (1, 2, 3, 'nihao') {'name': 'nihao', 'age': 9} #*args和*kwargs会把值解出来 #call 被调用 1 2 3 nihao name age print('call 被调用',*args,*kwargs) def speak(self): print('Human在讲话'+self.name)#实例化会自动调用init方法h1=Human(&quot;h1&quot;)print(h1.name)h1.speak()h2=Human(&quot;h2&quot;)print(h2.name)h2.speak()#像调用函数一样调用类#前面的数据会被*args接收，后面的两个赋值运算会被当作键值对被**kwargs接收h1(1,2,3,'nihao',name='nihao',age=9) 继承 封装 多态1234567891011121314151617181920212223242526272829303132class Human: def __init__(self,name,age): self.name=name #下划线开头代表私有 self.__age = age print('self-&gt;',self) def speak(self): print('Human在讲话'+self.name) #下划线开头代表私有 def __speak(self): print('Human在讲话'+self.name)#继承class nihao(Human): def __init__(self,name,age): self.nihao=name self.age = age #调用父类__init__方法 super(nihao, self).__init__(name,age) # 多态 重写父类 def speak(self): print('nihao') #在同名子类中调用父类 super(nihao, self).speak()def speak(obj): obj.speak()x1=nihao(&quot;nihao&quot;,2)x2=Human(&quot;nihao2&quot;,1)speak(x1)speak(x2) 12345678910111213141516171819202122#property 把类方法转化为类属性方式获取#classmethod 类方法表示属于类，不属于实例#staticmethod 静态方法 我当前的方法不属于类 是一个单独的函数class nihao: def __init__(self): self.age ='4' @property def _age(self): return self.age #设置属性 @_age.setter def _age(self,value): self.age=value #删除属性 @_age.deleter def _age(self): del self.agen = nihao()del n._agen._age = 5print(n._age) 装饰器12345678910111213141516171819202122#自制装饰器#高阶函数---把函数作为参数#参数是函数 返回内部函数 内部函数里边调用函数（传递参数）import timedef Timer(func): #start=time.time() def inner(*args,**kwargs): #print('传递的参数：',*args,**kwargs) func(*args,**kwargs) # end=time.time() # print('耗费时间：',end-start) return inner@Timerdef test(a,b,c): for i in range(100000): print(1)test(1,2,3) 文件操作12345678910111213141516171819202122&quot;&quot;&quot;w 写入 如果文件不存在我就创建 已经存在就会覆盖r 读取 读取文件内容a 追加 把内容写入文件末尾，不存在就创建，存在就直接写b 二进制 写入视频、音频、图片之类的就需要加这个with自开合 enter exit&quot;&quot;&quot;line=&quot;写入文件&quot;#第一种写法f=open('demo.txt','w',encoding='utf-8')f.write(line)f.close()#不关闭那就会导致内存泄漏（文本打开太多了，内存爆了）#第二种写法for i in range(10): with open('demo.txt','a',encoding='utf-8')as f: f.write(line+'\\n')# 读with open('demo.txt','r',encoding='utf-8')as fr: content=fr.read()print(content)","link":"/2023/08/08/python4/"},{"title":"Python基础(五)","text":"python三器 迭代器和生成器迭代器：标志是使用__iter__方法，返回一个迭代器对象使用__next__方法可以获取下一个值，如果没有下一个值则抛出StopIteration异常 迭代器是一个可以记住遍历的位置的对象，可以为序列、文件、集合、字典、字符串等对象 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束 迭代器只能往前不会后退 迭代器是有状态的，每次迭代都需要重新设置状态 生成器：生成器是一个特殊的迭代器，只能往后不会前进，标志是使用yield关键字，返回一个生成器对象 生成器是一个特殊的函数，只能用于迭代操作，返回迭代器对象 生成器是一个惰性计算的对象，只有在需要迭代的时候才会执行，节省内存 生成器可以不断返回下一个值，直到没有更多的值 装饰器装饰器是一个特殊的函数，它可以让其他函数增加额外的功能，其定义格式如下： 12345def decorator_name(func): def wrapper(*args, **kwargs): # 包装操作 return func(*args, **kwargs) return wrapper 装饰器的作用就是将原函数的内容包装起来，然后返回包装后的函数。 Python中如何实现单例模式 单例模式是一种常见的设计模式，它保证一个类只有一个实例，并提供一个访问它的全局访问点。123456789101112131415161718192021222324252627282930313233343536373839404142# 实现方式一：# 使用装饰器实现 判断是否已经实例化from functools import wrapsfrom typing import Anydef singleton(cls): &quot;&quot;&quot; 单列类装饰器 &quot;&quot;&quot; instance = {} @wraps(cls) def wrapper(*args, **kwargs): if cls not in instance: instance[cls] = cls(*args, **kwargs) return instance[cls] return wrapper@singletonclass Singleton: &quot;&quot;&quot; 单列类 &quot;&quot;&quot; passa = Singleton()b = Singleton()print(id(a), id(b))# 实现方式二：# 使用元类实现单例类(类这样的对象时通过元类来创建，默认元类为type)class Singleton2(type): &quot;&quot;&quot; 单列类元类 &quot;&quot;&quot; def __init__(cls,*arg,**kwargs): print('init') cls.__instance = None super().__init__(*arg,**kwargs) def __call__(cls,*arg,**kwargs): print('call') if cls.__instance is None: cls.__instance = super().__call__(*arg,**kwargs) return cls.__instanceclass President(metaclass=Singleton2): pass a = President()b = President()print(id(a), id(b))","link":"/2023/08/13/python5/"},{"title":"Redis(一)","text":"Redis安装使用 数据类型 设置自动过期时间 安装使用 安装 brew install redis key-value数据库，nosql非关系数据库 值可以时字符串、哈希、列表、集合、有序集合等 启动 redis-server 启动 redis-cli （-h 127.0.0.1 -p6379） 数据类型字符串类型 set “key” “value” get “key” 不存在返回nil strlen “key” 返回字符串长度 append “key” “追加内容” mset “key” “value” “key” “value” 存入多个数据 mget “key” “key” “key” 列表类型 能够让一个键对应多个值 插入 lpush “key” v1 v2 左端插入，结果为 v2 v1 rpush “key” v1 v2 右端插入，结果为 v1 v2 linsert “key” after v1 v3 中间插入 弹出内容 lpop “key” 删除左边第一个 rpop blpop/brpop key timeout 3 弹出内容-阻塞3秒 获取 lindex key 0 获取key中第0个元素 llen key 获取长度 lrange key start stop 获取从start到结束的元素，start/stop 为数字 哈希类型-和字典类似 hmset name key value key value 插入多个 hmget name key key 查询 hgetall name 获取name的全部key和value hexists name key 是否存在某个字段 hset name key value 修改或添加 hdel name key value 删除字段 一个哈希最多存2^32-1字段，字段为空自动释放内存 集合类型 去重 集合成员是唯一的，会自动去重 sadd key v1 v2 v1 添加 srem key v1 删除 scard key 获取长度 sismenber key v1 判断存在 members key 列出成员 设置自动过期时间 lpush “key” “url1” “url2” expire “key” 20 查看剩余过期时间 TTL “key” exists “spider cache”","link":"/2023/11/09/redis1/"},{"title":"Redis(二)","text":"事务 订阅模式 持久化RDB，AOF 事务 启动事务 multi 放弃事务 discard 提交事务 exec 监控键 watch（如果在事务exec之前修改了键，则取消事务） redis和sql事务的区别 没有回滚 语法错误，exec不会执行 原子性 执行过程中出错，后续命令还是会继续执行 打破原子性 redis发布订阅模式PubSub 经典消息传递机制，即频道把数据发送出去，订阅了该频道的用户受到消息 subscribe 用于订阅 publish 用于发布 pubsub channels 用于展示频道 unsubscribe 用于退订 当频道无订阅时会自动销毁，而且订阅消息不支持持久化 持久化 redis数据存储在内存中，重启后所有数据会被清空 为了保存数据，redis提供两种持久化类型RDB和AOF RDB默认自动保存也可以手动写入 保存文件名dump.rdb sava 同步写入，会阻塞线程 bgsave 异步方式，fork子进程处理 数据恢复：config get dir 修改 /usr/local/etc/redis.conf save 900 1 表示900秒内至少有1个key变化就自动保存，取消自动保存注释掉即可 stop-writes-on-bgsave-error:当启动RDB且最后一次保存数据失败，redis是否停止接受数据 rdbcompression：磁盘快照是否进行压缩 rdbchecksum：是否进行CRC64算法进行数据校验 dbfilename：设置快照文件名 dir：设置文件存放路径，是一个目录不是一个文件名 AOF记录写入命令的追加模式，每个写入命令都会被记录 修改redis.conf 文件 config set appendonly yes appendfsync always：每个写入都fsync appendfsync everysec：每一秒一次fsync appendfsync no：用于fsync，由系统时间决定 auto-aof-rewrite-percentage 100 当前AOF文件大小和上一次重写时AOF文件大小的比值 auto-aof-rewrite-min-size 64mb 文件最小体积 原理：redis先把写入命令写入到缓冲区，缓冲区的数据被fsync()之后刷到磁盘，redis关闭时自动调用一次fsync bgrewriteaof：重写会创建一个当前AOF文件的体积优化版本 如果只配置AOF，重启时加载AOF文件恢复数据 如果同时配置了RDB和AOF，启动时只加载AOF文件恢复数据 如果只配置RDB启动时加载dump文件恢复数据","link":"/2023/11/09/redis2/"},{"title":"Redis(三)","text":"Python操作redis redis主从复制 redis消息订阅 Python操作redis12345import redispool = redis.ConnectionPool(host='127.0.0.1', port=6379)r = redis.Redis(connection_pool=pool)r.set('name', 'tom')print(r.get('name')) 1234567891011import redispool = redis.ConnectionPool(host='127.0.0.1', port=6379)r = redis.Redis(connection_pool=pool)#事务try: pipe=r.pipeline() pipe.set(&quot;name&quot;,&quot;tom&quot;) # 提交 pipe.execute()except Exception as err: print(err) redis主从复制 生产环境中，单个服务器往往存在崩溃、宕机、网络故障。 提高容错，减轻单个服务器的压力，redis主从复制，能够讲一个服务器的数据，同时同步同步到多个备份服务器中。 操作 复制一份redis.windows.conf 修改文件名为redis.slave.conf 新建slave文件夹 修改文件： port 6389 dir ./slave slaveof 127.0.0.1 6379 启动命令：redis-cli -p 端口号 输入 info replications 可以查看当前主从关系 redis消息订阅1234567import redispool = redis.ConnectionPool(host='127.0.0.1', port=6379)r = redis.Redis(connection_pool=pool)while True: data = input(&quot;&gt;&gt;&gt;&quot;) r.publish('test', data) 1234567891011121314151617181920import redisimport timepool = redis.ConnectionPool(host='127.0.0.1', port=6379)r = redis.Redis(connection_pool=pool)pub=r.pubsub()pub.subscribe('test')pub.parse_response()while True: print(&quot;waiting for message...&quot;) msg = pub.parse_response() print(msg) print(msg[2].decode('utf-8')) time.sleep(3) if msg[2].decode('utf-8') == 'exit': m = pub.unsubscribe('test') print(m) print(&quot; &quot;) break","link":"/2023/11/12/redis3/"},{"title":"Scrapy框架(一)","text":"命令 框架结构 命令 pip3 install scrapy 安装 scrapy startproject study 创建一个名为study的项目 cd study scrapy genspider demo baidu.com 创建爬虫 scrapy crawl demo 运行爬虫 全局命令 scrapy runspider xxx.py 直接运行爬虫文件，无需创建项目 scrapy shell url 打开命令行请求网站 response.header response.xpath('//text') response.css('title::text')[0].get() scrapy fetch url 爬取主址 scrapy veiw url 打开浏览器 scrapy version 版本 项目内命令 scrapy list 列出当前爬虫 scrapy bench 测试scrapy运行速度 框架结构运行流程1.引擎到爬虫里边拿到start_urls，封装成Request请求对象（并没有真的去请求） 2.引擎将Request对象放入调度器队列 （先进先出 ）排队 3.引擎对队列挨个处理请求，交给下载中间件 4.下载中间件去请求Internet ，首先process_request，服务器返回process_response 5.引擎将响应交给爬虫处理parse，处理结果封装成items对象结合parse存储数据 6.引擎将item存储的数据交给管道进行存储","link":"/2023/08/11/scrapy1/"},{"title":"请求库","text":"介绍爬虫使用的请求库，requests，httpx，aiohttp。 requests 请求数据 get post 添加参数 user-agent 请求浏览器数据 date 数据 param 参数 cookie 防盗链 referer 请求超时 timeout=3 结果处理 二进制 文本text json数据 代码123456789101112131415161718192021222324252627282930313233343536import requestsurl = '这写上要爬的url'#添加头 headers = { &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)&quot;\\ &quot;Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.52&quot;,}#添加数据date = { &quot;kw&quot;: s}#添加参数（重新封装）params = { &quot;type&quot;: 20, &quot;interval_id&quot;: &quot;100:90&quot;, &quot;action&quot;: &quot;&quot;, &quot;start&quot;: 0, &quot;limit&quot;: 20,}#发起一个get请求resp = requests.get(url, headers=headers，data=data，params=params)#发起一个post请求resp = requests.post(url, headers=headers，data=data，params=params)#去掉安全验证resp = requests.get(url, verify=False)#设置编码格式resp.encoding = 'utf8'#状态码查看print(resp.status_code)#结果为二进制print(resp.content)#结果为json数据print(resp.json())#请求为文本print(resp.text) 中文解码12345678910import requestsfrom urllib.parse import quote,unquote#解码data='%E4%BD%A0%E5%A5%BD'print(unquote(data))#加码data2='你好'print(quote(data)) session会话 session对象 基于seesion发起的请求都会公用session内的参数。 session可以保存请求时的cookie12345678910import requestssession = requests.session()session.headers={ 'test':'test'}#请求是公用session中的参数，也可以自己添加，如果参数重合以自己的请求为主h1 =session.get('url',headers={'a':'b'})h2 =session.get('url') proxies代理123456import requestsproxies ={ 'http':'http://127.0.0.1:7890', 'https':'http://127.0.0.1:7890',}resp = requests.get('url',proxies=proxies) httpx 支持http2.0兼容http1.0 处理http1.0和requests一样的用法 12345import httpxheaders={}proies={}html = httpx.get('url',headers=headers,proies=proies)print(html.text) 处理http2.0和session用法相似 client=httpx.Client(http2.0=True,proxies=proxies) 异步请求 12345678910111213141516171819202122#第一中写法async def spider(num): print('run',num) client=httpx.AsyncClient(http2=True) html = await client.get('url') print(html) await client.aclose()#第二中写法async def spider(num): print('run',num) async with httpx.AsyncClient(http2=True) as client: html = await client.get('url') print(html)#建立队列async def main(): await asyncio.gather(*[spider(1),spider(2),spider(3)])#启动 if __name__ == '__main__': asyncio.run(main()) aiohttp 异步请求 123456789101112131415import aiohttpimport asyncioheaders={}#只支持http代理proxy='http://localhost:7890'async def main(): async with aiohttp.ClientSession(headers=headers) as client: html = await client.get('url') print(await html.text()) html.close()#使用loop启动程序loop = asyncio.get_event_loop()loop.run_until_complete(main()) 优缺点和区别 requests 同步 httpx 同步异步 aiohttp 只有异步","link":"/2023/08/01/spider1/"},{"title":"解析库","text":"使用bs4，xpath，re进行数据解析和提取。 bs4 BeautifulSoup 支持从HTML或XML文件中提取数据的python库 Beautiful Soup自动将输入文档转换为Unicode编码，输出文档转换为utf-8编码。 select方法需要使用css选择器 css选择器 class 使用·代替 id使用#代替 find方法是找到第一个满足条件的标签后就立即返回，只返回一个元素。 find_all方法是把所有满足条件的标签都选到，然后返回回去。 12345678910111213141516171819202122232425262728293031323334import requestsfrom bs4 import BeautifulSoup# 从bs对象中查找数据# find(标签，属性=值)# find_all(标签，属性-值（如果遇到python关键字用class_或者一个字典代替）)url = &quot;https://www.umei.cc/bizhitupian/diannaobizhi/&quot;resp = requests.get(url)resp.encoding = 'utf-8'#把爬下来的网站给bs并指定html解析# find(标签，属性=值)# find_all(标签，属性-值（如果遇到python关键字用class_或者一个字典代替）)main_page = BeautifulSoup(resp.text, &quot;html.parser&quot;)#main_page = BeautifulSoup(resp.text, &quot;lxml&quot;)a_list = main_page.find(&quot;div&quot;, class_=&quot;listlbc_cont_l&quot;).find_all(&quot;a&quot;)a_list = main_page.find(&quot;div&quot;, class_=&quot;item_list infinite_scroll&quot;).find_all(&quot;a&quot;)for a in a_list: href = a.get('href') print(href)#使用css选择器 调用select方法b_list = main_page.select('div.img div.btns a')#第一种写法for b in b_list: href = b.get('href') print(href)#第二种写法for b in b_list: print(b['href']) xpath //div找全部的div /div找第一个div @＋属性 严格匹配 鼠标右键复制完整xpath再元素控制台调试直到合适 12345678910111213141516import requestsfrom lxml import etreeurl = &quot;https://www.umei.cc/bizhitupian/diannaobizhi/&quot;resp = requests.get(url)resp.encoding = 'utf-8'soup = etree.HTML(resp.text)#text() @href @属性results=soup.xpath('/html/body/div[5]/div[1]/div[2]/div[1]/div/div/div[1]/div/a/img/@alt')results=soup.xpath('/html/body/div[5]/div[1]/div[2]/div[1]/div/div/div[1]/div/a/img/text()')for i in results: print(i) re re在爬虫种主要处理复杂的数据 使用正则设置一个匹配规则 得到一个list，使用group方法取出 1234567import re# （？P&lt;分组名字&gt;正则）可以单独从正则匹配的内容中进一步提取内容#re.S使.也可以匹配换行符obj = re.compile(r&quot;&lt;div class='.*?'&gt;&lt;span id='.*?'&gt;(?P&lt;分组&gt;.*?)&lt;/span&gt;&lt;div&gt;&quot;, re.S)result = obj.finditer(resp.text)for it in result: print(it.group(&quot;分组&quot;)) 总结爬虫解析页面主要使用bs4和xpath，如果遇到较为复杂的页面使用re即可。","link":"/2023/08/01/spider3/"},{"title":"免费代理处理","text":"免费代理测试验证ip可用性 1.通过爬虫爬取免费代理ip和端口号2.对每个ip进行可用性验证，请求’https://httpbin.org/ip'判断状态码 12345678910111213141516171819#封装proxyproxies = { 'http': f'http://{IP}:{PORT}', 'https': f'http://{IP}:{PORT}',}url = 'https://httpbin.org/ip' headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'\\ 'AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36 Edg/109.0.1518.78' } try: html = requests.get(url, proxies=proxies, headers=headers, timeout=3) print('状态码：', html.status_code) print('IP：', html.text) #可用的代理放入列表种 proxies_list.append(proxies) except: print('代理不可用')","link":"/2023/08/01/spider2/"},{"title":"验证码处理(一)","text":"dddocr处理验证码。 dddocr 一个免费好用的验证码处理包 找到验证码图片接口 下载验证码 将验证码传入进行识别 返回验证码 处理数字文字验证码123456789import ddddocrdef get_ocr(): ocr = ddddocr.DdddOcr() with open(&quot;1.png&quot;, 'rb') as f: image = f.read() res = ocr.classification(image) print(f'验证码识别结果:{res}') return res","link":"/2023/08/01/yanzheng1/"},{"title":"验证码处理(二)","text":"图片切片混淆原理，和还原处理思路。 原理 Css背景定位，通过控制背景图片坐标的位置来还原图片。 background-position，坐标代码决定了图片应该从哪个位置去取 还原图片 请求一张打乱的图片，前端通过Css将其还原成一张完整的图片，在开发者工具中找到打乱的验证码图片并保存下来。 找到前端图片还原的Css代码 复制样式代码到vscode 创建新style，复制原来的样式，更改图片请求地址为本地 修改Css代码，使用Canvas手动输入坐标重绘验证码图片 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;!--注意最后保存文档时的编码 --&gt; &lt;title&gt;这是标题&lt;/title&gt;&lt;/head&gt;&lt;!-- 使用canvas画布重绘制图片 --&gt;&lt;canvas id=&quot;myCanvas&quot; width=&quot;260&quot; height=&quot;116&quot; style=&quot;border: red 1px solid;&quot; &gt;&lt;/canvas&gt;&lt;script&gt; let img = new Image(); img.src = &quot;./css图片.png&quot;; // 绑定事件 图片加载完成时运行 img.onload = function(){ console.log(&quot;图片加载完成&quot;); let cv = document.getElementById(&quot;myCanvas&quot;); let ctx = cv.getContext('2d'); // drawImage(ImgUrl,pxX（网站混淆的坐标）,pxY,styleX（原本设定的样式）,styleY,绘画横坐标,绘画纵坐标,styleX,styleY) // 手动添加坐标，后续使用for处理坐标 ctx.drawImage(img,234,25,13,25,0,0,13,25); ctx.drawImage(img,143,25,13,25,13,0,13,25); ctx.drawImage(img,65,75,13,25,26,0,13,25); console.log(cv); }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用re处理坐标还原图片 可以使用js的re表达来取1let arr = str.matchAll(/&quot;background-position:-?(\\d+)px\\s+-?(\\d+)px;&quot;/igs); 也可以使用python中re库来取12re.compile()finditer() 验证码切片混淆后使用python进行还原 处理坐标中的负号，abs取绝对值123456# 处理坐标def coordinates(data): data = [[abs(int(pos[0].replace(' ',''))), abs(int(pos[1].replace(' ','')))] for pos in data] return data 还原图片123456789101112131415161718192021222324252627# 还原图片# 传入处理好的坐标def reduction_img(positions): # 打开混淆切片的图片 my_image = Image.open('code.jpg') crop_list = [] for pos in positions: if pos[1]==0: crop_list.append(my_image.crop((pos[0],0,pos[0]+13,25))) if pos[1]==25: crop_list.append(my_image.crop((pos[0],25,pos[0]+13,50))) if pos[1]==50: crop_list.append(my_image.crop((pos[0],50,pos[0]+13,75))) if pos[1]==75: crop_list.append(my_image.crop((pos[0],75,pos[0]+13,100))) new_img = Image.new('RGB',(260,100)) x_offset = 0 y_offset = 0 for crop in crop_list: if x_offset == 260: x_offset = 0 y_offset += 25 new_img.paste(crop, (x_offset,y_offset)) x_offset+=13 new_img.save('code2.jpg')","link":"/2023/08/01/yanzheng2/"},{"title":"验证码处理(三)","text":"","link":"/2024/01/20/yanzheng3/"}],"tags":[{"name":"安卓逆向","slug":"安卓逆向","link":"/tags/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"刷机","slug":"刷机","link":"/tags/%E5%88%B7%E6%9C%BA/"},{"name":"Spider","slug":"Spider","link":"/tags/Spider/"},{"name":"Charles","slug":"Charles","link":"/tags/Charles/"},{"name":"Proxifie","slug":"Proxifie","link":"/tags/Proxifie/"},{"name":"Css","slug":"Css","link":"/tags/Css/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQlite","slug":"SQlite","link":"/tags/SQlite/"},{"name":"TinyDB","slug":"TinyDB","link":"/tags/TinyDB/"},{"name":"Fiddler","slug":"Fiddler","link":"/tags/Fiddler/"},{"name":"RPC","slug":"RPC","link":"/tags/RPC/"},{"name":"Html","slug":"Html","link":"/tags/Html/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Js逆向","slug":"Js逆向","link":"/tags/Js%E9%80%86%E5%90%91/"},{"name":"Jscipher","slug":"Jscipher","link":"/tags/Jscipher/"},{"name":"Js混淆","slug":"Js混淆","link":"/tags/Js%E6%B7%B7%E6%B7%86/"},{"name":"Mongodb","slug":"Mongodb","link":"/tags/Mongodb/"},{"name":"MySql","slug":"MySql","link":"/tags/MySql/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"aiohttp","slug":"aiohttp","link":"/tags/aiohttp/"},{"name":"cipher","slug":"cipher","link":"/tags/cipher/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"验证码","slug":"验证码","link":"/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"},{"name":"滑块","slug":"滑块","link":"/tags/%E6%BB%91%E5%9D%97/"}],"categories":[{"name":"3.Android逆向","slug":"3-Android逆向","link":"/categories/3-Android%E9%80%86%E5%90%91/"},{"name":"1.Android基础","slug":"3-Android逆向/1-Android基础","link":"/categories/3-Android%E9%80%86%E5%90%91/1-Android%E5%9F%BA%E7%A1%80/"},{"name":"1.爬虫","slug":"1-爬虫","link":"/categories/1-%E7%88%AC%E8%99%AB/"},{"name":"5.编程基础","slug":"5-编程基础","link":"/categories/5-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"4.数据库","slug":"4-数据库","link":"/categories/4-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"4.抓包工具","slug":"1-爬虫/4-抓包工具","link":"/categories/1-%E7%88%AC%E8%99%AB/4-%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/"},{"name":"2.Js逆向","slug":"2-Js逆向","link":"/categories/2-Js%E9%80%86%E5%90%91/"},{"name":"4.Html+Css","slug":"5-编程基础/4-Html-Css","link":"/categories/5-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/4-Html-Css/"},{"name":"3.Mongodb","slug":"4-数据库/3-Mongodb","link":"/categories/4-%E6%95%B0%E6%8D%AE%E5%BA%93/3-Mongodb/"},{"name":"1.轻量级数据库","slug":"4-数据库/1-轻量级数据库","link":"/categories/4-%E6%95%B0%E6%8D%AE%E5%BA%93/1-%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"2.MySql","slug":"4-数据库/2-MySql","link":"/categories/4-%E6%95%B0%E6%8D%AE%E5%BA%93/2-MySql/"},{"name":"1.爬虫基础","slug":"1-爬虫/1-爬虫基础","link":"/categories/1-%E7%88%AC%E8%99%AB/1-%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"},{"name":"3.JavaScript","slug":"5-编程基础/3-JavaScript","link":"/categories/5-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/3-JavaScript/"},{"name":"1.Python","slug":"5-编程基础/1-Python","link":"/categories/5-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/1-Python/"},{"name":"4.Redis","slug":"4-数据库/4-Redis","link":"/categories/4-%E6%95%B0%E6%8D%AE%E5%BA%93/4-Redis/"},{"name":"2.Scrapy","slug":"1-爬虫/2-Scrapy","link":"/categories/1-%E7%88%AC%E8%99%AB/2-Scrapy/"},{"name":"3.验证码处理","slug":"1-爬虫/3-验证码处理","link":"/categories/1-%E7%88%AC%E8%99%AB/3-%E9%AA%8C%E8%AF%81%E7%A0%81%E5%A4%84%E7%90%86/"},{"name":"1.密码学","slug":"2-Js逆向/1-密码学","link":"/categories/2-Js%E9%80%86%E5%90%91/1-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"3.Js混淆","slug":"2-Js逆向/3-Js混淆","link":"/categories/2-Js%E9%80%86%E5%90%91/3-Js%E6%B7%B7%E6%B7%86/"}],"pages":[{"title":"","text":"Title *{ margin: 0; padding: 0; font-family: \"Poppins\", sans-serif; box-sizing: border-box; } .mycontainer .mycard .face{ position: absolute; top: 0; left: 0; width: 100%; height: 100%; transition: 0.5s; } .mycontainer .mycard .face.face1{ background: transparent; display: flex; justify-content: center; align-items: center; z-index: 1; transform-origin: bottom; } .mycontainer .mycard .face.face1 img{ max-width: 150px; } .mycontainer .mycard .face.face1 h3{ margin: 10px 0 0; color: #fff; text-align: center; font-size: 1.5em; } .mycontainer .mycard .face.face2 a{ color: rgb(0, 191, 255); text-align: center; font-size: 1.5em; } 1-爬虫基础 2-Scrapy 3-验证码处理 4-抓包工具 1-密码学 2-AST还原 3-Js混淆 4-Js补环境 1-Android基础 1-轻量级数据库 2-MySql 3-Mongodb 4-Redis","link":"/classification/index.html"},{"title":"","text":"/* *{ margin: 0; padding: 0; font-family: \"Poppins\", sans-serif; box-sizing: border-box; } */ mybody{ height: 500px; display: flex; justify-content: center; background-color: transparents } .mycontainer{ width: 700px; height: 520px; position: relative; /* display: flex; */ justify-content: space-between; /* 开启网格布局 */ display: grid; grid-template-rows: 300px 300px ; grid-template-columns: 300px 300px ; } .mycontainer .mycard{ position: relative; width: 300px; height: 200px; } /* .mycontainer .mycard .face{ position: absolute; top: 0; left: 0; width: 100%; height: 100%; transition: 0.5s; } */ /* .mycontainer .mycard .face.face1{ background: #333; display: flex; justify-content: center; align-items: center; z-index: 1; transform-origin: bottom; } */ /* .mycontainer .mycard .face.face1 h3{ margin: 10px 0 0; color: #fff; text-align: center; font-size: 1.5em; } */ .mycontainer .mycard:hover .face.face1{ transform: translateY(-100%) rotateX(90deg); background: transparent; } .mycontainer .mycard .face.face2{ background: transparent; display: flex; justify-content: center; align-items: center; padding: 20px; transform-origin: top; transform: translateY(100%) rotateX(90deg); } .mycontainer .mycard:hover .face.face2{ transform: translateY(0%) rotateX(0deg); }","link":"/classification/style.css"},{"title":"","text":"Title :root { --fontColor: white; --one1: #c39edc; --one2: white; --two1: #3dbbc7; --two2: white; --three1: #21bbfe; --three2: white; --four1: #122c9e; --four2: white; --levelShadow: #22325480; } .levels { position: relative; top: 50%; left: 50%; margin-left: -140px; margin-top: 100px; transform-style: preserve-3d; user-select: none; } .levels .level { width: 400px; height: 210px; border-radius: 12px; color: var(--fontColor); cursor: pointer; transition: all 0.4s ease; transform: rotateX(37deg) rotateY(-20deg) rotate(15deg); opacity: 0.9; margin-top: -70px; } .levels .level.one { background: linear-gradient(135deg, var(--one1), var(--one2)); box-shadow: 20px 20px 60px var(--levelShadow), 1px 1px 0px 1px var(--one2); z-index: 4; } .levels .level.two { background: linear-gradient(135deg, var(--two1), var(--two2)); box-shadow: 20px 20px 60px var(--levelShadow), 1px 1px 0px 1px var(--two2); z-index: 3; } .levels .level.three { background-image: linear-gradient(135deg, var(--three1), var(--three2)); box-shadow: 20px 20px 60px var(--levelShadow), 1px 1px 0px 1px var(--three2); z-index: 2; } .levels .level.four { background-image: linear-gradient(135deg, var(--four1), var(--four2)); box-shadow: 20px 20px 60px var(--levelShadow), 1px 1px 0px 1px var(--four2); z-index: 1; } .levels .level .title { color: white; position: absolute; top: 80px; right: 80px; font-size: 40px; font-weight: bold; } .levels .level .content { position: absolute; font-weight: 700; bottom: 15px; left: 15px; font-size: 16px; } .levels .level:hover { transform: rotateX(37deg) rotateY(-20deg) rotate(18deg) translate(-25px, 50px); opacity: 0.6; } .levels .level:hover:after { transform: translateX(100%); transition: all 2s ease-in-out; } .levels .level::after { content: ''; position: absolute; top: 0px; left: 0; width: 100%; height: 100%; transform: translateX(-100%); background: linear-gradient(60deg, rgba(255,255,255,0) 20%, rgba(255,255,255,0.1), rgba(255,255,255,0) 80%); } Python 爬虫开发 Java Android逆向 后端开发 JavaScript Js逆向 Html+Css 前端开发","link":"/codebase/index.html"},{"title":"","text":"碎碎念 h2{ text-align: center; } p{ text-align: center; } 碎碎念 一路有陌路人陪你这一生","link":"/about/index.html"}]}