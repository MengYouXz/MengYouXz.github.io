{"posts":[{"title":"刷机","text":"介绍刷机基础，使用设备GooglePiexlXL 代号(marlin)，安卓版本 10.0。 1.刷机包分类 线刷包 后续编译的安卓系统都使用线刷包 刷机包组成 flash-all.bat内容：使用fastboot刷入bl radio image 卡刷包 2.刷机过程 线刷 进入bootloader双击flash-all.bat运行 进入bootloader使用fastboot命令进行刷机 卡刷 进入recovery使用手机sd卡内保存的卡刷包刷机 进入recovery使用adb sideload 推送刷机包 3.刷机命令（常用） adb adb devices 检测设备是否连接上电脑 adb reboot 重启 adb reboot recovery/bootloader 重启进入recovery/bootloader adb sideload &lt;刷机包地址&gt; 在recovery模式启用adb调试推送刷机包 fastboot fastboot devices 检测设备是否连接上电脑 fastboot reboot 重启 fastboot reboot recovery 重启进入recovery fastboot flash &lt;分区&gt; &lt;分区对应刷机包&gt; 刷入刷机包命令","link":"/2023/08/01/android2/"},{"title":"adb原理及命令","text":"介绍abd原理及adb常用操作命令。 原理 adb构成 client端，在电脑，负责发送adb命令 daemon守护进程adbd，在手机端，负责接受和执行adb命令 server端，在电脑上，负责管理client和daemon之间的通信 adb工作原理 client-&gt;server-&gt;daemon(执行返回结果)-&gt;server-&gt;client 命令 adb help adb version adb start-server 启动server adb kill-server 停止server adb devices adb install xxx.apk 安装应用 adb install -r xxx.apk 覆盖安装 adb uninstall 包名 adb push xxx xxx 推送文件到手机 adb push xxx.apk ./sdcard/yyy adb pull xxx xxx 拉取手机文件到电脑上并改名 adb pull xxx 拉取整个文件夹 adb shell 进入到手机linux控制台 去除wife感叹号 adb shell settings put global captive_portal_mode 0 adb -s 设备名 shell（多个设备是使用） 超级adb才能用 adb root adb remount 挂载分区为可读写 adb disable-verity 关闭分区检测功能","link":"/2023/08/01/android1/"},{"title":"查看日志","text":"logcat命令，As查看日志 logcat命令 adb logcat -help 查看帮助 adb logcat 常规显示 adb logcat -c 清除日志 adb logcat -g 显示缓冲区大小 adb logcat -G 256M 修改缓冲区大小 adb logcat -v time 设置不同的显示格式 adb logcat -v color 带颜色的显示 过滤方法 根据tag过滤日志 adb logcat -s xxx 根据pid过滤日志 获取进程pid ps -A｜grep 包名 adb logcat ｜findstr(win, mac(grep)) pid 根据自定义标签过滤 adb logcat｜findstr 自定义标签 AS中查看Logcat package:mine 用当前运行的应用包名进行过滤 level:DEBUG 显示调试级别以上信息 tag:xxx 过滤xxx的标签 -tag:xxx xxx的标签除外 message:xxx 过滤包含xxx关键字的信息","link":"/2023/08/13/android4/"},{"title":"查看包名","text":"查看安卓包名的方法 反编译查看清单文件 通过shell命令获取包名和入口类名 adb shell dumpsys window | grep mFocusedApp (mac下这个可以看到) adb shell dumpsys window | grep mCorrentFocus adb shell dumpsys window windows |grep mFocusedApp windows环境下将grep替换为findstr 查看入口类 adb shell dumpsys package 包名 | grep LAUNCHER 打印进程信息 Android8之前 ps Android8之后 ps -A pm list packages /data/data /data/app","link":"/2023/08/07/android3/"},{"title":"安卓常见目录","text":"安卓常见目录 /data/data 存放用户app数据的目录，每个app都有自己的目录，以包名命名，这是一个私有目录，app只能访问各自的目录，除非app有root权限，该目录下的文件要pull到电脑上来，通常先拷贝到sdcard目录 /data/app 用户安装的app存放在这个目录下，里面还有当前版本的base.apk安装包 /data/local/tmp 临时目录，权限很大 /system/app 目录：存放系统自带的app /system/lib 存放app用到的系统so文件 /system/lib64 存放app用到的系统so文件 /system/bin 存放shell命令 /system/framework 安卓系统所用到框架，一些jar文件 sd卡目录 不管手机里有没有储存卡都有这个目录，app操作sd卡目录需要申请权限，不同系统版本要求还不同 软连接 /sdcard /storage/self/primary /mnt/sdcard /storage/emulated/0","link":"/2023/10/23/android5/"},{"title":"Apk结构","text":"安卓版本和安卓应用结构 apk在进行反编译后 use-sdk android minSdkVersion='xx'xx表示最小支持sdk版本 android10 —sdk 29 android 13 —sdk 33 Android历史版本 4.4 以前使用dalvik/dvm虚拟机，libdvm.so 4.4 使用dvm和art虚拟机，可以切换libdvm.so、libart.so 5.0 之后采用art虚拟机，安卓系统开始分32位和64位 apk基本结构 assets 资源文件（图片、音频、数据库、网页、配置文件、dll、so等） res 资源文件（编译后到布局文件、程序图标） lib 各种平台下使用的对应的so文件 META-INF 签名文件 resources.arsc 资源加密（语言包） AndroidManifest.xml 清单文件（图标、界面、权限、代码执行入口） classes.dex java源代码需要反编译","link":"/2023/10/24/android6/"},{"title":"Js密码学(二)","text":"介绍消息摘要算法,MD5，SHA，HMAC（MD5，SHA）SM3使用。 消息摘要算法 MD5 SHA1，256，512 HmacMD5 HmacSHA1 HmacSHA256 HmacSHA512 RIPEMD160 HmacRIPEMD160 PBKDF2 EvpKDF SM3 单向散列，哈希算法（rename） 输入长度不固定，输出长度固定，密文不可逆 散列后结果唯一（绝大多数）（MD5，sh1有这问题） 用于校验数据完整性，签名 MD5 SHA MD5 散列后为16个字节，转换为Hex后为32个字符 输入无限长度 1234567let CryptoJS = require('./CryptoJS');//直接用，可以转换为wordArray也可以不转换let nihao_MD5 = CryptoJS.MD5('nihaonihao');//默认输出Hexconsole.log(nihao_MD5+ '');//转Base64console.log(nihao_MD5.toString(CryptoJS.enc.Base64)); SHA sha1散列后为20个字节，转换为Hex后为40个字符 sha1，sha2输入为有限长度 sha3输入为无限长度1234let CryptoJS = require('./CryptoJS');let wordArray = CryptoJS.enc.Utf8.parse('nihaonihao');console.log(CryptoJS.SHA1(wordArray)+'');console.log(CryptoJS.SHA256(wordArray)+''); 1234567891011 //第二种写法//创建一个MD5或SHA，压入数据，加密let md5 = CryptoJS.algo.MD5.create();md5.update('nihaonihao');//分段压入md5.update('nihao');//清空压入数据md5.reset();md5.update('nihao');let cipherText = md5.finalize()+'';console.log(cipherText); HMAC 多了个密钥 密文长度和对应的MD5，SHA一致 123456let CryptoJS = require('./CryptoJS');//默认Hex编码console.log(CryptoJS.HmacMD5('nihao','key')+'');console.log(CryptoJS.HmacSHA1('nihao','key')+'');//转Base64console.log(CryptoJS.HmacSHA1('nihao','key').toString(CryptoJS.enc.Base64)); 1234//第二种写法let hmacSHA1 = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA1.create(),'key');hmacSHA1.update('nihao');console.log(hmacSHA1.finalize()+'') SM3类似于SHA256算法密文长度32个字节，hex编码后64导入sm3文件 1234567//这一步是先将输入数据转成utf-8编码的字节流，然后再转成16进制可见字符var dataBy = Hex.utf8StrToBytes('nihao');var sm3 = new SM3Digest();sm3.update(dataBy,0,dataBy.length); //数据很多的话，可以分多次updatevar sm3Hash = sm3.doFinal(); //得到的数据是个byte数组var sm3HashHex = Hex.encode(sm3Hash,0,sm3Hash.length); //编码成16进制可见字符console.log(sm3HashHex);","link":"/2023/08/01/jsencrypt2/"},{"title":"Js密码学(三)","text":"介绍对称加密算法，DES，3DES，AES，SM4的使用，以及加密模式和填充方式。 对称加密算法 DES，3DES，AES，SM4 加密解密使用相同密钥 可以还原 加密方式（密钥位数） 序列加密 RCA 1-256字节 分组加密 DES 8字节 3DES 24字节 AES 16 24 32字节 SM4 16字节 加密模式和填充方式 加密模式 ECB模式 8个字符加密一次，再拼接起来 CBC模式（包括一个iv向量） 前8个字符和iv异或一次再加密，再和下一段异或，最后拼接起来 填充方式 填充的是字节不是字符，再不满足一个分组时填充满一个分组，刚好满一个分组时在填充一个分组 NoPaddding PKcs7（5） DES 密钥长度64bit 分组长度64bit 实际使用的56个字节 每一个密钥转换为8bit的最后一位不用 1234567891011121314151617181920212223let CryptoJS = require('./CryptoJS');let text = CryptoJS.enc.Utf8.parse('nihao');let key = CryptoJS.enc.Utf8.parse('12345678');let iv = CryptoJS.enc.Utf8.parse('12345678');//没有传cfg默认使用CBC模式Pkcs7填充var cfg ={ iv:iv, //ECB不用iv mode:CryptoJS.mode.CBC, //mode:CryptoJS.mode.ECB, padding:CryptoJS.pad.Pkcs7};let cipherObj = CryptoJS.DES.encrypt(text,key,cfg);console.log(cipherObj.toString())//Base64console.log(cipherObj.ciphertext.toString())//Hex// 9bb1965d9e71548c//解密 只能接受Base64数据let en_text = CryptoJS.enc.Hex.parse('9bb1965d9e71548c').toString(CryptoJS.enc.Base64);let cipherobj = CryptoJS.DES.decrypt(en_text,key,cfg).toString(CryptoJS.enc.Utf8);console.log(cipherobj); 3DES 密钥 24位 前八位加密，中间八位解码，后八位加密 使用方法和DES一样 把DES替换为TrioleDES AES 密钥长度不同 AES128， AES192，AES156 iv长度128位 使用方和DES一样改一下key和iv format和自动生成key iv format 密文/明文的自定义输出（cfg种指定format） CryptoJS自动生成key iv salt ，不需要传iv，cfg，只需要传key，他会自动生成iv 每次生成的key iv salt 均不同 12345678910111213let CryptoJS = require('./CryptoJS');//加密let cipherObj = CryptoJS.AES.encrypt('nihao','12345678');console.log(cipherObj);let cipherText = cipherObj.toString();console.log(cipherText);console.log(cipherObj.key.toString());console.log(cipherObj.iv.toString());console.log(cipherObj.salt.toString());//解密let plainObj = CryptoJS.AES.decrypt(cipherText,'12345678');console.log(plainObj.toString(CryptoJS.enc.Utf8)); SM4 国密算法 密钥128位16字节 使用SM4文件调用SM4算法 123456789101112131415161718function sm4_encrypt_ecb() { let inputBytes = Hex.decode('0123456789abcdeffedcba9876543210'); let key = Hex.decode('0123456789abcdeffedcba9876543210'); let sm4 = new SM4(); let cipher = sm4.encrypt_ecb(key, inputBytes); console.log(Hex.encode(cipher, 0, cipher.length));}function sm4_encrypt_cbc() { let inputBytes = Hex.decode('0123456789abcdeffedcba9876543210'); let key = Hex.decode('0123456789abcdeffedcba9876543210'); let iv = Hex.decode('0123456789abcdeffedcba9876543210'); let sm4 = new SM4(); let cipher = sm4.encrypt_cbc(key, iv, inputBytes); console.log(Hex.encode(cipher, 0, cipher.length));}sm4_encrypt_ecb();sm4_encrypt_cbc(); 其他算法 RIPEMD160 and HmacRIPEMD160(多个密钥) PBKDF2 文本 密钥 keySize iterations（迭代次数） EvpKDF 同上 RC4 RC4Drop 同AES Rabbit RabbitLegacy 流密码","link":"/2023/08/01/jsencrypt3/"},{"title":"TinyDB数据库","text":"面向文档，类似MongoDB 表示为字典的任何文档存入 纯python 小型数据库 增删改查1234567891011121314151617181920212223242526272829303132333435from tinydb import TinyDB,Query db = TinyDB(&quot;tiny.db&quot;)query= Query()# 增# db.insert({&quot;name&quot;: &quot;a&quot;, &quot;value&quot;:&quot;100&quot;})# db.insert_multiple(# [{&quot;name&quot;: &quot;b&quot;, &quot;value&quot;:&quot;123&quot;},# {&quot;name&quot;: &quot;c&quot;, &quot;value&quot;:&quot;qew&quot;}]# )# 输出内容# print(db.all())# for line in db:# print(line)# 搜索 query.name==query['name']# result = db.search(query.name==&quot;c&quot;)# print(result)# 更新db.insert_multiple( [{&quot;name&quot;: &quot;b&quot;, &quot;value&quot;:&quot;123&quot;}, {&quot;name&quot;: &quot;c&quot;, &quot;value&quot;:&quot;qew&quot;}])# 把name为b的value改为qewdb.update({&quot;value&quot;: &quot;qew&quot;},query.name==&quot;b&quot;)print(db.all())# 删除db.remove(query.name==&quot;c&quot;)# 全删db.truncate()print(db.all())","link":"/2023/10/23/database2/"},{"title":"Mongodb(一)","text":"Mongodb安装 基本操作 安装 brew tap mongodb/brew brew install mongodb-community 安装信息： 配置文件：**/usr/local/etc/mongod.conf** 日志文件路径：**/usr/local/var/log/mongodb** 数据存放路径：**/usr/local/var/mongodb** brew 启动： 1brew services start mongodb-community 查看http://127.0.0.1:27017/ 显示It looks like you are trying to access MongoDB over HTTP on the native driver port.表示开启 brew 停止： 1brew services stop mongodb-community 一个数据库包含多个集合，一个集合包含多个文档，一个文档为一句JSON键值对 数据类型：null，布尔型，数字，字符串，数组，二进制，日期，代码 基本操作 进入数据库：1mongosh 创建数据库：1use datademo 展示数据库：1show dbs 展示数据库集合：1show collections 删除数据库：1db.dropDatabase() 插入数据：1db.datatest.insert({&quot;name&quot;:&quot;test&quot;}) 插入多条数据：1db.datatest.insertMany([{&quot;name1&quot;:&quot;test1&quot;},{&quot;name2&quot;:&quot;test2&quot;}]) 读取数据：123db.datatest.findOne()db.datatest.find()db.datatest.find().pretty() 美化 更新数据库：12db.datatest.updateOne({&quot;name&quot;:&quot;test&quot;},{$set:{&quot;name&quot;:&quot;test3&quot;}})db.datatest.updateOne(db.datatest.findOne({&quot;name&quot;:&quot;test&quot;}),{$set:{&quot;name&quot;:&quot;test3&quot;}}) 删除数据：1db.datatest.remove({&quot;name&quot;:&quot;test3&quot;}) 删除所有符合条件的数据 删除数据库：1db.datatest.drop()","link":"/2023/11/13/mongo1/"},{"title":"Mongodb(二)","text":"mongodb的ID 特殊查询 pymongo mongodb的ID 每插入一条文档都有一个默认ID，而且必须存在 属于Objectid类型，有12个字节空间，共24个十六进制数字 0 1 2 3 时间戳，提供秒级别的唯一，能够按照时间顺序插入 4 5 6 机器标识符 7 8 不同进程PID 9 10 11 计数器：相同进程累加 mongdb查询 全部返回 1db.datatest.find() 查询条件小于等于5的 lt小于gt大于 1db.datatest.find({_id:{$lt:10}}) 查询条件在1，2，3里面的 1db.datatest.find({_id:{$in:[1,2,3]}}) 查询存在某项条件的 1db.datatest.find({id:{$exists:true}}) 查询显示：0为不显示，1为显示 1db.datatest.find({},{_id:0}) pymongo123456789101112131415161718192021222324252627282930313233343536import pymongo# link to mongodbclient=pymongo.MongoClient(&quot;mongodb://127.0.0.1:27017&quot;)# select databasedb=client['datademo']# select collectioncol=db['test']mydict={&quot;name&quot;:&quot;python&quot;}# insert datares=col.insert_one(mydict)print(res)# insert_many datamylist=[ {&quot;name&quot;:&quot;C++&quot;},{&quot;name&quot;:&quot;Lua&quot;}]# res=col.insert_many(mylist)# print(res)for num,i in enumerate(mylist): i['id']=num col.insert_one(i)# findres=col.find({},{&quot;_id&quot;:0})for r in res: print(r)# updatacol.update_one(mydict,{&quot;$set&quot;:{&quot;name&quot;:&quot;python3&quot;}})# deletecol.delete_many({})","link":"/2023/11/13/mongo2/"},{"title":"异步爬虫使用","text":"异步爬虫爬取图片 异步验证proxy 异步爬虫爬取图片 调用DownloadImage，List形式传入要下载的图片url 对于图片后缀suffix默认jpg 需要其他的再加12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import asyncioimport aiohttpfrom aiohttp import TCPConnectorimport osdef DownloadImage(urls='',address='',suffix='jpg',): async def download_image(url,address,suffix,tmp,): async with aiohttp.ClientSession(connector=TCPConnector(ssl=False)) as session: print('正在下载{}'.format(url)) response = await session.get(url) tmps = str(tmp) if response.status == 200: image_data = await response.read() if address =='': if not os.path.exists('images'): os.makedirs('images') print(&quot;文件夹已成功创建！&quot;) else: pass # 将获取到的图片数据保存为文件 if suffix == 'jpg': file_path = 'images'+'/'+url.split('/')[-1]+tmps+'.jpg' # 设置保存路径及名称 elif suffix == 'png': file_path = 'images'+'/'+url.split('/')[-1]+tmps+'.png' elif suffix == 'jpeg': file_path = 'images'+'/'+url.split('/')[-1]+tmps+'.jpeg' with open(file_path, 'wb') as f: f.write(image_data) print('{}图片已保存'.format(file_path)) else : if not os.path.exists(address): os.makedirs(address) print(&quot;文件夹已成功创建！&quot;) else: pass if suffix == 'jpg': file_path = address + '/'+url.split('/')[-1]+tmps+'.jpg' # 设置保存路径及名称 elif suffix == 'png': file_path = address + '/'+url.split('/')[-1]+tmps+'.png' elif suffix == 'jpeg': file_path = address + '/'+url.split('/')[-1]+tmps+'.jpeg' with open(file_path, 'wb') as f: f.write(image_data) print('{}图片已保存'.format(file_path)) else: print('无法下载图片') # 定义要下载的图片URL列表 urls = urls loop = asyncio.get_event_loop() tasks = [] tmp = 1 for url in urls: task = loop.create_task(download_image(url,address,suffix,tmp)) tasks.append(task) tmp += 1 loop.run_until_complete(asyncio.wait(tasks)) loop.close() 异步验证proxy1234567891011121314151617181920212223def Proxy_test(proxies): tasks = [] enable_proxy = [] test_url = 'https://httpbin.org/ip' async def get_status_code(test_url,my_proxy): async with aiohttp.ClientSession(connector=TCPConnector(ssl=False),) as session: try: response = await session.get(url=test_url,proxy=my_proxy,timeout=10) if response.status == 200: print('{}代理可用'.format(my_proxy)) enable_proxy.append(my_proxy) except: print('{}代理不可用'.format(my_proxy)) pass loop = asyncio.get_event_loop() for my_proxy in proxies: task = loop.create_task(get_status_code(test_url,my_proxy)) tasks.append(task) loop.run_until_complete(asyncio.wait(tasks)) loop.close()","link":"/2024/01/16/myaio/"},{"title":"MySql(一)","text":"MySql在mac上启动不了执行命令 数据库基本用法 MySql启动不了执行命令-sudo chown -RL root:mysql /usr/local/mysql-sudo chown -RL mysql:mysql /usr/local/mysql/data-sudo /usr/local/mysql/support-files/mysql.server start 关闭MySql mysql.server stop mysql -uroot -p 登陆 修改密码为root ALTER USER 'root'@'localhost' IDENTIFIED BY 'root'; 数据库操作 显示数据库mysql&gt; show databases; 创建数据库mysql&gt; create database test1; 使用数据库mysql&gt; use test1; 先使用数据库再展示数据库的表mysql&gt; use test1; 删除数据库mysql&gt; drop database test1; 表操作 创建表 创建表名为user 内有name age date属性mysql&gt; create table user(name varchar(10),age int(2),date date); 查看表格式mysql&gt; desc user; 查看详细描述mysql&gt; show create table user; 修改表 修改 修改name为varchar（20）mysql&gt; alter table user modify name varchar(20); 改名 修改age为age1 int（4）mysql&gt; alter table user change age age1 int(4); 新增 新增test行mysql&gt; alter table user add column test varchar(10); 删除 删除test行mysql&gt; alter table user drop column test; 表名 修改整个表名mysql&gt; alter table user rename user1; 删除表mysql&gt; drop table user;","link":"/2023/10/25/mysql1/"},{"title":"MySql(二)","text":"表操作 数据类型 表操作 插入数据 insert into user1 values(“nihao”,”20”,”2021-01-29”); 向user1插入(“nihao”,”20”,”2021-01-29”) insert into user1(name) values(“buhao”),(“test”); 向user1的name属性插入(“buhao”),(“test”)，其他属性为NULL 查询数据 select * from user1; 查询全部user1数据 select * from user1 where age1=”20”; 查询全部user1数据中age1条件为20的所有数据 select name,age1 from user1; 查找user1数据中所有name，age1的数据 更新数据 update user1 set age1=30 where name=”buhao”; 更新name条件为buhao的数据的age1为30 删除数据 delete from user1 where age1=30; 删除age1条件为30的全部数据 数据类型 tinyint int bigint float double bit int(5)指的是具体宽度显示，插入超过数据宽度不会被截断 默认int宽度为10，使用zerofill 用0填充 alter table t1 modify id2 int(5) zerofill; 如果用int会直接改为10宽度 修改查询bit数据的显示方式，以hex显示，以bin显示 select id3,hex(id3),bin(id3) from t1; 字符串类型 char 0-255 varchar 0-65535 text 0-65535字节 mediumtext 0-167772150字节 longtext 0-4294967295字节 二进制字符串 binary varbinary（大一些） 检索时char会删除尾部空格 length（）计算长度 concat（）查询时连接一个标志 mysql&gt; select length(v1),concat(“biaozhi”) from vc; 日期类型 类型 date 年月日 datetime 年月日时分秒 默认 now() timestamp 年月日时分秒 默认 current_timestamp() time 时分秒 year 年份 插入默认 now() current_timestamp() mysql&gt; insert into dd values(now(),now(),now(),now(),now()); 设置默认 mysql&gt; alter table dd modify d2 datetime default now(); mysql&gt; alter table dd modify d3 timestamp default current_timestamp(); date time year 没有默认值，但是可以自行设置一个固定的默认值方法同上。","link":"/2023/11/07/mysql2/"},{"title":"MySql(三)","text":"存储引擎 MySQL事务 表连接 存储引擎 MySql的存储引擎是插件式的，支持多种引擎 5.0支持 MyISAM InnoDB BDB MEMORY等 InnoDB BDB是事务性安全表 5.5之后默认为InnoDB，之前均为MyISAM mysql&gt; show engines;查看支持引擎 mysql&gt; alter table xx engine=myisam;修改引擎 MyISAM 不支持事务，优点是速度快 如果主要以select，insert为主的可以使用 InnoDB 提供事务（提交，回滚，崩溃恢复） 比MyISAM速度慢，磁盘占用多 MEMORY 使用内存中的数据来建表，数据放在内存中，速度很快，服务关闭时数据丢失 MySQL事务 四大特性 原子性：一个事务中的所有操作，要么全部完成要么全部不完成，出现错误会回滚到事务开始之前。 一致性：在事务开始之前和结束之后，数据库的完整性没有被破坏，表示写入数据必须完全符合所有预设规则。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的操作，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。 持久性：事务结束后，对数据的修改是永久的。 操作 mysql&gt; start transaction; 开启事务 mysql&gt; commit; 提交内容 mysql&gt; rollback; 回滚 mysql&gt; commit and chain; 提交并开启新事务 表锁：进行表锁后只能有一个线程去操作表，其他线程会被阻塞 mysql&gt; lock table xxx write；xxx表的写权限上锁，其他不受影响 mysql&gt; unlock tables; 解锁 表连接 通常多个表之间的数据会有联系，同时选择多个关联的表 内连接：选出两张表中相匹配的记录，本质上是找两个表的相同部分 select xxx,xxx,xxx from 表1，表2 where 表1.xxx=表2.xxx; 外连接：本质上是包含某一个表的全部信息 左外链接：包含所有左边表的记录，右表没有和他匹配的为NULL select xxx,xxx,xxx from 表1 left join 表2 on 表1.xxx=表2.xxx; 右外连接：包含所有右边表的记录，左表没有和他匹配的为NULL select xxx,xxx,xxx from 表2 right join 表1 on 表1.xxx=表2.xxx; 子查询 当进行查询的时候，查询条件需要另一个SQL命令的结果 子查询需要两张表的字段名字一致 alter table 表1名 change xxx yyy int 把表1中xxx改为yyy select * from 表1 where xxx in (select xxx from xxx); in可以用=替代 select * from 表1 where xxx = (select xxx from xxx limit 1);","link":"/2023/11/07/mysql3/"},{"title":"MySql(四)","text":"pymysql 使用python多线程操作数据库 使用python操作MySql1234567891011121314151617181920212223242526import pymysqldb = pymysql.connect(host='localhost', user='root', password='root', database='test1', port=3306)# 游标cursor = db.cursor()# 搜索数据cursor.execute('show tables')data = cursor.fetchall()print(data)# 插入数据 如果你的表的引擎是Innodb事务# 默认吧事务开起来 所以需要提交try: cursor.execute(&quot;insert into vc values('123','123')&quot;) cursor.execute(&quot;select * from vc&quot;) data = cursor.fetchall() print(data) #提交 #cursor.execute(&quot;commit&quot;) db.commit()except: db.rollback()cursor.close()db.close() 使用多线程操作数据库 pymysql不支持并发，需要使用锁123456789101112131415161718192021222324252627282930313233343536373839404142import pymysqlimport threadingfrom threading import Locklock = Lock()db = pymysql.connect(host='localhost', user='root', password='root', database='test1', port=3306)# 写入数据def write_con(): try: print(&quot;写入数据&quot;) # 获取游标 cursor = db.cursor() lock.acquire() cursor.execute(&quot;insert into vc values('321','321')&quot;) db.commit() lock.release() except: db.rollback()# 查询数据def read_con(): try: print(&quot;查询数据&quot;) cursor = db.cursor() lock.acquire() cursor.execute(&quot;select * from vc&quot;) data = cursor.fetchall() print(data) lock.release() except: db.rollback()t1 = threading.Thread(target=write_con)t2 = threading.Thread(target=read_con)t1.start()t2.start()t1.join()t2.join()print(&quot;over&quot;)db.close()","link":"/2023/11/07/mysql4/"},{"title":"MySql(五)","text":"sqlalchemy使用 基础使用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, Integer, String,Date,UnicodeTextfrom sqlalchemy.orm import sessionmakerfrom sqlalchemy import create_enginefrom datetime import datetime# 引擎engine = create_engine(&quot;mysql+pymysql://root:root@127.0.0.1:3306/test1&quot;)#创建表Base = declarative_base()class User(Base): __tablename__ = 'user' id = Column(Integer, primary_key=True)#主键 索引 不需要你添加 id 自增 name = Column(String(32)) age = Column(Integer,nullable=True)#可以为空 date=Column(Date,default=datetime.now())#默认 desc=Column(UnicodeText,nullable=True)#定义初始化数据库函数def init_db(): Base.metadata.create_all(engine)#顶固删除数据库函数def drop_db(): Base.metadata.drop_all(engine)drop_db()init_db()Session = sessionmaker(bind=engine) #创建sessionsession = Session()# 增obj = User(name=&quot;nihao&quot;, age=30,desc=&quot;nihao&quot;) #添加单条session.add(obj) #加入到队列session.add_all([ #添加多条 User(name=&quot;lry&quot;), User(name=&quot;abu&quot;),])session.commit() # 添加到sql#删session.query(User).filter(User.id &gt;1).delete()session.commit()#改 修改内容为字典session.query(User).filter(User.name=='xjb').update({&quot;name&quot; : &quot;xjb2&quot;,&quot;age&quot;:100})session.commit()#查ret = session.query(User).all() # 查询所有print(ret[0].name,ret[0].desc)ret = session.query(User.name, User.age).all()ret = session.query(User).filter(User.age&gt;10).all()ret = session.query(User).filter(User.age&gt;10).first()# ret是一个对象列表。这个对象可以通过 “对象[索引].字段”来获取对应的值ret = session.query(User).all() #查询列表所有数据#print(ret[0].name) #结果为元组，可通过下标的形式for i in ret: #循环元组， print(i.name,i.age,i.desc,i.date) 多线程数据库连接池1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import threadingfrom sqlalchemy.orm import sessionmakerfrom sqlalchemy import create_engine# User表from User import Userfrom threading import Threadengine = create_engine( &quot;mysql+pymysql://root:root@127.0.0.1:3306/test1&quot;, max_overflow=3, # 超过连接池大小外最多创建的连接 pool_size=10, # 连接池大小 pool_timeout=30, # 池中没有线程最多等待的时间，否则报错)Session = sessionmaker(bind=engine)def task_add(): # 去连接池中获取一个连接 session = Session() try: # 向表内添加线程信息 user=User(name=threading.currentThread().getName()) session.add(user) session.commit() print(threading.currentThread().getName()) except: session.rollback() # 将连接交还给连接池 session.close()def task_query(): # 去连接池中获取一个连接 session = Session() try: user=session.query(User).all() print(threading.currentThread().getName(),user) except: session.rollback() # 将连接交还给连接池 session.close()threads=[]for i in range(10): t=Thread(target=task_add) threads.append(t)for j in range(10): t=Thread(target=task_query) threads.append(t)for t in threads: t.start() t.join() 储存json123456789101112131415161718192021222324252627282930313233343536373839404142from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, Integer, String,Date,UnicodeText,JSONfrom sqlalchemy.orm import sessionmaker,relationshipfrom sqlalchemy import create_engine,ForeignKeyfrom datetime import datetimeengine = create_engine(&quot;mysql+pymysql://root:root@127.0.0.1:3306/test1&quot;)#创建表Base = declarative_base()class JData(Base): __tablename__ = 'jdata' id = Column(Integer, primary_key=True)#主键 索引 不需要你添加 id 自增 data=Column(JSON)#定义初始化数据库函数def init_db(): Base.metadata.create_all(engine)#顶固删除数据库函数def drop_db(): Base.metadata.drop_all(engine)drop_db()init_db()Session = sessionmaker(bind=engine) #创建sessionsession = Session()# 增# 以字典的形式添加session.add_all([ #添加多条 JData(data={&quot;name&quot;:&quot;python&quot;,&quot;time&quot;:1}), JData(data={&quot;name&quot;:&quot;go&quot;,&quot;time&quot;:2}),])session.commit() # 添加到sqlret = session.query(JData).all() #查询列表所有数据for i in ret: #循环元组， print(i.id,i.data) 通过外键进行多表查询 通过（ForeignKey）外键关联两张表 通过relationship定义两表相互访问时的名字123456789101112131415161718192021222324252627from sqlalchemy.orm import sessionmaker,relationshipfrom sqlalchemy import create_engine,ForeignKeyclass Myclass(Base): __tablename__ = 'class' id = Column(Integer, primary_key=True)#主键 索引 不需要你添加 id 自增 name = Column(String(32)) #通过relationship定义两表相互访问时的名字 students=relationship('User',back_populates='myclass') def __str__(self): return f'id{self.id} name:{self.name}'class User(Base): __tablename__ = 'user' id = Column(Integer, primary_key=True)#主键 索引 不需要你添加 id 自增 name = Column(String(32)) age = Column(Integer,nullable=True) date=Column(Date,default=datetime.now()) desc=Column(UnicodeText,nullable=True) # 通过外键关联ForeignKey class_id=Column(Integer,ForeignKey(Myclass.id)) myclass=relationship(&quot;Myclass&quot;,back_populates='students')ret = session.query(Myclass).all() #查询列表所有数据for i in ret: #循环元组， print(i.id,i.name,i.students)","link":"/2023/11/07/mysql5/"},{"title":"Python密码学(一)","text":"介绍使用python实现消息摘要算法，MD5，SHA，HMAC（MD5，SHA）和SM3算法 消息摘要算法 消息摘要算法是一种可以将文本或其他信息压缩成简短的字符串的算法。这些字符串被称为消息摘要算法或散列值。 作用：验证文件的完成性，在加密数据库中存储密码 MD和SHA（哈希函数） 给定输入，返回相同的输出 输出长度固定，输入长度不同 不可逆 MD51234567from Crypto.Hash import MD5word = MD5.new(b'nihao')print(word.hexdigest())word2 = MD5.new()word2.update(b'ni')word2.update(b'hao')print(word2.hexdigest()) SHA1234567from Crypto.Hash import SHA256,SHA3_256word3 = SHA256.new(b'nihao')word4 = SHA256.new()word4.update(b'ni')word4.update(b'hao')print(word3.hexdigest())print(word4.hexdigest()) HMAC hash算法的进阶版，在hash计算过程中混入了key（加盐），防止彩虹表破解 选择一种hash函数，SHA1，SHA256 生成密钥，并将其与消息一起输入 12345678910111213import hmacfrom Crypto.Random import get_random_bytesfrom Crypto.Hash import MD5,SHA512data = '你好'.encode()key = get_random_bytes(16)#key = b'123456789'#加盐后的res = hmac.new(key,msg=data,digestmod=MD5).hexdigest()print('hmac',res)# 原版md5res2 = MD5.new(data).hexdigest()print('md5',res2) SM3 SM国密算法 SM31234567#sm3的使用 约等于SHA256from gmssl import sm3data = 'nihao'.encode()result = sm3.sm3_hash(sm3.bytes_to_list(data=data))print(result)print(len(result))","link":"/2023/08/01/pycrypt1/"},{"title":"Python密码学(二)","text":"介绍使用python实现对称加密算法，DES，3DES，AES，RC4和SM4算法。 对称加密算法 加密mode ECB模式：将明文简单的按照128bit为一个分块进行切割，在把每个分块进行AES加密，然后将密文拼接，如果长度不足128位，则会补全。 CBC模式：先对第一个明文块加密，之后每一个与前一个密文进行异或后再加密，每个密文块都依赖前面所以明文块。第一个明文块要用到IV，在CBC模式下IV要先与第一个明文块进行异或得到第一个明文块，在对后续加密。 OFB模式 CTR模式 CFB模式 DES，3DES DES 对称加密 64bit 8个字节（有效长度为56bit） 16轮迭代加密 56位密钥对64位明文进行加密 不安全 使用的模式mode和AES一致5种 12345678910111213141516171819202122232425from Crypto.Cipher import DESfrom Crypto.Util.Padding import pad,unpadfrom Crypto.Random import get_random_byteskey = get_random_bytes(8)def encrypt_des(data): # 模式和AES一样的用法 des = DES.new(key,DES.MODE_ECB) res = des.encrypt(pad(data,8)) print('加密结果',res) return resdef decrypt_des(data): # 模式和AES一样的用法 des = DES.new(key,DES.MODE_ECB) res = des.decrypt(data) print('解密结果',unpad(res,8).decode()) return unpad(res,8)if __name__ == '__main__': data = '你好'.encode() res = encrypt_des(data) decrypt_des(res) 3DES 三倍56位加密 前56位加密，中间56位解密，后56位加密 123456789101112131415161718192021222324from Crypto.Cipher import DES,DES3from Crypto.Util.Padding import pad,unpadfrom Crypto.Random import get_random_byteskey = get_random_bytes(24)def encrypt_des(data): # 模式和AES一样的用法 des = DES3.new(key,DES3.MODE_ECB) res = des.encrypt(pad(data,8)) print('加密结果',res) return resdef decrypt_des(data): # 模式和AES一样的用法 des = DES3.new(key,DES3.MODE_ECB) res = des.decrypt(data) print('解密结果',unpad(res,8).decode()) return unpad(res,8)if __name__ == '__main__': data = '你好'.encode() res = encrypt_des(data) decrypt_des(res) AES AES是一种常用的对称加密算法，使用密钥加密，使用密钥解密 特点： 速度快，安全 长度128位，192位，256位 模式 ECB模式：将明文简单的按照128bit为一个分块进行切割，在把每个分块进行AES加密，然后将密文拼接，如果长度不足128位，则会补全。 1234567891011121314151617181920212223242526from Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad,unpadfrom base64 import b64decode,b64encodekey = get_random_bytes(16)# 加密def encrypt_ecb(data): aes=AES.new(key,AES.MODE_ECB) res=aes.encrypt(pad(data,16)) print(b64encode(res).decode()) return b64encode(res).decode()# cBUc8RKHih7RkWRG2e9C2Q==# 解密def decrypt_ecb(data): aes=AES.new(key,AES.MODE_ECB) res=aes.decrypt(b64decode(data.encode())) print(unpad(res,16).decode()) if __name__=='__main__': data = '你好'.encode() res=encrypt_ecb(data) decrypt_ecb(res) CBC模式：先对第一个明文块加密，之后每一个与前一个密文进行异或后再加密，每个密文块都依赖前面所以明文块。第一个明文块要用到IV，在CBC模式下IV要先与第一个明文块进行异或得到第一个明文块，在对后续加密 12345678910111213141516171819202122232425from Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad,unpadfrom base64 import b64decode,b64encodekey = get_random_bytes(16)iv = get_random_bytes(16)# 加密def encrypt_cbc(data): aes=AES.new(key,AES.MODE_CBC,iv=iv) res=aes.encrypt(pad(data,16)) print(b64encode(res).decode()) return b64encode(res).decode()# R3jIvRc7SZx88iRa3yEMfw==# 解密def decrypt_cbc(data): aes=AES.new(key,AES.MODE_CBC,iv=iv) res=aes.decrypt(b64decode(data.encode())) print(unpad(res,16).decode()) if __name__=='__main__': data = '你好'.encode() res=encrypt_cbc(data) decrypt_cbc(res) OFB模式 12345678910111213141516171819202122232425from Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad,unpadfrom base64 import b64decode,b64encodekey = get_random_bytes(16)iv = get_random_bytes(16)# 加密def encrypt_ofb(data): aes=AES.new(key,AES.MODE_OFB,iv=iv) res=aes.encrypt(pad(data,16)) print(b64encode(res).decode()) return b64encode(res).decode()# SoNsyX8HqZrHxAlUtFA34w==# 解密def decrypt_ofb(data): aes=AES.new(key,AES.MODE_OFB,iv=iv) res=aes.decrypt(b64decode(data.encode())) print(unpad(res,16).decode()) if __name__=='__main__': data = '你好'.encode() res=encrypt_ofb(data) decrypt_ofb(res) CTR模式 1234567891011121314151617181920212223242526from Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad,unpadfrom base64 import b64decode,b64encodekey = get_random_bytes(16)nonce = get_random_bytes(8)# 加密def encrypt_ctr(data): aes=AES.new(key,AES.MODE_CTR,nonce=nonce) res=aes.encrypt(pad(data,16)) print(b64encode(res).decode()) return b64encode(res).decode()# UW9GRltpxIrUF1M80gI/sw==# 解密def decrypt_ctr(data): aes=AES.new(key,AES.MODE_CTR,nonce=nonce) res=aes.decrypt(b64decode(data.encode())) print(unpad(res,16).decode()) if __name__=='__main__': data = '你好'.encode() res=encrypt_ctr(data) decrypt_ctr(res) CFB模式 12345678910111213141516171819202122232425from Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad,unpadfrom base64 import b64decode,b64encodekey = get_random_bytes(16)iv = get_random_bytes(16)# 加密def encrypt_cfb(data): aes=AES.new(key,AES.MODE_CFB,iv=iv) res=aes.encrypt(pad(data,16)) print(b64encode(res).decode()) return b64encode(res).decode()# nwqQbIwBjQ/VfumOJk6KEg==# 解密def decrypt_cfb(data): aes=AES.new(key,AES.MODE_CFB,iv=iv) res=aes.decrypt(b64decode(data.encode())) print(unpad(res,16).decode()) if __name__=='__main__': data = '你好'.encode() res=encrypt_cfb(data) decrypt_cfb(res) RC4 字节流加密—-以此加密明文中每一个字节，解密也是如此 RC4密钥长度1-256字节，最好128位以上，安全 12345678910111213141516171819from Crypto.Cipher import ARC4from Crypto.Random import get_random_bytesdata = '你好'.encode()key = get_random_bytes(16)def encrypt_arc4(data,key): arc = ARC4.new(key) res = arc.encrypt(data) print(res) return resdef decrypt_arc4(data,key): arc = ARC4.new(key) res = arc.decrypt(data) print(res.decode()) return resif __name__ == '__main__': res = encrypt_arc4(data,key) decrypt_arc4(res,key) SM4 SM4对称加密算法 123456789101112131415161718192021222324#ecb模式from gmssl import sm4from Crypto.Random import get_random_bytes#加密mode = 0def encrypt_sm4(data): SM4 = sm4.CryptSM4() SM4.set_key(key,mode=0) res = SM4.crypt_ecb(data) print('加密结果',res) return res#解密mode =1def decrypt_sm4(data): SM4 = sm4.CryptSM4() SM4.set_key(key,mode=1) res = SM4.crypt_ecb(data) print('解密结果',res.decode()) return resif __name__ == '__main__': key = get_random_bytes(16) data = '你好'.encode() res = encrypt_sm4(data) decrypt_sm4(res) 12345678910111213141516171819202122232425#cbc模式from gmssl import sm4from Crypto.Random import get_random_bytes#加密mode = 0def encrypt_sm4(data): SM4 = sm4.CryptSM4() SM4.set_key(key,mode=0) res = SM4.crypt_cbc(iv,data) print('加密结果',res) return res#解密mode =1def decrypt_sm4(data): SM4 = sm4.CryptSM4() SM4.set_key(key,mode=1) res = SM4.crypt_cbc(iv,data) print('解密结果',res.decode()) return resif __name__ == '__main__': key = get_random_bytes(16) iv = get_random_bytes(16) data = '你好'.encode() res = encrypt_sm4(data) decrypt_sm4(res)","link":"/2023/08/01/pycrypt2/"},{"title":"Python密码学(三)","text":"介绍使用python实现非对称加密算法，RSA，SM2，数字签名算法。 非对称加密算法RSA 两个不同密钥，一个用来加密一个用来解密 安全性强与AES但速度慢 先生成密钥对在调用加密器PKCS1_OAEP再进行加密 1234567891011121314151617181920212223242526from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEP#生成密钥key = RSA.generate(2048)public_key = key.public_key().export_key()private_key = key.export_key()#加密def encrypt_rsa(data): my_key = RSA.import_key(public_key) rsa = PKCS1_OAEP.new(my_key) res = rsa.encrypt(data) print('加密结果',res) return res#解密 def decrypt_rsa(data): my_key = RSA.import_key(private_key) rsa = PKCS1_OAEP.new(my_key) res = rsa.decrypt(data) print('解密结果',res.decode()) return resif __name__=='__main__': data = &quot;你好&quot;.encode() print(data) res = encrypt_rsa(data) de_res = decrypt_rsa(res) 将密码存入文件中读写 1234567891011from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEP#生成密钥key = RSA.generate(2048)with open('python/public.pem','wb')as f: public_key = key.public_key().export_key() f.write(public_key)with open('python/private.pem','wb')as f: private_key = key.export_key() f.write(private_key) 12345678910111213141516171819202122from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEP#加密def encrypt_rsa(data): my_key = RSA.import_key(open('python/public.pem','rb').read()) rsa = PKCS1_OAEP.new(my_key) res = rsa.encrypt(data) print('加密结果',res) return res#解密 def decrypt_rsa(data): my_key = RSA.import_key(open('python/private.pem','rb').read()) rsa = PKCS1_OAEP.new(my_key) res = rsa.decrypt(data) print('解密结果',res.decode()) return resif __name__=='__main__': data = &quot;你好&quot;.encode() print(data) res = encrypt_rsa(data) de_res = decrypt_rsa(res) SM2 密钥对需要专门的SM密钥生成器生成 使用gmsll库进行加密 12345678910111213141516171819202122from gmssl import sm2private_key = 'f379721d08cc34bcbb37f76343043ca3c614ce39a23c7cacd0b9ab75fbddf301'public_key = 'be4bea1224719c10ebf550ee66a24c7e7fbe94329749ce32651b666a32474e0953b5f29'\\ '6c14d29d853e85e8f724de20028050d69409de13e6b42f1f2107e3e3e'key=sm2.CryptSM2(private_key,public_key)# 加密def encrypt_sm2(data): res = key.encrypt(data) print('加密结果',res) return res#解密def decrypt_sm2(data): res = key.decrypt(data) print('解密结果',res.decode()) return resif __name__ == '__main__': data = '你好'.encode() res = encrypt_sm2(data) de_res = decrypt_sm2(res) 也可以实现数字签名算法 12345678910111213141516171819202122232425262728#签名from gmssl import sm2private_key = 'f379721d08cc34bcbb37f76343043ca3c614ce39a23c7cacd0b9ab75fbddf301'public_key = 'be4bea1224719c10ebf550ee66a24c7e7fbe94329749ce32651b666a32474e0953b5f296c14d29d'\\ '853e85e8f724de20028050d69409de13e6b42f1f2107e3e3e'key=sm2.CryptSM2(private_key,public_key)# 加密def encrypt_sm2(data): res = key.encrypt(data) signature = key.sign(data,private_key) print('加密结果',res) print('签名',signature) return res,signature#解密def decrypt_sm2(data,signature): res = key.decrypt(data) print('解密结果',res.decode()) verify = key.verify(signature,res) print('签名结果',verify) return res,if __name__ == '__main__': data = '你好'.encode() res,signature = encrypt_sm2(data) de_res = decrypt_sm2(res,signature) 数字签名算法 公钥用于签名验证，私钥用于签名生成 过程如下 签名过程：消息的Hash值被用作数字签名，然后使用私钥加密，生成数字签名。 验证过程：将数字签名用于公钥解密，并与消息的Hash值比较，如果两个值相同，则证明数字签名是合法的 数字签名的目的是为了保证数据的完整性和发送者的身份验证 保证数据在传输过程中没有被篡改 身份验证 不可抵赖性，认证 12345678910111213141516171819202122232425262728293031323334353637383940from Crypto.PublicKey import RSA,DSA,ECCfrom Crypto.Cipher import PKCS1_OAEPfrom Crypto.Signature import pkcs1_15from Crypto.Hash import SHA512myPublic_key = RSA.import_key(open('python/public.pem','rb').read())myPrivate_key = RSA.import_key(open('python/private.pem','rb').read())#加密def encrypt_rsa(data): digest = SHA512.new(data) signature = pkcs1_15.new(myPrivate_key).sign(digest) rsa = PKCS1_OAEP.new(myPublic_key) res = rsa.encrypt(data) print('加密结果',res) return res,signature#解密 def decrypt_rsa(data,signature): rsa = PKCS1_OAEP.new(myPrivate_key) res = rsa.decrypt(data) print('解密结果',res.decode()) digeat = SHA512.new(res) try: pkcs1_15.new(myPublic_key).verify(digeat,signature) print('签名以通过') except: print('签名未通过') return resif __name__=='__main__': data = &quot;你好&quot;.encode() print(data) res,signature = encrypt_rsa(data) de_res = decrypt_rsa(res,signature)","link":"/2023/08/01/pycrypt3/"},{"title":"Js密码学(四)","text":"介绍非对称加密算法，RSA，SM2和数字加密算法库的使用。 非对称加密算法 RSA SM2 加密解密使用不同密钥的算法 用于加密比较短的数据 公钥和私钥成对生成 公钥加密私钥解密，私钥加密公钥解密 常用1024位，2048位 私钥内包含公钥 密钥格式 PKCS1格式的密钥 前缀 —–BEGIN RSA PRIVATE KEY—– 后缀 —–END RSA PRIVATE KEY—– PKCS8格式的密钥 前缀 —–BEGIN PRIVATE KEY—– 后缀 —–END PRIVATE KEY—– 填充方式 PKCS1Padding 明文最大字节数为密钥字节数-11 密文和密钥是等长的 每次填充不一样结果不一样 NOPadding 明文最大字节数为密钥字节数 密文和密钥是等长的 填充字节为0，加密后密文不变 RSA加密库使用 使用jsencrypt.js文件 使用python可以生成公钥和私钥1234567891011121314151617function getEncrypt(password, publickey){ //实例化一个JSEncrypt对象 var jsEncrypt = new JSEncrypt(); //调用setPublicKey设置公钥 jsEncrypt.setPublicKey(publickey); //调用encrypt方法加密明文 return jsEncrypt.encrypt(password);}var publicKeyBase64 = &quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDxRQHxL/8xZ1EaNmQBGZnpMiCY&quot; + &quot;7gRzog6nDjfBJacytEiVJnJRuq1V/D+JKaXDwetsCnSUaz65LCFHU09OSEYee5oC&quot; + &quot;iI0ql21EA306c91oT/fQpPngQGZHLUtDOUdJVlAKnicCvmR24NqyNKFuY8L0cnB1&quot; + &quot;zcax73Rf+Ctf/lxAOwIDAQAB&quot;;console.log(getEncrypt(&quot;nihaonihaonihaonihaonihaonihaonihaonihaonihaonihaonihaonihaonihao&quot;, publicKeyBase64));//采用PKCS1Padding填充，每次填充不同，结果会变化 返回的是Base64编码的结果 使用RSA.js文件 12345678910111213let password = 'a12345678';function test(password) { setMaxDigits(129); //传入加密指数和加密模数，中间一般没有 var key_to_encode = new RSAKeyPair(&quot;010001&quot;, &quot;&quot;, &quot;978C0A92D2173439707498F0944AA476B1B62595877DD6FA87F6E2AC6DCB3D0BF0B82857439C99B5091192BC134889DFF6&quot;\\ &quot;0C562EC54EFBA4FF2F9D55ADBCCEA4A2FBA80CB398ED501280A007C83AF30C3D1A142D6133C63012B90AB26AC60C898FB6&quot;\\ &quot;6EDC3192C3EC4FF66925A64003B72496099F4F09A9FB72A2CF9E4D770C41&quot;); //传入密钥和明文返回Hex编码的结果动态变化 return encryptedString(key_to_encode, password);}console.log(test(password)); SM2算法库 sm2Test.html vscode安装live serve 右下角Go live运行html文件 数字加密算法（多种算法结合） 随机生成AES密钥AESKey AESKey密钥用于AES加密数据，得到数据密文cipherText 使用RSA对AESKey加密，得到密钥密文cipherKey 提交密钥密文cipherKey和数据密文cipherText给服务器 使用数字加密算法库jsshuziqianming.js1234567891011121314var signData = &quot;nihao&quot;;//PKCS1格式的密钥 前缀 -----BEGIN RSA PRIVATE KEY----- 后缀 -----END RSA PRIVATE KEY-----//PKCS8格式的密钥 前缀 -----BEGIN PRIVATE KEY----- 后缀 -----END PRIVATE KEY-----//必须将完整的密钥传入告诉他是那种密钥格式var privateKeyBase64 = &quot;-----BEGIN PRIVATE KEY-----MIICdwIBADANBgkq&quot; + &quot;此处省略密钥内容&quot;+ &quot;FAmhvYQwwLnifrw=-----END PRIVATE KEY-----&quot;;//使用私钥进行签名，结果不变function doSign() { var signature = KEYUTIL.getKey(privateKeyBase64); var hSig = signature.signString(signData, &quot;sha256&quot;);//小写sha256 return hex2b64(hSig);}console.log(doSign());","link":"/2023/08/01/jsencrypt4/"},{"title":"Python基础(二)","text":"异步协程 异步:在单线程中利用IO等待时间去执行其他任务 携程:一个个没有并发起来的任务，协程本身不会多个并发需要我们包装成任务 注意: 如果不加await 则任务只是一个声明不会运行，await + 等待执行的任务 在等待程序前面加上asyncio表示这是个异步程序 123456789101112131415161718192021222324import asyncioasync def num(name): print('{}start'.format(name)) await asyncio.sleep(2) print('{}end'.format(name))async def main(): t1=[asyncio.create_task(num(1)), asyncio.create_task(num(2)), asyncio.create_task(num(3))] await asyncio.wait(t1)#两种写法效果一样# async def main():# t1 = [num(1),# num(2),# num(3)]# await asyncio.gather(*t1)if __name__ == '__main__': #声明协程对象 并不会直接运行 #await运行协程任务 等待 会一直阻塞到任务结果返回 asyncio.run(main())","link":"/2023/08/06/python2/"},{"title":"Js密码学(一)","text":"介绍常见的编码方式。使用CryptoJS包进行Hex，Base64编码操作。 编码方式 ASCII 128个字符，每个占1个字节 UTF8 字母数字1个字节，汉字3-4个字节 Unicode 字母数字汉字都2个字节 GBK 字母1个字节，汉字2个字节 ANSI win通用字符，根据地区不同改变 Hex 密钥和密文的编码 用0123456789abcdef表示 可以进行修改 4个bit位对应一个字符，2个十六进制字符代表一个字节 ，结果原文2倍 URL 本质是Hex编码，在每一个字节前面加了% 主要是对汉字进行编码 一个汉字转换为%xx%xx%xx Base64 用64个字符表示任意二进制数据 6个bit位对应一个字符，结果比原文多1/3 RSA密钥，图片，密文 为了数据传输安全，通常会将Base64数据进行URL编码，或将+/替换位-_（+服务器接收到后会变成一个空格） A-Z a-z 0-9 +/ 共64 Hex编码 utf8转Hex后长度变为两倍123456789//导文件let CryptoJS = require('./CryptoJS');//不能直接传string 要转换为wordArray//每四个字符转换为wrods中一个数字let ninao = CryptoJS.enc.Utf8.parse('nihaonihao');console.log(ninao)console.log(CryptoJS.enc.Hex.stringify(ninao))//还原 tostring默认hex编码，可以指定为utf8console.log(CryptoJS.enc.Hex.parse('6e6968616f6e6968616f').toString(CryptoJS.enc.Utf8)); Base64编码 utf8转base64 大概5/812345678//hex和b64编码之间的转换都要先转换位wordArray，再进行编码let CryptoJS = require('./CryptoJS');let nihao_wordArray = CryptoJS.enc.Utf8.parse('nihaonihao');let nihao_b64 = CryptoJS.enc.Base64.stringify(nihao_wordArray)console.log(nihao_b64);let nihao_wordArray2 = CryptoJS.enc.Base64.parse(nihao_b64);let nihao_hex = CryptoJS.enc.Hex.stringify(nihao_wordArray);console.log(nihao_hex);","link":"/2023/08/01/jsencrypt1/"},{"title":"SQlite数据库","text":"SQlite是一个软件库，实现自给自足，无服务器，零配置、事务性的SQl数据库引擎 是一个进程内的库，使用python，sqlite3模块集成 增删改查123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import sqlite3&quot;&quot;&quot;数据库 test.db 游标 cursorSQL数据库语言， 使用ORM封装后commit提交&quot;&quot;&quot;db = sqlite3.connect('test.db') cursor = db.cursor()cursor.execute(&quot;&quot;&quot; create table if not exists Study( id integer primary key autoincrement, name varchar(10) not null );&quot;&quot;&quot;)# 插入表格# cursor.execute(&quot;&quot;&quot;# insert into Study(id,name) values(1,&quot;hello&quot;)# &quot;&quot;&quot;)# # # 不提交不会插入数据# db.commit()# cursor.execute(&quot;&quot;&quot;# insert into Study(name) values(&quot;hello2&quot;)# &quot;&quot;&quot;)# db.commit()# 删# cursor.execute(&quot;&quot;&quot;# delete from Study where id=1;# &quot;&quot;&quot;)# db.commit()# 改# cursor.execute(&quot;&quot;&quot;# update Study set name='hello3' where id =1;# &quot;&quot;&quot;)# db.commit()# 查results = cursor.execute(&quot;&quot;&quot; select * from Study;&quot;&quot;&quot;)# 返回一个列表包元组print(results.fetchall())cursor.close()db.close()","link":"/2023/10/23/database1/"},{"title":"Python基础(三)","text":"python基础语法 python编译原理 .py文件—编译器—pyCodeObject(内存)/.pyc(磁盘)—虚拟机VM—解释执行—机器码PC 数据类型 str int float bool list dict tuple set str “”12345#字符串 和引号无关str_a='nihao'str_b=&quot;nihao&quot;str_c=&quot;&quot;&quot;nihao&quot;&quot;&quot;print(str_a,str_b,str_c) int float1234int_a=123456float_a=3.1415926print(int_a,float_a)print(type(int_a)) bool123bool_a=Trueprint(type(bool_a),bool_a)print(0==False) list []1234567list_a=[1,2,3,3.14,'nihao','buhao',[5,6,7]]print(list_a)list_a[4]='你好'print(list_a)#删除del list_a[0]print(list_a) dict {key:value}123456dict_a={'name':'xxx','age':100,'port':8000}print(dict_a['name'])dict_a['name']='nihao'print(dict_a)del dict_a['age']print(dict_a) tuple ()1234#类似列表 不能更改 ()tuple_a=('human',99,55,22)print(tuple_a,type(tuple_a))print(tuple_a[0]) set {}123456#集合，过滤重复元素 {}list_b=[1,2,3,5,4,2]set_a=set()for i in list_b: set_a.add(i)print(set_a) 基本语法 break 跳出当前循环 ,continue 继续下一次循环 if else123456username=input(&quot;请输入用户名：&quot;)if username=='nihao': print('登陆成功') breakelse: print('用户名错误,请重新输入') 循环123456789#while死循环-结束条件while True: username=input(&quot;请输入用户名：&quot;) if username=='xjb': print('登陆成功') break else: print('用户名错误,请重新输入')print('程序结束') 123456789#for计次for i in range(10): username=input(&quot;请输入用户名：&quot;) if username=='xjb': print('登陆成功') break else: print('用户名错误,请重新输入')print('程序结束') 循环计数123456789# 循环时候计数enumerateli=['nihao','nihao2','nihao3']for num,item in enumerate(li): print(num+1,item)# 1 nihao# 2 nihao2# 3 nihao3 1234567891011#多个序列打包循环 zipli=[1,2,3,4]li2=[4,5,6,7]li3=[4,5,6,7]for i,j,z in zip(li,li2,li3): print(i,j,z)# 1 4 4# 2 5 5# 3 6 6# 4 7 7 定义函数1234567def add(a,b): print(a+b) # 不写return默认返回None return a+b tmp=add(5,3)print(tmp) 错误处理123456789101112def add(a,b): try: c=a+b print('a+b=',c) # except：可以指定错误类型 except Exception as e: print('发生错误了！',e) finally: #不管正确与否都执行finally print('执行finally')add(1,3)","link":"/2023/08/07/python3/"},{"title":"Redis(一)","text":"Redis安装使用 数据类型 设置自动过期时间 安装使用 安装 brew install redis key-value数据库，nosql非关系数据库 值可以时字符串、哈希、列表、集合、有序集合等 启动 redis-server 启动 redis-cli （-h 127.0.0.1 -p6379） 数据类型字符串类型 set “key” “value” get “key” 不存在返回nil strlen “key” 返回字符串长度 append “key” “追加内容” mset “key” “value” “key” “value” 存入多个数据 mget “key” “key” “key” 列表类型 能够让一个键对应多个值 插入 lpush “key” v1 v2 左端插入，结果为 v2 v1 rpush “key” v1 v2 右端插入，结果为 v1 v2 linsert “key” after v1 v3 中间插入 弹出内容 lpop “key” 删除左边第一个 rpop blpop/brpop key timeout 3 弹出内容-阻塞3秒 获取 lindex key 0 获取key中第0个元素 llen key 获取长度 lrange key start stop 获取从start到结束的元素，start/stop 为数字 哈希类型-和字典类似 hmset name key value key value 插入多个 hmget name key key 查询 hgetall name 获取name的全部key和value hexists name key 是否存在某个字段 hset name key value 修改或添加 hdel name key value 删除字段 一个哈希最多存2^32-1字段，字段为空自动释放内存 集合类型 去重 集合成员是唯一的，会自动去重 sadd key v1 v2 v1 添加 srem key v1 删除 scard key 获取长度 sismenber key v1 判断存在 members key 列出成员 设置自动过期时间 lpush “key” “url1” “url2” expire “key” 20 查看剩余过期时间 TTL “key” exists “spider cache”","link":"/2023/11/09/redis1/"},{"title":"Python基础(四)","text":"类，装饰器，文件操作 类123456789101112131415161718192021222324252627282930#参数叫属性#函数叫方法class Human: # 初始化 def __init__(self,name): # 指针指向self内存地址 # self 放在内存里的一个Human对象 self.name=name print('self-&gt;',self) # 像调用函数一样调用类 def __call__(self, *args, **kwargs): print('call 被调用',args,kwargs) #call 被调用 (1, 2, 3, 'nihao') {'name': 'nihao', 'age': 9} #*args和*kwargs会把值解出来 #call 被调用 1 2 3 nihao name age print('call 被调用',*args,*kwargs) def speak(self): print('Human在讲话'+self.name)#实例化会自动调用init方法h1=Human(&quot;h1&quot;)print(h1.name)h1.speak()h2=Human(&quot;h2&quot;)print(h2.name)h2.speak()#像调用函数一样调用类#前面的数据会被*args接收，后面的两个赋值运算会被当作键值对被**kwargs接收h1(1,2,3,'nihao',name='nihao',age=9) 继承 封装 多态1234567891011121314151617181920212223242526272829303132class Human: def __init__(self,name,age): self.name=name #下划线开头代表私有 self.__age = age print('self-&gt;',self) def speak(self): print('Human在讲话'+self.name) #下划线开头代表私有 def __speak(self): print('Human在讲话'+self.name)#继承class nihao(Human): def __init__(self,name,age): self.nihao=name self.age = age #调用父类__init__方法 super(nihao, self).__init__(name,age) # 多态 重写父类 def speak(self): print('nihao') #在同名子类中调用父类 super(nihao, self).speak()def speak(obj): obj.speak()x1=nihao(&quot;nihao&quot;,2)x2=Human(&quot;nihao2&quot;,1)speak(x1)speak(x2) 12345678910111213141516171819202122#property 把类方法转化为类属性方式获取#classmethod 类方法表示属于类，不属于实例#staticmethod 静态方法 我当前的方法不属于类 是一个单独的函数class nihao: def __init__(self): self.age ='4' @property def _age(self): return self.age #设置属性 @_age.setter def _age(self,value): self.age=value #删除属性 @_age.deleter def _age(self): del self.agen = nihao()del n._agen._age = 5print(n._age) 装饰器12345678910111213141516171819202122#自制装饰器#高阶函数---把函数作为参数#参数是函数 返回内部函数 内部函数里边调用函数（传递参数）import timedef Timer(func): #start=time.time() def inner(*args,**kwargs): #print('传递的参数：',*args,**kwargs) func(*args,**kwargs) # end=time.time() # print('耗费时间：',end-start) return inner@Timerdef test(a,b,c): for i in range(100000): print(1)test(1,2,3) 文件操作12345678910111213141516171819202122&quot;&quot;&quot;w 写入 如果文件不存在我就创建 已经存在就会覆盖r 读取 读取文件内容a 追加 把内容写入文件末尾，不存在就创建，存在就直接写b 二进制 写入视频、音频、图片之类的就需要加这个with自开合 enter exit&quot;&quot;&quot;line=&quot;写入文件&quot;#第一种写法f=open('demo.txt','w',encoding='utf-8')f.write(line)f.close()#不关闭那就会导致内存泄漏（文本打开太多了，内存爆了）#第二种写法for i in range(10): with open('demo.txt','a',encoding='utf-8')as f: f.write(line+'\\n')# 读with open('demo.txt','r',encoding='utf-8')as fr: content=fr.read()print(content)","link":"/2023/08/08/python4/"},{"title":"Python基础(五)","text":"python三器 迭代器和生成器迭代器：标志是使用__iter__方法，返回一个迭代器对象使用__next__方法可以获取下一个值，如果没有下一个值则抛出StopIteration异常 迭代器是一个可以记住遍历的位置的对象，可以为序列、文件、集合、字典、字符串等对象 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束 迭代器只能往前不会后退 迭代器是有状态的，每次迭代都需要重新设置状态 生成器：生成器是一个特殊的迭代器，只能往后不会前进，标志是使用yield关键字，返回一个生成器对象 生成器是一个特殊的函数，只能用于迭代操作，返回迭代器对象 生成器是一个惰性计算的对象，只有在需要迭代的时候才会执行，节省内存 生成器可以不断返回下一个值，直到没有更多的值 装饰器装饰器是一个特殊的函数，它可以让其他函数增加额外的功能，其定义格式如下： 12345def decorator_name(func): def wrapper(*args, **kwargs): # 包装操作 return func(*args, **kwargs) return wrapper 装饰器的作用就是将原函数的内容包装起来，然后返回包装后的函数。 Python中如何实现单例模式 单例模式是一种常见的设计模式，它保证一个类只有一个实例，并提供一个访问它的全局访问点。123456789101112131415161718192021222324252627282930313233343536373839404142# 实现方式一：# 使用装饰器实现 判断是否已经实例化from functools import wrapsfrom typing import Anydef singleton(cls): &quot;&quot;&quot; 单列类装饰器 &quot;&quot;&quot; instance = {} @wraps(cls) def wrapper(*args, **kwargs): if cls not in instance: instance[cls] = cls(*args, **kwargs) return instance[cls] return wrapper@singletonclass Singleton: &quot;&quot;&quot; 单列类 &quot;&quot;&quot; passa = Singleton()b = Singleton()print(id(a), id(b))# 实现方式二：# 使用元类实现单例类(类这样的对象时通过元类来创建，默认元类为type)class Singleton2(type): &quot;&quot;&quot; 单列类元类 &quot;&quot;&quot; def __init__(cls,*arg,**kwargs): print('init') cls.__instance = None super().__init__(*arg,**kwargs) def __call__(cls,*arg,**kwargs): print('call') if cls.__instance is None: cls.__instance = super().__call__(*arg,**kwargs) return cls.__instanceclass President(metaclass=Singleton2): pass a = President()b = President()print(id(a), id(b))","link":"/2023/08/13/python5/"},{"title":"Redis(三)","text":"Python操作redis redis主从复制 redis消息订阅 Python操作redis12345import redispool = redis.ConnectionPool(host='127.0.0.1', port=6379)r = redis.Redis(connection_pool=pool)r.set('name', 'tom')print(r.get('name')) 1234567891011import redispool = redis.ConnectionPool(host='127.0.0.1', port=6379)r = redis.Redis(connection_pool=pool)#事务try: pipe=r.pipeline() pipe.set(&quot;name&quot;,&quot;tom&quot;) # 提交 pipe.execute()except Exception as err: print(err) redis主从复制 生产环境中，单个服务器往往存在崩溃、宕机、网络故障。 提高容错，减轻单个服务器的压力，redis主从复制，能够讲一个服务器的数据，同时同步同步到多个备份服务器中。 操作 复制一份redis.windows.conf 修改文件名为redis.slave.conf 新建slave文件夹 修改文件： port 6389 dir ./slave slaveof 127.0.0.1 6379 启动命令：redis-cli -p 端口号 输入 info replications 可以查看当前主从关系 redis消息订阅1234567import redispool = redis.ConnectionPool(host='127.0.0.1', port=6379)r = redis.Redis(connection_pool=pool)while True: data = input(&quot;&gt;&gt;&gt;&quot;) r.publish('test', data) 1234567891011121314151617181920import redisimport timepool = redis.ConnectionPool(host='127.0.0.1', port=6379)r = redis.Redis(connection_pool=pool)pub=r.pubsub()pub.subscribe('test')pub.parse_response()while True: print(&quot;waiting for message...&quot;) msg = pub.parse_response() print(msg) print(msg[2].decode('utf-8')) time.sleep(3) if msg[2].decode('utf-8') == 'exit': m = pub.unsubscribe('test') print(m) print(&quot; &quot;) break","link":"/2023/11/12/redis3/"},{"title":"Scrapy框架(一)","text":"命令 框架结构 命令 pip3 install scrapy 安装 scrapy startproject study 创建一个名为study的项目 cd study scrapy genspider demo baidu.com 创建爬虫 scrapy crawl demo 运行爬虫 全局命令 scrapy runspider xxx.py 直接运行爬虫文件，无需创建项目 scrapy shell url 打开命令行请求网站 response.header response.xpath('//text') response.css('title::text')[0].get() scrapy fetch url 爬取主址 scrapy veiw url 打开浏览器 scrapy version 版本 项目内命令 scrapy list 列出当前爬虫 scrapy bench 测试scrapy运行速度 框架结构运行流程1.引擎到爬虫里边拿到start_urls，封装成Request请求对象（并没有真的去请求） 2.引擎将Request对象放入调度器队列 （先进先出 ）排队 3.引擎对队列挨个处理请求，交给下载中间件 4.下载中间件去请求Internet ，首先process_request，服务器返回process_response 5.引擎将响应交给爬虫处理parse，处理结果封装成items对象结合parse存储数据 6.引擎将item存储的数据交给管道进行存储","link":"/2023/08/11/scrapy1/"},{"title":"请求库","text":"介绍爬虫使用的请求库，requests，httpx，aiohttp。 requests 请求数据 get post 添加参数 user-agent 请求浏览器数据 date 数据 param 参数 cookie 防盗链 referer 请求超时 timeout=3 结果处理 二进制 文本text json数据 代码123456789101112131415161718192021222324252627282930313233343536import requestsurl = '这写上要爬的url'#添加头 headers = { &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)&quot;\\ &quot;Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.52&quot;,}#添加数据date = { &quot;kw&quot;: s}#添加参数（重新封装）params = { &quot;type&quot;: 20, &quot;interval_id&quot;: &quot;100:90&quot;, &quot;action&quot;: &quot;&quot;, &quot;start&quot;: 0, &quot;limit&quot;: 20,}#发起一个get请求resp = requests.get(url, headers=headers，data=data，params=params)#发起一个post请求resp = requests.post(url, headers=headers，data=data，params=params)#去掉安全验证resp = requests.get(url, verify=False)#设置编码格式resp.encoding = 'utf8'#状态码查看print(resp.status_code)#结果为二进制print(resp.content)#结果为json数据print(resp.json())#请求为文本print(resp.text) 中文解码12345678910import requestsfrom urllib.parse import quote,unquote#解码data='%E4%BD%A0%E5%A5%BD'print(unquote(data))#加码data2='你好'print(quote(data)) session会话 session对象 基于seesion发起的请求都会公用session内的参数。 session可以保存请求时的cookie12345678910import requestssession = requests.session()session.headers={ 'test':'test'}#请求是公用session中的参数，也可以自己添加，如果参数重合以自己的请求为主h1 =session.get('url',headers={'a':'b'})h2 =session.get('url') proxies代理123456import requestsproxies ={ 'http':'http://127.0.0.1:7890', 'https':'http://127.0.0.1:7890',}resp = requests.get('url',proxies=proxies) httpx 支持http2.0兼容http1.0 处理http1.0和requests一样的用法 12345import httpxheaders={}proies={}html = httpx.get('url',headers=headers,proies=proies)print(html.text) 处理http2.0和session用法相似 client=httpx.Client(http2.0=True,proxies=proxies) 异步请求 12345678910111213141516171819202122#第一中写法async def spider(num): print('run',num) client=httpx.AsyncClient(http2=True) html = await client.get('url') print(html) await client.aclose()#第二中写法async def spider(num): print('run',num) async with httpx.AsyncClient(http2=True) as client: html = await client.get('url') print(html)#建立队列async def main(): await asyncio.gather(*[spider(1),spider(2),spider(3)])#启动 if __name__ == '__main__': asyncio.run(main()) aiohttp 异步请求 123456789101112131415import aiohttpimport asyncioheaders={}#只支持http代理proxy='http://localhost:7890'async def main(): async with aiohttp.ClientSession(headers=headers) as client: html = await client.get('url') print(await html.text()) html.close()#使用loop启动程序loop = asyncio.get_event_loop()loop.run_until_complete(main()) 优缺点和区别 requests 同步 httpx 同步异步 aiohttp 只有异步","link":"/2023/08/01/spider1/"},{"title":"免费代理处理","text":"免费代理测试验证ip可用性 1.通过爬虫爬取免费代理ip和端口号2.对每个ip进行可用性验证，请求’https://httpbin.org/ip'判断状态码 12345678910111213141516171819#封装proxyproxies = { 'http': f'http://{IP}:{PORT}', 'https': f'http://{IP}:{PORT}',}url = 'https://httpbin.org/ip' headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'\\ 'AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36 Edg/109.0.1518.78' } try: html = requests.get(url, proxies=proxies, headers=headers, timeout=3) print('状态码：', html.status_code) print('IP：', html.text) #可用的代理放入列表种 proxies_list.append(proxies) except: print('代理不可用')","link":"/2023/08/01/spider2/"},{"title":"Redis(二)","text":"事务 订阅模式 持久化RDB，AOF 事务 启动事务 multi 放弃事务 discard 提交事务 exec 监控键 watch（如果在事务exec之前修改了键，则取消事务） redis和sql事务的区别 没有回滚 语法错误，exec不会执行 原子性 执行过程中出错，后续命令还是会继续执行 打破原子性 redis发布订阅模式PubSub 经典消息传递机制，即频道把数据发送出去，订阅了该频道的用户受到消息 subscribe 用于订阅 publish 用于发布 pubsub channels 用于展示频道 unsubscribe 用于退订 当频道无订阅时会自动销毁，而且订阅消息不支持持久化 持久化 redis数据存储在内存中，重启后所有数据会被清空 为了保存数据，redis提供两种持久化类型RDB和AOF RDB默认自动保存也可以手动写入 保存文件名dump.rdb sava 同步写入，会阻塞线程 bgsave 异步方式，fork子进程处理 数据恢复：config get dir 修改 /usr/local/etc/redis.conf save 900 1 表示900秒内至少有1个key变化就自动保存，取消自动保存注释掉即可 stop-writes-on-bgsave-error:当启动RDB且最后一次保存数据失败，redis是否停止接受数据 rdbcompression：磁盘快照是否进行压缩 rdbchecksum：是否进行CRC64算法进行数据校验 dbfilename：设置快照文件名 dir：设置文件存放路径，是一个目录不是一个文件名 AOF记录写入命令的追加模式，每个写入命令都会被记录 修改redis.conf 文件 config set appendonly yes appendfsync always：每个写入都fsync appendfsync everysec：每一秒一次fsync appendfsync no：用于fsync，由系统时间决定 auto-aof-rewrite-percentage 100 当前AOF文件大小和上一次重写时AOF文件大小的比值 auto-aof-rewrite-min-size 64mb 文件最小体积 原理：redis先把写入命令写入到缓冲区，缓冲区的数据被fsync()之后刷到磁盘，redis关闭时自动调用一次fsync bgrewriteaof：重写会创建一个当前AOF文件的体积优化版本 如果只配置AOF，重启时加载AOF文件恢复数据 如果同时配置了RDB和AOF，启动时只加载AOF文件恢复数据 如果只配置RDB启动时加载dump文件恢复数据","link":"/2023/11/09/redis2/"},{"title":"解析库","text":"使用bs4，xpath，re进行数据解析和提取。 bs4 BeautifulSoup 支持从HTML或XML文件中提取数据的python库 Beautiful Soup自动将输入文档转换为Unicode编码，输出文档转换为utf-8编码。 select方法需要使用css选择器 css选择器 class 使用·代替 id使用#代替 find方法是找到第一个满足条件的标签后就立即返回，只返回一个元素。 find_all方法是把所有满足条件的标签都选到，然后返回回去。 12345678910111213141516171819202122232425262728293031323334import requestsfrom bs4 import BeautifulSoup# 从bs对象中查找数据# find(标签，属性=值)# find_all(标签，属性-值（如果遇到python关键字用class_或者一个字典代替）)url = &quot;https://www.umei.cc/bizhitupian/diannaobizhi/&quot;resp = requests.get(url)resp.encoding = 'utf-8'#把爬下来的网站给bs并指定html解析# find(标签，属性=值)# find_all(标签，属性-值（如果遇到python关键字用class_或者一个字典代替）)main_page = BeautifulSoup(resp.text, &quot;html.parser&quot;)#main_page = BeautifulSoup(resp.text, &quot;lxml&quot;)a_list = main_page.find(&quot;div&quot;, class_=&quot;listlbc_cont_l&quot;).find_all(&quot;a&quot;)a_list = main_page.find(&quot;div&quot;, class_=&quot;item_list infinite_scroll&quot;).find_all(&quot;a&quot;)for a in a_list: href = a.get('href') print(href)#使用css选择器 调用select方法b_list = main_page.select('div.img div.btns a')#第一种写法for b in b_list: href = b.get('href') print(href)#第二种写法for b in b_list: print(b['href']) xpath //div找全部的div /div找第一个div @＋属性 严格匹配 鼠标右键复制完整xpath再元素控制台调试直到合适 12345678910111213141516import requestsfrom lxml import etreeurl = &quot;https://www.umei.cc/bizhitupian/diannaobizhi/&quot;resp = requests.get(url)resp.encoding = 'utf-8'soup = etree.HTML(resp.text)#text() @href @属性results=soup.xpath('/html/body/div[5]/div[1]/div[2]/div[1]/div/div/div[1]/div/a/img/@alt')results=soup.xpath('/html/body/div[5]/div[1]/div[2]/div[1]/div/div/div[1]/div/a/img/text()')for i in results: print(i) re re在爬虫种主要处理复杂的数据 使用正则设置一个匹配规则 得到一个list，使用group方法取出 1234567import re# （？P&lt;分组名字&gt;正则）可以单独从正则匹配的内容中进一步提取内容#re.S使.也可以匹配换行符obj = re.compile(r&quot;&lt;div class='.*?'&gt;&lt;span id='.*?'&gt;(?P&lt;分组&gt;.*?)&lt;/span&gt;&lt;div&gt;&quot;, re.S)result = obj.finditer(resp.text)for it in result: print(it.group(&quot;分组&quot;)) 总结爬虫解析页面主要使用bs4和xpath，如果遇到较为复杂的页面使用re即可。","link":"/2023/08/01/spider3/"},{"title":"Python基础(一)","text":"多线程，多进程，进程间数据通信 Python多线程 一个进程至少包含一个主线程（守护线程），也可以包含许多子线程（非守护线程）。 Python程序为了线程安全，每一个进程设有一个全局解释器锁，不同的操作系统对线程的占用时间时有限的，当Python程序执行时每一个线程都需要排队去申请解锁，在有限的占用时间后还锁，这就造成Python多线程程序同一时刻只能有一个线程在运行，但由于操作系统切换线程速度太快，就看似是一种并发的状态，但其实是伪并发。 Python要实现真并发，可以使用多进程。 对于爬虫来说主要在等待I/O的请求时间，所以多线程完全可以使用。 threading，多线程包 基础使用 设置线程 开启线程 其他：设置守护线程，查看线程状态 12345678910111213141516171819202122232425262728293031323334import threadingdef print1(): for i in range(100): print(&quot;1&quot;)def print2(): for i in range(100): print(&quot;2&quot;)#target=函数名，args=传入参数x1=threading.Thread(target=print1,args=())x2=threading.Thread(target=print2,args=())#设置为守护线程# x1.daemon=True# x2.daemon=True#开启线程#主线程接受不影响非守护线程x1.start()x2.start()#判断是否为守护线程# print('x1',x1.daemon)# print('x2',x2.daemon)print(&quot;主线程结束&quot;)#查看线程状态#print(threading.current_thread())#查理主线程状态#print(threading.main_thread()) 上锁 使用 threading.Lock() 进行上锁等待，上文说到在有限的的时间内会将锁还回去（但保留运行数据，再次轮到后继续进行），任务开始使用 .acquire获取锁，可以强制等待任务执行完毕后使用 .release 再还锁。 .join()的作用，主线程任务结束后进入阻塞状态，会一直等待调用了join子线程任务执行结束后主线程才会终止。 用时间换安全 使用一个循环加一减一的例子说明 1234567891011121314151617181920212223242526272829303132import threadingLock=threading.Lock()num = 0def print1(): global num for i in range(100): Lock.acquire() num+=1 Lock.release()def print2(): global num for i in range(100): Lock.acquire() num-=1 Lock.release()#target=函数名，args=传入参数x1=threading.Thread(target=print1)x2=threading.Thread(target=print2)x1.start()x2.start()x1.join()x2.join()print(num) Python多进程 multiprocessing包 基本使用 设置线程–启动线程–给每个线程添加等待 12345678910111213141516171819202122import multiprocessingimport time# 查看电脑线程数# print(multiprocessing.cpu_count())def num(name): print('run process{}'.format(name)) time.sleep(3) print('end process{}'.format(name))if __name__ == '__main__': # 设置线程--启动线程--给每个线程添加等待 processes=[] for i in range(5): p1=multiprocessing.Process(target=num,args=(i,)) processes.append(p1) p1.start() for i in processes: i.join() print('进程结束') 进程池构建 在一开始创建一个进程池，那个空闲用那个，用完自动还回去 123456789101112if __name__ == '__main__'： Pools=multiprocessing.Pool(3) for i in range(9): #Pools.apply(func=num,args=(i,))#apply同步 Pools.apply_async(func=num,args=(i,))#apply_async异步(主要使用异步) Pools.close()#使用结束后关闭全部进程池 Pools.join() print('进程结束') 多进程数据共享 原理：使用代理 Manager 使用代理复制一份数据进行同步更改 不是共享内存 123456789101112131415161718192021222324252627282930import multiprocessingimport timedef push(li): print(id(li)) while True: print(&quot;存数据&quot;) li.append('a') time.sleep(1)def pop(li): print(id(li)) while True: if li: print('拿数据'+str(li.pop())) time.sleep(1)def main(): #设置代理Manager（列表） li = multiprocessing.Manager().list() print(id(li)) p1 = multiprocessing.Process(target=push,args=(li,)) p2 = multiprocessing.Process(target=pop, args=(li,)) p1.start() p2.start() p1.join() p2.join()if __name__ == '__main__': main()","link":"/2023/08/06/python1/"}],"tags":[{"name":"安卓逆向","slug":"安卓逆向","link":"/tags/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"刷机","slug":"刷机","link":"/tags/%E5%88%B7%E6%9C%BA/"},{"name":"Js逆向","slug":"Js逆向","link":"/tags/Js%E9%80%86%E5%90%91/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Jscipher","slug":"Jscipher","link":"/tags/Jscipher/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"TinyDB","slug":"TinyDB","link":"/tags/TinyDB/"},{"name":"Mongodb","slug":"Mongodb","link":"/tags/Mongodb/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"aiohttp","slug":"aiohttp","link":"/tags/aiohttp/"},{"name":"MySql","slug":"MySql","link":"/tags/MySql/"},{"name":"cipher","slug":"cipher","link":"/tags/cipher/"},{"name":"SQlite","slug":"SQlite","link":"/tags/SQlite/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"}],"categories":[{"name":"3.Android逆向","slug":"3-Android逆向","link":"/categories/3-Android%E9%80%86%E5%90%91/"},{"name":"1.Android基础","slug":"3-Android逆向/1-Android基础","link":"/categories/3-Android%E9%80%86%E5%90%91/1-Android%E5%9F%BA%E7%A1%80/"},{"name":"2.Js逆向","slug":"2-Js逆向","link":"/categories/2-Js%E9%80%86%E5%90%91/"},{"name":"4.数据库","slug":"4-数据库","link":"/categories/4-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"1.爬虫","slug":"1-爬虫","link":"/categories/1-%E7%88%AC%E8%99%AB/"},{"name":"1.密码学","slug":"2-Js逆向/1-密码学","link":"/categories/2-Js%E9%80%86%E5%90%91/1-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"5.编程基础","slug":"5-编程基础","link":"/categories/5-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"4.Redis","slug":"4-数据库/4-Redis","link":"/categories/4-%E6%95%B0%E6%8D%AE%E5%BA%93/4-Redis/"},{"name":"1.轻量级数据库","slug":"4-数据库/1-轻量级数据库","link":"/categories/4-%E6%95%B0%E6%8D%AE%E5%BA%93/1-%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"3.Mongodb","slug":"4-数据库/3-Mongodb","link":"/categories/4-%E6%95%B0%E6%8D%AE%E5%BA%93/3-Mongodb/"},{"name":"1.爬虫基础","slug":"1-爬虫/1-爬虫基础","link":"/categories/1-%E7%88%AC%E8%99%AB/1-%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"},{"name":"2.MySql","slug":"4-数据库/2-MySql","link":"/categories/4-%E6%95%B0%E6%8D%AE%E5%BA%93/2-MySql/"},{"name":"1.Python","slug":"5-编程基础/1-Python","link":"/categories/5-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/1-Python/"},{"name":"2.Scrapy","slug":"1-爬虫/2-Scrapy","link":"/categories/1-%E7%88%AC%E8%99%AB/2-Scrapy/"}],"pages":[{"title":"","text":"Title *{ margin: 0; padding: 0; font-family: \"Poppins\", sans-serif; box-sizing: border-box; } .mycontainer .mycard .face{ position: absolute; top: 0; left: 0; width: 100%; height: 100%; transition: 0.5s; } .mycontainer .mycard .face.face1{ background: transparent; display: flex; justify-content: center; align-items: center; z-index: 1; transform-origin: bottom; } .mycontainer .mycard .face.face1 img{ max-width: 150px; } .mycontainer .mycard .face.face1 h3{ margin: 10px 0 0; color: #fff; text-align: center; font-size: 1.5em; } .mycontainer .mycard .face.face2 a{ color: rgb(0, 191, 255); text-align: center; font-size: 1.5em; } 1-爬虫基础 2-Scrapy 3-验证码处理 4-抓包工具 1-密码学 2-AST还原 3-Js混淆 4-Js补环境 1-轻量级数据库 1-轻量级数据库 2-MySql 3-Mongodb 4-Redis","link":"/classification/index.html"},{"title":"","text":"/* *{ margin: 0; padding: 0; font-family: \"Poppins\", sans-serif; box-sizing: border-box; } */ mybody{ height: 500px; display: flex; justify-content: center; background-color: transparents } .mycontainer{ width: 700px; height: 520px; position: relative; /* display: flex; */ justify-content: space-between; /* 开启网格布局 */ display: grid; grid-template-rows: 300px 300px ; grid-template-columns: 300px 300px ; } .mycontainer .mycard{ position: relative; width: 300px; height: 200px; } /* .mycontainer .mycard .face{ position: absolute; top: 0; left: 0; width: 100%; height: 100%; transition: 0.5s; } */ /* .mycontainer .mycard .face.face1{ background: #333; display: flex; justify-content: center; align-items: center; z-index: 1; transform-origin: bottom; } */ /* .mycontainer .mycard .face.face1 h3{ margin: 10px 0 0; color: #fff; text-align: center; font-size: 1.5em; } */ .mycontainer .mycard:hover .face.face1{ transform: translateY(-100%) rotateX(90deg); background: transparent; } .mycontainer .mycard .face.face2{ background: transparent; display: flex; justify-content: center; align-items: center; padding: 20px; transform-origin: top; transform: translateY(100%) rotateX(90deg); } .mycontainer .mycard:hover .face.face2{ transform: translateY(0%) rotateX(0deg); }","link":"/classification/style.css"},{"title":"","text":"Title :root { --fontColor: white; --one1: #c39edc; --one2: white; --two1: #3dbbc7; --two2: white; --three1: #21bbfe; --three2: white; --four1: #122c9e; --four2: white; --levelShadow: #22325480; } .levels { position: relative; top: 50%; left: 50%; margin-left: -140px; margin-top: 100px; transform-style: preserve-3d; user-select: none; } .levels .level { width: 400px; height: 210px; border-radius: 12px; color: var(--fontColor); cursor: pointer; transition: all 0.4s ease; transform: rotateX(37deg) rotateY(-20deg) rotate(15deg); opacity: 0.9; margin-top: -70px; } .levels .level.one { background: linear-gradient(135deg, var(--one1), var(--one2)); box-shadow: 20px 20px 60px var(--levelShadow), 1px 1px 0px 1px var(--one2); z-index: 4; } .levels .level.two { background: linear-gradient(135deg, var(--two1), var(--two2)); box-shadow: 20px 20px 60px var(--levelShadow), 1px 1px 0px 1px var(--two2); z-index: 3; } .levels .level.three { background-image: linear-gradient(135deg, var(--three1), var(--three2)); box-shadow: 20px 20px 60px var(--levelShadow), 1px 1px 0px 1px var(--three2); z-index: 2; } .levels .level.four { background-image: linear-gradient(135deg, var(--four1), var(--four2)); box-shadow: 20px 20px 60px var(--levelShadow), 1px 1px 0px 1px var(--four2); z-index: 1; } .levels .level .title { color: white; position: absolute; top: 80px; right: 80px; font-size: 40px; font-weight: bold; } .levels .level .content { position: absolute; font-weight: 700; bottom: 15px; left: 15px; font-size: 16px; } .levels .level:hover { transform: rotateX(37deg) rotateY(-20deg) rotate(18deg) translate(-25px, 50px); opacity: 0.6; } .levels .level:hover:after { transform: translateX(100%); transition: all 2s ease-in-out; } .levels .level::after { content: ''; position: absolute; top: 0px; left: 0; width: 100%; height: 100%; transform: translateX(-100%); background: linear-gradient(60deg, rgba(255,255,255,0) 20%, rgba(255,255,255,0.1), rgba(255,255,255,0) 80%); } Python 爬虫开发 Java Android逆向 后端开发 JavaScript Js逆向 Html+Css 前端开发","link":"/codebase/index.html"},{"title":"","text":"碎碎念 h2{ text-align: center; } p{ text-align: center; } 碎碎念 一路有陌路人陪你这一生","link":"/about/index.html"}]}