{"posts":[{"title":"adb原理及命令","text":"介绍abd原理及adb常用操作命令。 原理 adb构成 client端，在电脑，负责发送adb命令 daemon守护进程adbd，在手机端，负责接受和执行adb命令 server端，在电脑上，负责管理client和daemon之间的通信 adb工作原理 client-&gt;server-&gt;daemon(执行返回结果)-&gt;server-&gt;client 命令 adb help adb version adb start-server 启动server adb kill-server 停止server adb devices adb install xxx.apk 安装应用 adb install -r xxx.apk 覆盖安装 adb uninstall 包名 adb push xxx xxx 推送文件到手机 adb push xxx.apk ./sdcard/yyy adb pull xxx xxx 拉取手机文件到电脑上并改名 adb pull xxx 拉取整个文件夹 adb shell 进入到手机linux控制台 去除wife感叹号 adb shell settings put global captive_portal_mode 0 adb -s 设备名 shell（多个设备是使用） 超级adb才能用 adb root adb remount 挂载分区为可读写 adb disable-verity 关闭分区检测功能","link":"/2023/08/01/android1/"},{"title":"刷机","text":"介绍刷机基础，使用设备GooglePiexlXL 代号(marlin)，安卓版本 10.0。 1.刷机包分类 线刷包 后续编译的安卓系统都使用线刷包 刷机包组成 flash-all.bat内容：使用fastboot刷入bl radio image 卡刷包 2.刷机过程 线刷 进入bootloader双击flash-all.bat运行 进入bootloader使用fastboot命令进行刷机 卡刷 进入recovery使用手机sd卡内保存的卡刷包刷机 进入recovery使用adb sideload 推送刷机包 3.刷机命令（常用） adb adb devices 检测设备是否连接上电脑 adb reboot 重启 adb reboot recovery/bootloader 重启进入recovery/bootloader adb sideload &lt;刷机包地址&gt; 在recovery模式启用adb调试推送刷机包 fastboot fastboot devices 检测设备是否连接上电脑 fastboot reboot 重启 fastboot reboot recovery 重启进入recovery fastboot flash &lt;分区&gt; &lt;分区对应刷机包&gt; 刷入刷机包命令","link":"/2023/08/01/android2/"},{"title":"查看包名","text":"查看安卓包名的方法 反编译查看清单文件 通过shell命令获取包名和入口类名 adb shell dumpsys window | grep mFocusedApp (mac下这个可以看到) adb shell dumpsys window | grep mCorrentFocus adb shell dumpsys window windows |grep mFocusedApp windows环境下将grep替换为findstr 查看入口类 adb shell dumpsys package 包名 | grep LAUNCHER 打印进程信息 Android8之前 ps Android8之后 ps -A pm list packages /data/data /data/app","link":"/2023/08/07/android3/"},{"title":"查看日志","text":"logcat命令，As查看日志 logcat命令 adb logcat -help 查看帮助 adb logcat 常规显示 adb logcat -c 清除日志 adb logcat -g 显示缓冲区大小 adb logcat -G 256M 修改缓冲区大小 adb logcat -v time 设置不同的显示格式 adb logcat -v color 带颜色的显示 过滤方法 根据tag过滤日志 adb logcat -s xxx 根据pid过滤日志 获取进程pid ps -A｜grep 包名 adb logcat ｜findstr(win, mac(grep)) pid 根据自定义标签过滤 adb logcat｜findstr 自定义标签 AS中查看Logcat package:mine 用当前运行的应用包名进行过滤 level:DEBUG 显示调试级别以上信息 tag:xxx 过滤xxx的标签 -tag:xxx xxx的标签除外 message:xxx 过滤包含xxx关键字的信息","link":"/2023/08/13/android4/"},{"title":"安卓常见目录","text":"安卓常见目录 /data/data 存放用户app数据的目录，每个app都有自己的目录，以包名命名，这是一个私有目录，app只能访问各自的目录，除非app有root权限，该目录下的文件要pull到电脑上来，通常先拷贝到sdcard目录 /data/app 用户安装的app存放在这个目录下，里面还有当前版本的base.apk安装包 /data/local/tmp 临时目录，权限很大 /system/app 目录：存放系统自带的app /system/lib 存放app用到的系统so文件 /system/lib64 存放app用到的系统so文件 /system/bin 存放shell命令 /system/framework 安卓系统所用到框架，一些jar文件 sd卡目录 不管手机里有没有储存卡都有这个目录，app操作sd卡目录需要申请权限，不同系统版本要求还不同 软连接 /sdcard /storage/self/primary /mnt/sdcard /storage/emulated/0","link":"/2023/10/23/android5/"},{"title":"Apk结构","text":"安卓版本和安卓应用结构 apk在进行反编译后 use-sdk android minSdkVersion='xx'xx表示最小支持sdk版本 android10 —sdk 29 android 13 —sdk 33 Android历史版本 4.4 以前使用dalvik/dvm虚拟机，libdvm.so 4.4 使用dvm和art虚拟机，可以切换libdvm.so、libart.so 5.0 之后采用art虚拟机，安卓系统开始分32位和64位 apk基本结构 assets 资源文件（图片、音频、数据库、网页、配置文件、dll、so等） res 资源文件（编译后到布局文件、程序图标） lib 各种平台下使用的对应的so文件 META-INF 签名文件 resources.arsc 资源加密（语言包） AndroidManifest.xml 清单文件（图标、界面、权限、代码执行入口） classes.dex java源代码需要反编译","link":"/2023/10/24/android6/"},{"title":"抓包工具(一)","text":"介绍抓包工具Charles的安装和使用，Proxifie的设置。 抓包工具分类 全局抓包工具 代理抓包 Charles Fiddler BurpSuite（渗透用） 手机抓包 tcpdump HttpCanary（vpn） 流量转发工具 Proxifier socksdroid postern lamda r0Capture eCapture 网卡抓包 WireShark Charles 为了应对网页跳转时，打开一个新网页，使用开发者工具没办法抓包。 为了应对网页跳转时，打开一个新网页，开发者工具会把前面的响应丢掉。 Charles注册码 ：https://zzzmode.com/mytools/charles/ 配置Proxy Settings 解密SSL -&gt; 安装证书 抓取https数据包 关闭Charles原因是Proxifie的Rules默认将全部流量转发到127.0.0.1:8889端口，即使关闭了也不会改变，可以将Default的Action改为Direct直连。 抓取Python程序发出的数据包开启Charles代理后对Python爬虫程序发出的数据包进行抓取需要添加代理 代理地址为Charles设置的地址和端口 123456789101112131415import requests#消除警告import urllib3urllib3.disable_warnings()url = 'https://www.eloancn.com/'headers = {}# 设置代理proxies={'https':'http://127.0.0.1:8888'}resp = requests.get(url=url,headers=headers,proxies=proxies,verify=False)resp.encoding='utf-8'print(resp.text) Proxifie Proxifier是socks5客户端，可以让不支持通过代理服务器工作的网络程序能通过HTTPS或SOCKS代理或代理链,将pc端端流量强制转发到代理服务器上。 开启Charles的SOCKS代理服务器，根据Proxifie的规则，将数据包先转发到127.0.0.1:8889端口，在发送到Charles由其发送出去。","link":"/2023/08/01/charles/"},{"title":"抓包工具(二)","text":"charles使用 修改请求和响应，替换文件 charles 修改请求和响应 对网站起始进行Focus方便观察 下断点，选择要修改的请求链接下断点 charles会对该链接的请求和响应进行拦截 Edit Request 修改请求内容 Edit Response 修改响应内容 修改完后Execute执行 charles 修改文件 对需要修改的文件选择map local 添加Map to 中的本地替换文件","link":"/2023/08/28/charles1/"},{"title":"Css基础","text":"改变页面样式 使用Canvas绘画 改变页面样式12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;这是标题&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;url&quot;&gt; &lt;style&gt; &lt;!--标签选择器：修改input样式--&gt; input{ 属性名:值; 属性名:值; } &lt;!--类选择器--&gt; .textEdit{ 属性名:值; 属性名:值; } .box{ 属性名:值; 属性名:值; } &lt;!--id选择器--&gt; #id{ 属性名:值; 属性名:值; } &lt;!--通配符选择器--&gt; *{ 属性名:值; 属性名:值; } &lt;/style&gt; &lt;/head&gt;&lt;body&gt; username &lt;input class=&quot;textEdit box&quot; type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;提示输入&quot; /&gt;&lt;br /&gt; username2 &lt;input class=&quot;textEdit&quot; type=&quot;text&quot; name=&quot;username2&quot; placeholder=&quot;提示输入&quot; /&gt;&lt;br /&gt; username3 &lt;input id=&quot;id&quot; type=&quot;text&quot; name=&quot;username3&quot; placeholder=&quot;提示输入&quot; /&gt;&lt;br /&gt; username4 &lt;input id=&quot;id&quot; type=&quot;text&quot; name=&quot;username4&quot; placeholder=&quot;提示输入&quot; style=&quot;bored : red 1px solid&quot; /&gt;&lt;br /&gt;&lt;/body&gt;&lt;/html&gt; 使用Canvas绘画，处理验证码图片位置混淆123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;这是标题&lt;/title&gt;&lt;/head&gt;&lt;!-- 使用canvas画布重绘制图片 设置画布大小 边框--&gt;&lt;canvas id=&quot;myCanvas&quot; width=&quot;260&quot; height=&quot;116&quot; style=&quot;border: red 1px solid;&quot; &gt;&lt;/canvas&gt;&lt;!-- 通过js代码导入图片 --&gt;&lt;script&gt; let img = new Image(); img.src = &quot;./css图片.png&quot;; // 绑定事件 图片加载完成时运行 img.onload = function(){ console.log(&quot;图片加载完成&quot;); let cv = document.getElementById(&quot;myCanvas&quot;); // 2d 二维图片 let ctx = cv.getContext('2d'); // drawImage(ImgUrl,pxX（网站混淆的坐标）,pxY,styleX（原本设定的样式）,styleY,绘画横坐标,绘画纵坐标,styleX,styleY) // 手动添加坐标，后续使用for处理坐标 ctx.drawImage(img,234,25,13,25,0,0,13,25); ctx.drawImage(img,143,25,13,25,13,0,13,25); ctx.drawImage(img,65,75,13,25,26,0,13,25); console.log(cv); }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2023/10/25/css1/"},{"title":"SQlite数据库","text":"SQlite是一个软件库，实现自给自足，无服务器，零配置、事务性的SQl数据库引擎 是一个进程内的库，使用python，sqlite3模块集成 增删改查123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import sqlite3&quot;&quot;&quot;数据库 test.db 游标 cursorSQL数据库语言， 使用ORM封装后commit提交&quot;&quot;&quot;db = sqlite3.connect('test.db') cursor = db.cursor()cursor.execute(&quot;&quot;&quot; create table if not exists Study( id integer primary key autoincrement, name varchar(10) not null );&quot;&quot;&quot;)# 插入表格# cursor.execute(&quot;&quot;&quot;# insert into Study(id,name) values(1,&quot;hello&quot;)# &quot;&quot;&quot;)# # # 不提交不会插入数据# db.commit()# cursor.execute(&quot;&quot;&quot;# insert into Study(name) values(&quot;hello2&quot;)# &quot;&quot;&quot;)# db.commit()# 删# cursor.execute(&quot;&quot;&quot;# delete from Study where id=1;# &quot;&quot;&quot;)# db.commit()# 改# cursor.execute(&quot;&quot;&quot;# update Study set name='hello3' where id =1;# &quot;&quot;&quot;)# db.commit()# 查results = cursor.execute(&quot;&quot;&quot; select * from Study;&quot;&quot;&quot;)# 返回一个列表包元组print(results.fetchall())cursor.close()db.close()","link":"/2023/10/23/database1/"},{"title":"TinyDB数据库","text":"面向文档，类似MongoDB 表示为字典的任何文档存入 纯python 小型数据库 增删改查1234567891011121314151617181920212223242526272829303132333435from tinydb import TinyDB,Query db = TinyDB(&quot;tiny.db&quot;)query= Query()# 增# db.insert({&quot;name&quot;: &quot;a&quot;, &quot;value&quot;:&quot;100&quot;})# db.insert_multiple(# [{&quot;name&quot;: &quot;b&quot;, &quot;value&quot;:&quot;123&quot;},# {&quot;name&quot;: &quot;c&quot;, &quot;value&quot;:&quot;qew&quot;}]# )# 输出内容# print(db.all())# for line in db:# print(line)# 搜索 query.name==query['name']# result = db.search(query.name==&quot;c&quot;)# print(result)# 更新db.insert_multiple( [{&quot;name&quot;: &quot;b&quot;, &quot;value&quot;:&quot;123&quot;}, {&quot;name&quot;: &quot;c&quot;, &quot;value&quot;:&quot;qew&quot;}])# 把name为b的value改为qewdb.update({&quot;value&quot;: &quot;qew&quot;},query.name==&quot;b&quot;)print(db.all())# 删除db.remove(query.name==&quot;c&quot;)# 全删db.truncate()print(db.all())","link":"/2023/10/23/database2/"},{"title":"Debugger处理","text":"debugger的创建 绕过debugger debugger的创建123456789101112131415161718192021//直接执行debugger;//虚拟机执行eval(&quot;debugger;&quot;);//判断前后时间大于100ms时debuggereval(&quot;(function() {var a = new Date(); debugger; return new Date()-a&gt;100;}())&quot;)//利用Function构造函数创建debuggerFunction(&quot;debugger;&quot;).call();Function(&quot;debugger;&quot;).apply();Function(&quot;debugger;&quot;).bind()();Function.constructor(&quot;debugger;&quot;).call();// 任意函数对象// funcObj.constructor(&quot;debugger;&quot;).call();//使用setInterval重复调用一个函数或执行一个代码片段，在每次调用之间具有固定的时间间隔。// 返回一个 interval ID，该 ID 唯一地标识时间间隔，因此你可以稍后通过调用 clearInterval() 来移除定时器。setInterval(function(){debugger;},1000); 绕过debugger 1 在debugger处下条件断点，永远处于false 2 使用浏览器Overrides功能，修改替换JS代码，使用Fiddler自动响应 3 JsHook1234567891011121314151617181920212223242526272829//hook FuncitonFunction.prototype._constructor = Function.prototype.constructor;Function.prototype.constructor = function() { if(arguments &amp;&amp; typeof arguments[0]=='string'){ if(&quot;debugger&quot; === arguments[0]){ return; } } return Function.prototype._constructor.apply(this,arguments);}//hook evalvar _eval = eval;eval = function(arguments) { if(arguments.indexOf('debugger') != -1) { return function() {} } return _eval(arguments);}//hook setIntervalsetInterval =function(){}//制空setInterval函数_setInterval = setInterval;setInterval = function(a,b) { if(a.toString().indexOf('debugger') != -1){ return null; } return _setInterval(a,b);}","link":"/2024/01/16/debugger/"},{"title":"使用Fiddler转发数据","text":"Fiddler抓包工具转发数据 Fiddler Script 使用Fiddler进行自动转发 适用window环境下的Fiddler软件进行转发数据包 在本地开启接受数据的端口 12345678910111213141516171819202122import uvicornfrom fastapi import FastAPIfrom typing import Dict app = FastAPI() # post发送@app.post(&quot;/sendData&quot;)async def post_info1(request_data: Dict): print(request_data) return 'ok' @app.get(&quot;/&quot;)async def get_infos(): print(&quot;test&quot;) return 'ok' if __name__ == '__main__': # host='127.0.0.1'本机地址 # host ='0.0.0.0' 局域网下其他机器可引访问本机 uvicorn.run(app=app, host='0.0.0.0', port=8000) 改写Fiddler script 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960static function OnBeforeResponse(oSession: Session) { if (m_Hide304s &amp;&amp; oSession.responseCode == 304) { oSession[&quot;ui-hide&quot;] = &quot;true&quot;; } //Contains 过滤包含xx网站的数据 if (oSession.fullUrl.Contains(&quot;fangdi.com.cn/service/index/getWriteDict.action&quot;)) { var html = oSession.GetResponseBodyAsString() if(html.Contains(&quot;listWriteDict&quot;)){ //数据统计开始：把内容通过ajax http发送其它地方 var _xhr = new ActiveXObject('Microsoft.XMLHTTP'); var url = 'http://192.168.3.9:8000/sendData'; //发送的数据参数 var jsonString = oSession.GetResponseBodyAsString(); var requestHeaders = oSession.oRequest.headers.ToString(); var responseHeaders=oSession.oResponse.headers.ToString(); var str='{}';//构造自己的JSON http请求的信息及返回的结果 var data = Fiddler.WebFormats.JSON.JsonDecode(str); data.JSONObject[&quot;requestHeaders&quot;]=requestHeaders; data.JSONObject[&quot;responseHeaders&quot;]=responseHeaders; data.JSONObject[&quot;responseBody&quot;] = jsonString; data.JSONObject[&quot;url&quot;] = oSession.fullUrl; data.JSONObject[&quot;response_code&quot;] = oSession.responseCode; if(oSession.oRequest.headers.Exists(&quot;Cookie&quot;)){ data.JSONObject[&quot;requestCookie&quot;] = oSession.oRequest.headers['Cookie']; }else{ data.JSONObject[&quot;requestCookie&quot;] = 'request no Cookie'; }; if(oSession.oResponse.headers.Exists(&quot;Cookie&quot;)){ data.JSONObject[&quot;responseCookie&quot;] = oSession.oResponse.headers['Cookie']; }else{ data.JSONObject[&quot;responseCookie&quot;] = 'response no Cookie'; }; jsonString = Fiddler.WebFormats.JSON.JsonEncode(data.JSONObject) //FiddlerObject.log(jsonString); _xhr.onreadystatechange=function(){ if (_xhr.readyState==4){ FiddlerObject.log(_xhr.responseText); } }; _xhr.open('POST', url, true); _xhr.send(jsonString); //----数据统计结束----- }else{ //弹窗报错 FiddlerObject.alert(&quot;抓取出错！&quot;); } // if end } // if controll end }","link":"/2024/01/18/forward1/"},{"title":"使用RPC转发数据","text":"RPC转发数据 使用浏览器自带的WebSocket对象连接服务器转发数据 123456var ws=new WebSocket(&quot;ws://localhost:8899&quot;);ws.onmessage=function (e) { console.log(e) return xxx} 开启本地服务接受数据 12345678910111213141516171819202122import asyncioimport websocketsasync def echo(websocket): while True: await asyncio.sleep(2) print('发送.') await websocket.send('') data=await websocket.recv() print('data:',data) #我的爬虫代码 #xxxxasync def main_process(websocket,path): await echo(websocket)loop=asyncio.get_event_loop()loop.run_until_complete(websockets.serve(main_process,'localhost',8899))loop.run_forever()print('开启服务')","link":"/2024/01/18/forward2/"},{"title":"Html基础","text":"一种用于创建网页的标准标签语言 基本语法 HTML标签 双标签 &lt;head&gt;&lt;/head&gt; 单标签 &lt;br /&gt; 不区分大小写 基本结构 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;!--注意最后保存文档时的编码 --&gt; &lt;title&gt;这是标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--这是注释 --&gt; &lt;br /&gt;&lt;!--换行 --&gt; &lt;a href=&quot;url&quot; target=&quot;_self&quot;&gt;我是文本，从当前页面打开&lt;/a&gt;&lt;!--超链接 --&gt; &lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt;我是文本，新开页面打开&lt;/a&gt;&lt;!--超链接 --&gt; &lt;img src=&quot;url&quot; alt=&quot;加载不出来显示&quot; width=&quot;20&quot; height=&quot;30&quot;/&gt;&lt;!--加载图片,alt如果url加载不了显示alt --&gt; &lt;div&gt; &lt;span&gt;&lt;!--做布局 --&gt;&lt;/body&gt; &lt;/html&gt; Html字符实体 空格&amp;nbsp; 半角的空格&amp;ensp 全角的空格&amp;emsp Js代码添加在Html网页中1.script标签中 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;!--注意最后保存文档时的编码 --&gt; &lt;title&gt;这是标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; console.log(&quot;js代码&quot;);&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 2.文件引入 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;!--注意最后保存文档时的编码 --&gt; &lt;title&gt;这是标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=&quot;./demo.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.绑定事件中引入 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;!--注意最后保存文档时的编码 --&gt; &lt;title&gt;这是标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;普通按钮&quot; onclick=&quot;console.log('nihao')&quot; /&gt;&lt;br /&gt; &lt;a href=&quot;javascript:alert(&quot;点击&quot;)&quot; target=&quot;_self&quot; &gt;我是文本，从当前页面打开&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 4.网站地址栏里 javascript:alert(&quot;点击&quot;)","link":"/2023/10/26/html1/"},{"title":"Java基础(一)","text":"注释，变量，数据类型，常量，运算符 Java语言特点 特点 面向对象 强类型，解释性语言，.java文件编译成.class文件运行 跨平台运行在不同平台的jvm虚拟机上 垃圾回收机制 编译 javac xxx.java 运行 java xxx(class不显示) 书写格式 文件名字和公有类名要保持一致 一个文件中只能有一个公有类 类名首字母大写，命名每个单词首字母大写 命名规范 包名 全小写 类名 大驼峰 变量名、方法名 小驼峰 常量命 全大写，多个单词用下划线连接起来 多个类会被编译成多个class文件 utf8格式 public static void main(String[] args){}主函数入口不能改，只能改args变量名12345public class demo1 { public static void main(String[] args){ System.out.println(&quot;Hello Java&quot;); }} 注释12///* */ 转义字符12345\\t 制表符\\n 换行符\\\\ 一个\\\\&quot; 一个&quot;\\' 一个' 变量1234567//在内存中开辟了一片地址//类型 + 名称 + 值//区分大小写//字母数_$命名，数字不可开头//驼峰命名发//同一作用域不能重名int niHao = 0; 数据类型 数值型 整数 byte short int long 浮点 float double 字符型 字符 char 布尔 boolean 引用数据类型 类class 接口interface 数组[] 数值型 整数型 byte 1字节 short 2字节 int 4字节 long 8字节123//整数默认为int，声明long后需要加L或lint a = 1;long b = 1L; 浮点型 float 4字节 double 8字节12345//小数默认为double 声明float后需要加F或ffloat a = 10.1F;double b = 10;//int可以直接赋给doubledouble c = 2.3e3;//2300double d = 2.3e-3;//0.0023 字符型 字符 char 2字节 本质是存储一个整数，需要时可以进行强转(int)c1123456char a = 97;//achar b = 'a';char c = '/t';char d = '汉'； //可以进行运算char e = a + 1; 布尔 boolean 1字节 true/false 不可以为1/0代替 类型转换 自动类型转换（精度小的可以自动转换为） char-&gt;int-&gt;long-&gt;float-&gt;double byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double boolean不能转换 char 和 byte short 之间不能自动转换 有char byte short参与计算时自动转换为int12byte a = 127;//不报错 在给byte赋值时先判断在在不在byte范围内，在就不报错byte b = 128;//报错 不在byte范围 有字符串&quot;&quot;参与的计算自动转换为字符串 强转类型转换 强转的优先级比较高 高精度转低精度会丢掉部分数据 12int a = 120;byte b = (byte)a; 常量 123456789101112131415161718//整数常量int a = 100;//10进制int b = 0100;//8进制int c = 0x100;//16进制int d = 0b100;//2进制//小数常量float a = 100.0F;//布尔常量boolean a = true;//字符常量char a = '1';//字符串常量String a = &quot;1&quot;;//null常量String a = null;//只在String中//其他pubilc static final String NAME = &quot;nihao&quot;; BigInteger 保存比较大的整型 BigDecimal 保存浮点型 方法：加减乘除 add，subtract，multiply，divide 运算符 + - * / 特殊注意 字符 + 数字 = 字符 字符串 + 任意 = 字符串拼接 除法需要先判断除完后的类型再进行赋值，可能会丢掉一部分小数。 % 取余 -10%4 = -2 -10%4 = -2 10%4 = 2 10%-4=2 取余的结果取决于前面的数 ++ – i++ i– 先用再加减 ++i –i 先加减在用12345678int i =1;i = i++;System.out.println(i);int ii = 1;ii = ++ii;System.out.println(ii);//1//2 1234567int x = 4;int y = (--x)+(x--)+(x*10);// 3 + 3 + 2*10 = 26System.out.println(x);System.out.println(y);//2//26 赋值 = += -= *= /= %= 特殊123byte a = 1; a = a + 1;//报错int不能赋给bytebyte b = 1; b += 128;//可以赋值 可以超过bytebyte c = 1; c ++ ;//可以 关系运算符 返回true fasle == != &lt; &gt; &lt;= &gt;= A instanceof B A是否时B这个类的对象 逻辑运算符 短路 左边为真或假，右边就不判断了 || &amp;&amp; 逻辑 两边都判断 | &amp; 取反 ！ true取反为false，false取反为true 逻辑异或 ^ a和b相同为true，不同为false 三元运算符 变量 = 条件表达式？代码1:代码2； 表达式为true执行代码1，false执行代码2 位运算符 &amp; ｜ ^ ～ &lt;&lt; &gt;&gt; &gt;&gt;&gt; 运算优先级 加括号 进制转换 计算器 Hex编码 二进制转十六进制，每4bit为一组转为十六进制一位，所以二进制转十六进制结果翻倍。","link":"/2023/08/20/java1/"},{"title":"Java基础(十)","text":"集合 Collection单列集合 接口有两个字接口List和Set Map双列集合 k-v 集合 数组创建时长度必须指定，而且后续不能更改 数组保存的必须为同一类型元素 数组增加/删除元素比较麻烦 集合可以动态保存任意多个对象 集合提供了一系列方便的方法操作对象：add、remove、set、get等 集合框架体系 Collection单列集合 接口有两个字接口List和Set Map双列集合 k-v Collection单列集合 ArrayList为例，可使用的类方法123456789101112131415161718192021222324252627Collection collection = new ArrayList();//add 添加单个元素都是Object 加入的都是包装类型collection.add(100);collection.add(&quot;hello world&quot;);collection.add(false);collection.add(null);//remove 删除指定元素 List的子类有重载可以按index删除collection.remove(null);//contains 查找元素是否存在System.out.println(collection.contains(false));//size 获取元素的个数System.out.println(collection.size());//isEmpty 判断是否为空System.out.println(collection.isEmpty());//clear 清空collection.clear();Collection collection2 = new ArrayList();collection2.add(200);collection2.add(&quot;nihao&quot;);//addAll 添加多个元素collection.addAll(collection2);collection2.add(&quot;collection2&quot;);//containsAll 查找多个元素是否都存在System.out.println(collection.containsAll(collection2));//removeAll 删除多个元素collection.removeAll(collection2);System.out.println(collection); List list集合中元素有序，且可以重复 list元素都有一个索引，从0开始 list可以加入各种元素，可以重复加入，包括null 包括 Vector ArrayList LinkedList list遍历 list遍历方法适用于所有实现子类 迭代器遍历 iterator 对象称为迭代器，用于遍历Collection集合中的元素 实现Collection接口类都有iterator()方法，返回一个迭代器 iterator仅用于遍历集合，本身不存放对象12345Iterator iterator = list.iterator();while(iterator.hasNext()){Object o = iterator.next();System.out.println(o);} 增强for循环 其实就是迭代器遍历1234Iterator iterator = list.iterator();for(Object o:list){ System.out.println(o);} for循环1234Iterator iterator = list.iterator();for (int i=0;i&lt;list.size();i++){System.out.println(list.get(i));} ArrayList ArrayList是由数组来实现数据存储的 Vector与ArrayList基本相同，Vector线程安全多用于多线程，ArrayList单线程执行效率高没锁 ArrayList扩容机制 ArrayList中有一个Object类型的数组elementData用来存放元素 指定大小的构造器，初始elementData容量为指定大小，如需要扩容，则直接扩容为1.5倍 使用无参构造器，创建ArrayList对象时，初始为0，第一次添加扩大为10个，再次扩容为1.5倍12345678910111213141516171819202122232425262728293031import java.util.ArrayList;import java.util.List;public class demo1 { @SuppressWarnings({&quot;all&quot;}) public static void main(String[] args){ //add 在指定位置插入元素 List list = new ArrayList(); list.add(&quot;hello&quot;); list.add(&quot;world&quot;); list.add(&quot;nihao&quot;); list.add(2,&quot;java&quot;); //addAll 从指定位置插入多个元素 List list2 = new ArrayList(); list2.add(&quot;hello2&quot;); list2.add(&quot;world2&quot;); list2.add(&quot;nihao2&quot;); list.addAll(1, list2); //get 获取指定位置元素 System.out.println(list.get(2)); //indexOf 返回指定元素在集合中首次出现位置 System.out.println(list.indexOf(&quot;hello2&quot;)); //lastIndexOf 返回指定元素在集合中末次出现位置 System.out.println(list.lastIndexOf(&quot;hello2&quot;)); //remove 移除指定index位置的元素，并返回此元素 list.remove(5); //set 设置指定位置元素为，相当于替换 list.set(1, &quot;olleh&quot;); //subList 返回从1-3的子集合集 System.out.println(list.subList(1, 3)); }} Vector 用一个对象数组存放元素，elementData 扩容机制 无参时初始扩容10，再次扩容为2倍 有参时初始elementData为指定大小，每次扩容为2倍 可以指定每次扩容个数，初始为10，每次扩容3个 new Vector（10，3） LinkedList LinkedList底层是一个双层链表 LinkedList中有两个属性first和last分别指向首届点和节点尾 每个节点Node对象中包含next item prev 三个属性，其中item中存放元素，prev指向前一个节点，next指向后一个节点，实现双向链表 LinkedList和ArrayList LinkedList的添加删除不是通过数组完成的相对效率较高 ArrayList对查找修改效率高 都是线程不安全 Set 无序，添加和取出的顺序不同，没有索引 取出的顺序虽然不是添加的顺序，但是取出的顺序固定 不允许重复元素，所以最多包含一个null Set接口也是Collection的子接口，常用方法和Collection接口一样 包括 TreeSet HashSet LinkedHashSet Set接口的遍历123456789101112131415161718192021import java.util.*;public class demo1 { @SuppressWarnings({&quot;all&quot;}) public static void main(String[] args){ HashSet hashSet = new HashSet(); hashSet.add(&quot;nihao123&quot;); hashSet.add(&quot;hello&quot;); hashSet.add(&quot;world&quot;); Iterator iterator = hashSet.iterator(); //迭代器遍历 while(iterator.hasNext()) { Object o = iterator.next(); System.out.println(o); } //增强for循环 for(Object o : hashSet){ System.out.println(o); } }}//不能使用索引的方式来获取，因此无法用普通for循环遍历 TreeSet 底层走TreeMap 在构造器中可以传入一个比较器，指定排序规则 默认使用字母顺序排序 如果比较器返回结果为0，则数据不会加入到TreeSet HashSet HashSet底层实际上就是HashMap HashSet元素是无序的，取决于hash后，再确定索引结果1234567891011121314151617import java.util.*;public class demo1 { @SuppressWarnings({&quot;all&quot;}) public static void main(String[] args){ HashSet hashSet = new HashSet(); hashSet.add(&quot;nihao123&quot;); hashSet.add(&quot;hello&quot;); hashSet.add(&quot;world&quot;); System.out.println(hashSet); //remove hashSet.remove(&quot;world&quot;); hashSet.add(&quot;hello&quot;);//不可重复，添加失败 hashSet.add(new Dog(&quot;tom&quot;));//T 两个类不一样 hashSet.add(new Dog(&quot;tom&quot;));//T 可以添加 hashSet.add(new String(&quot;world&quot;));//不可重复，添加失败,虽然地址不同，但是指向相同 }} add进行的操作 HashSet底层是HashMap，HashMap底层是（数组+链表+红黑树） 添加一个元素时，先用Hashcode得到hash值，然后转换成索引值 找到存储数据表table，看这个索引位置是否已经存放的有元素 如果没有，直接加入 如果有，调用equals比较，如果相同，就放弃添加，如果不同，则添加到最后 在java8中，如果一条链表的元素个数&gt;=TREEIFY_THRESHOLD默认8，并且table的大小&gt;=MINTREEIFY_CAPACITY默认64，就会进行树化（红黑树） 如果链表元素到达8个，但是table大小没有到64，会先进行数组扩容 自定义类要重写Hashcode 和 equals方法 LinkedHashSet 是HashSet的子类 不允许添加重复元素 底层是LinkedHashMap 存放元素方式和HashSet相同，只不过它在这个基础上又维护了一个双向链表，使得元素遍历的顺序和添加顺序一致 Map双列集合 Map和Collection并列存在。用于保存具有映射关系的数据：key-value Map中的Key和Value可以是任意引用类型的数据，会封装到HashMap$Node对象中 Map中的Key不可重复，原因和HashSet一样，当Key一样时，新的值会替换原先的 Map中的Value可以重复 Map的Key可以为null（唯一），vale可以为null Key和value之间是单向一对一关系，通过指定Key总能找到对应Value 方法 put（”key”,”value”）添加 remove 根据键删除映射关系 get 根据键获取值 size 获取元素个数 isEmpty 判断个数是否为0 clear 清除 containsKey 查找键是否存在 遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import com.sun.javafx.collections.MappingChange;import java.util.*;import java.util.function.Consumer;public class demo1 { @SuppressWarnings({&quot;all&quot;}) public static void main(String[] args){ HashMap hashMap = new HashMap(); hashMap.put(&quot;a&quot;, &quot;b&quot;); hashMap.put(&quot;c&quot;, &quot;d&quot;); hashMap.put(null, &quot;f&quot;); hashMap.put(&quot;e&quot;,null); System.out.println(&quot;--------------------------------&quot;); Set set = hashMap.keySet(); System.out.println(&quot;--------------加强For循环遍历------------------&quot;); for (Object o : set){ System.out.println(o+&quot;-&quot;+hashMap.get(o)); } System.out.println(&quot;--------------迭代器遍历------------------&quot;); Iterator iterator = set.iterator(); while (iterator.hasNext()){ Object key = iterator.next(); System.out.println(key+&quot;=&quot;+hashMap.get(key)); } System.out.println(&quot;--------------只遍历value------------------&quot;); Collection values = hashMap.values(); for (Object o : values){ System.out.println(o); } System.out.println(&quot;-------------通过forEach遍历-------------------&quot;); set.forEach(new Consumer() { @Override public void accept(Object key) { System.out.println(key+&quot;=&quot;+hashMap.get(key)); } }); //通过获取entrySet获取key value System.out.println(&quot;-------------通过EntrySet遍历-------------------&quot;); Set entrySet = hashMap.entrySet();//EntrySet&lt;Map.Entry&lt;K,V&gt;&gt; for (Object obj : entrySet){ Map.Entry entry = (Map.Entry)obj; System.out.println(entry.getKey()+&quot;=&quot;+entry.getValue()); } System.out.println(&quot;-------------通过迭代器EntrySet遍历-------------------&quot;); Iterator iterator2 = entrySet.iterator(); while (iterator2.hasNext()) { Object entry = iterator2.next(); Map.Entry m = (Map.Entry)entry; System.out.println(m.getKey()+&quot;=&quot;+m.getValue()); } }} HashMap LinkedHashMap 为其子类 TreeMap 在构造器中可以传入一个比较器，指定排序规则 k-v可以都为null 如果比较器返回结果为0，则key不会加入到TreeMap，值会替换 Hashtable 存放的元素是键值对：k-v HashTable的键和值都不能是null，否则会抛出NullPointerException HashTable使用方法基本上和HashMap一样 HashTable线程安全（有加锁），HashMap线程不安全 Properties Properties类继承自Hashtable类 使用一种键值对的形式来保存数据，使用特点和HashTable类似 Properties还可以用于从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改。xxx.properties文件通常为配置文件 Properties的增删改查 Collections工具类 是一个操作Set、List和Map等集合的工具类 提供了一系列静态方法对集合元素进行排序、查询和修改等操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;public class Hello { @SuppressWarnings({&quot;all&quot;}) public static void main(String[] args) throws Exception { ArrayList arrayList = new ArrayList(); arrayList.add(100); arrayList.add(200); arrayList.add(300); arrayList.add(400); arrayList.add(500); arrayList.add(600); arrayList.add(700); arrayList.add(800); arrayList.add(900); arrayList.add(900); System.out.println(arrayList); System.out.println(&quot;==================================&quot;);// a) reverse(List): 反转List中元素的顺序 Collections.reverse(arrayList); System.out.println(arrayList); System.out.println(&quot;==================================&quot;);// b) shuffle(List): 对List集合元素进行随机打乱 for (int i = 0; i &lt; 5; i++) { Collections.shuffle(arrayList); System.out.println(arrayList); } System.out.println(&quot;==================================&quot;);// c) sort(List): 根据元素的自然顺序对指定List集合元素按升序排序 Collections.sort(arrayList); System.out.println(arrayList); System.out.println(&quot;==================================&quot;);// d) sort(List, Comparator): 根据指定规则对List集合元素进行排序 Collections.sort(arrayList, new Comparator&lt;Object&gt;() { @Override public int compare(Object o1, Object o2) { return (int)o2 - (int)o1; } }); System.out.println(arrayList); System.out.println(&quot;==================================&quot;);// e) swap(List,int,int): 将指定List集合中的i处元素和j处元素进行交换 Collections.swap(arrayList, 1, 8); System.out.println(arrayList); System.out.println(&quot;==================================&quot;); // a) Object max(Collection): 根据元素的自然顺序，返回集合中的最大元素 Object max1 = Collections.max(arrayList); System.out.println(arrayList); System.out.println(max1); System.out.println(&quot;=================================&quot;); // b) Object max(Collection, Comparator): 根据指定规则, 返回集合中的最大元素 Object max2 = Collections.max(arrayList, new Comparator&lt;Object&gt;() { @Override public int compare(Object o1, Object o2) { return (int)o1 - (int)o2; } }); System.out.println(arrayList); System.out.println(max2); System.out.println(&quot;=================================&quot;);// e) int frequency(Collection, Object): 返回指定集合中指定元素的出现次数 int frequency = Collections.frequency(arrayList, 900); System.out.println(frequency); System.out.println(&quot;=================================&quot;);// f) void copy(List dest,List src): 将src中的内容复制到dest中 ArrayList new_arrayList = new ArrayList(arrayList.size()); for (int i = 0; i &lt; arrayList.size(); i++) { new_arrayList.add(0); } Collections.copy(new_arrayList, arrayList); System.out.println(new_arrayList); System.out.println(&quot;=================================&quot;);// g) boolean replaceAll(List list, Object oldVal, Object newVal): 使用新值替换所有旧值 Collections.replaceAll(new_arrayList, 200, 1000); System.out.println(new_arrayList); System.out.println(&quot;=================================&quot;); }} 集合使用的选择 判断需要存储数据的类型（一组对象或一组键值对） 一组对象（单列）：Collection接口 允许重复：List 增删多：LinkedList（底层是双向链表） 改查多：ArrayList（底层是Object类型的可变数组） 不允许重复：Set 无序：HashSet（底层是HashMap，数组+链表+红黑树） 排序：TreeSet 插入和取出顺序一致：LinkedHashSet（底层是数组+双向链表） 一组键值对（双列）：Map接口 键无序：HashMap（底层jdk7:数组+链表，jdk8:数组+链表+红黑树） 键排序：TreeMap 键插入和取出顺序一致：LinkedHashMap 读取文件：Properties","link":"/2023/10/23/java10/"},{"title":"Java基础(十一)","text":"泛型 编译时，检测添加元素的类型，提高了安全性 减少了类型转换次数，提高效率Properties读配置文件 泛型1ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); 泛型是一种可以接受数据类型的类型，相当于通用型 泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生类型转换异常。同时代码更加简洁 可以在类声明时通过一个标识符表示类中某个属性的类型，或者是某个方法的返回值的类型、参数类型 声明： &lt;E&gt; &lt;T&gt; &lt;K,V&gt;这里的E就是泛型，字母可以随意表示，在实例化时指定类型可以是String，Integer，Boolean,Dog；12interface List&lt;T&gt; {}class HashMap&lt;K,V&gt; {} T,K,V不代表值，而是代表类型，任意字母都可以。 实例化 1HashMap&lt;String,String&gt; hashMap = new HashMap&lt;String,String&gt;(); 1Iterator&lt;Map.Entry&lt;String,String&gt;&gt; Iterator = entries.iterator(); 细节 T，K，V只能放指定引用类型 在给定泛型指定具体类型后，可以传入该类型或者其子类类型123HashMap hashMap2 = new HashMap();//等价HashMas&lt;Object&gt; hashMap3 = new HashMas&lt;&gt;(); 自定义泛型类 1234567class People&lt;T&gt;{ public T name; public T test(T a){ System.out.println(a); return a; }} 泛型标识符，一般是单个大写字母 泛型标识符可以有多个 实例属性，实例方法参数，实例方法返回值都可以使用泛型 静态属性，静态方法，静态代码块都不能使用泛型 使用了泛型的数组不能初始化 泛型类的类型是在创建对象时确定的 创建对象时没有指定类型，默认为Object 自定义泛型接口 接口中，静态成员不能使用泛型 泛型接口类型，在继承接口或者实现接口时确定 没有指定类型，默认为Object 自定义泛型方法 泛型方法，可以定义在普通类中，也可以定义在泛型类中 泛型方法和使用了泛型的方法的区别 泛型方法，可以使用类声明的泛型，也可以使用自己声明的泛型 当泛型方法被调用时，类型会确定 泛型方法可以是静态的，但是如果用了类声明的方法，就不能静态了 泛型通配符 泛型没有继承 支持任意泛型类型 支持A类以及A类的子类，规定了泛型的上限 支持A类以及A类的父类，不限于直接父类，规定了泛型的下限 Properties读配置文件 文件名以properties结尾 k-v形式 java获取工程路径123456String filePath = new File(&quot;&quot;).getCanonicalPath() + File.separator + &quot;src\\\\demo.properties&quot;;Properties properties = new Properties();properties.load(new FileInputStream(filePath));String className = (String) properties.get(&quot;class&quot;);String methodName = (String) properties.get(&quot;method&quot;);System.out.println(className + &quot;.&quot; + methodName);","link":"/2023/10/23/java11/"},{"title":"Java基础(十二)","text":"反射 在不修改源码的情况下，控制程序 在不知道类结构信息的情况下，也可以获取类的结构信息，方便后续的hook 可以突破访问修饰符限制 class method 字段 构造器 Class类 Class也是类，因此也继承Object类（接口没有继承Object） Class类对象是通过ClassLoader的loadClass加载的 Class类对象只加载一次，除非ClassLoader不一样 通过Class可以完整的得到一个类的完整结构，通过一系列API Class对象是存放在堆中，类的字节码二进制数据是存放在方法区，有的也称为类的元数据（包含方法代码，变量名，方法名，访问权限等） 有Class类对象 外部类 成员内部类，静态内部类，局部内部类，匿名内部类 interface 数组 enum，Thread.State annotation 注解 基本数据类型 void Class类对象的获取方式 Class&lt;*?*&gt; cls = Class.forName(className); Class&lt;*?*&gt; cls1 = hello.class; Class&lt;*?*&gt; cls2 = new hello().getClass(); Class&lt;*?*&gt; cls3 = hello.class.getClassLoader().loadClass(className); Class&lt;*?*&gt; cls4 = new hello().getClass().getClassLoader().loadClass(className); 基本数据类型的Class类对象获取 System.out.println(int.class); System.out.println(Integer.TYPE); 获取包装类的类对象 System.out.println(Integer.class); Class类方法反射创建对象 无参构造器 Class&lt;*?*&gt; hello = Class.forName(&quot;hello&quot;); Object o1 = hello(); 有参构造器 Constructor&lt;*?*&gt; constructor = hello.getConstructor(String.class, int.class); Object o2 = constructor.newInstance(&quot;hello&quot;, 30); 私有构造器 Constructor&lt;*?*&gt; constructor1 = hello.getDeclaredConstructor(String.class); constructor1.setAccessible(true); Object o3 = constructor1.newInstance(&quot;hello&quot;); 反射操作属性 Declared可以获取所以的（公开和私有），加s获取全部的属性或方法 获取属性 Field nameField = hello.getField(&quot;name&quot;); String name = (String)nameField.get(对象); 设置属性 nameField.set(对象, &quot;hello2&quot;); name = (String)nameField.get(o3); 私有属性 getDeclaredField 如果是静态属性，第一个参数可以给null 反射操作方法 getMethod(name,类对象) getDeclaredMethod invoke(对象，参数列表)调用 其他方法 获取内部类 getClasses() getDeclaredClasses() 获取父类 getSuperclass() 获取接口 getInterface() 获取类全名 getName() getSimpleName() 遍历类结构123456789101112131415161718Class&lt;?&gt; hello = Class.forName(&quot;hello&quot;);Field[] declaredFields = hello.getDeclaredFields();for (Field declaredField : declaredFields) {System.out.println(declaredField);//System.out.println(declaredField.getModifiers());//System.out.println(Modifier.isPrivate(10));//System.out.println(declaredField.getName());}Method[] declaredMethods = hello.getDeclaredMethods();for (Method declaredMethod : declaredMethods) {System.out.println(declaredMethod);}Constructor&lt;?&gt;[] constructors = hello.getConstructors();for (Constructor&lt;?&gt; constructor : constructors) {System.out.println(constructor);} import java.lang.reflect.Field类 getModifiers int形式返回修饰符 getType Class形式返回类型 getName 返回属性名 import java.lang.reflect.Method类 getModifiers int形式返回修饰符 getName 返回属性名 getReturnType Class形式获取返回类型 getParameterTypes Class[]形式获取返回类型 import java.lang.reflect.Constructor;类 getModifiers int形式返回修饰符 getName 返回属性名 getParameterTypes Class[]形式获取返回类型 newInstance 创建有参构造器对象","link":"/2023/10/23/java12/"},{"title":"Java基础(二)","text":"顺序结构 分支结构 循环结构 if 单分支if 双分支 if…else… 123456789101112int a =10;if(a &lt; 10){ System.out.println(&quot;Hello Java&quot;);}if(a &lt; 10){ System.out.println(&quot;Hello Java&quot;);}else if(a == 10){ System.out.println(&quot;Nihao Java&quot;);}else{ System.out.println(&quot;Buhao Java&quot;); } switch switch case break default 不加break会向下继续执行 1234567891011121314int a =1;switch(a){ case 1: System.out.println(&quot;Hello Java1&quot;); break; case 2: System.out.println(&quot;Hello Java2&quot;); break; case 3: System.out.println(&quot;Hello Java3&quot;); break; default: System.out.println(&quot;default&quot;);} switch中表达式的数据类型要和case后常量类型一致，或者可以转换 switch中表达式的数据类型，只能是byte short char int String enum case 后面的值，只能是常量或者常量表达式，不能是变量 while 先判断后执行 12345int a =1;while(a &lt; 5){ System.out.println(&quot;Hello Java&quot;); a++;} 先执行后判断(至少执行一次) 12345int a =1;do{ System.out.println(&quot;Hello Java&quot;); a++;}while(a &lt; 5); for for(初始化表达式；循环条件表达式；循环后的操作表达式) 初始化表达式：可以任意，多个表达式中间用逗号分隔 循环条件表达式：结果必须为boolean类型 执行语句只有一句可以省略{} 变量在for循环中生成，在for循环结束后销毁 12345int a = 0;for (int i = 0; i &lt; 100; i++) { a += i; }System.out.println(a); 循环控制 break 跳出循环 break+xxx 跳出指定循环 continue 跳到本次循环结束 continue+xxx跳出指定循环 return 跳出方法，如果在main函数中，直接退出程序","link":"/2023/08/27/java2/"},{"title":"Java基础(三)","text":"数组 数组初始化 初始化 java中的数组只能放同一类的数据，js python 可以随意放 123456789//动态初始化int[] arr = new int[5];//静态初始化int[] arr1 = {1,2,3,4,5};int[] arr2 =new int[]{1,2,3,4,5};char arr3 [] = new char[5];//初始化变量arr[0] = 1;arr[1] = 2; 默认值 long/int/short/byte 0 float/double 0.0 char \\u0000 boolean false String null 其他 数组下标从0开始，越界会抛出异常 int[] arr = new int[3]; System.out.println(arr[3]); 空指针也会抛出异常 int[] arr; 数组的遍历和拷贝 获取数组长度 12int[] arr = new int[5];System.out.println(arr.length); 使用for / while 进行循环遍历 数组的拷贝 java中的数组不能随意添加新的元素 可以先创建一个新的数组，再将原数组循环赋值给新数组，再给新数组的新元素添加值，最后将原数组至为null 不能直接复制，数组是引用传递，不是值传递。 引用传递其实也是一种值传递，他传递的是内存地址 栈内存和堆内存 栈内存中存放局部变量，离开作用域自动释放，基本数据类型的值传递 堆内存中存放对象和数组 通过new的实例 gc会不定时回收 二维数组1234int [][] arr= new int[2][3];System.out.println(arr.length);System.out.println(arr[0].length);System.out.println(arr[1].length); 定义方式 12345int arr1[][]= new int[2][3];int [] arr3[]= new int[2][3];int[]x,y[]=new int[2][3];//int[] 表示后面的是个数组//int[] x,y[] 表示先定义，一维数组x，再定义二维数组y 10进制转16进制代码实现1234567891011121314public class demo1 { public static void main(String[] args){ int a = 100; StringBuilder stringBuilder = new StringBuilder(); char[] chars = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'}; while (a &gt; 0){ int index = a % 16; char temp = chars[index]; stringBuilder.append(temp); a = a/16; } System.out.println(stringBuilder.reverse().toString());; }}","link":"/2023/08/27/java3/"},{"title":"Java基础(四)","text":"类 类的参数，返回值，传参机制 静态属性（类属性）和实例属性（对象属性） 抽象类 java类 构造器 构造器和类名一致，没有返回值 当对象创建的时候，会自动调用对应的构造器 如果没有定义构造器，会自动生成默认无参构造器 一个类可以定义多个不同构造器，利用重载 一旦定义了自己的构造器，默认构造器就覆盖了，需要使用默认构造器需要重新定义一下 Cat对象创建流程，Cat cat = new Cat();在堆中分配空间，对对象进行初始化（默认初始化，显式初始化，构造器初始化），将堆中地址返回给cat12345678910public class Cat { String name; Cat(){ System.out.println(&quot;Cat constructor&quot;); } Cat(String name){ this.name = name; System.out.println(name); }} 1234567public class Hello { @SuppressWarnings(&quot;all&quot;) public static void main(String[] args) throws Exception { Cat cat = new Cat(); Cat cat2 = new Cat(&quot;小白&quot;); }} 在new一个新对象时调用构造器12345678910public class Cat { String name; int age; String color; public Cat(String name, int age, String color) { this.name = name; this.age = age; this.color = color; }} 实例化的新对象在堆内存中1234567891011public class test { public static void main(String[] args){ //没有构造器时可以这样 Cat cat1 = new Cat(); //有构造器使用这样 Cat cat = new Cat(&quot;好吃&quot;, 10, &quot;blue&quot;); System.out.println(cat.name); System.out.println(cat.age); System.out.println(cat.color); }} 类的参数，返回值，传参机制1234567891011121314151617181920212223242526272829303132333435363738394041/*访问修饰符+返回值类型+方法名（形参）{ 语句； return 返回值；}*///调用/*在类内部需要直接调用在类外部需要先实例化对象，在调用对象方法*///返回值/*一个方法只能返回一个值，要返回多个可以用数组返回值可以是任意类型，包括基本数据类型和引用类型返回值类型，必须和return的值类型一致或兼容当函数没有返回值，那么返回值类型用viod，return可以省略*///参数/*一个方法可以没有参数，也可以有多个参数，中间用逗号隔开参数类型可以为任意类型，包含基本数据类型或引用数据类型方法定义时的参数称为形式参数，方法调用时的参数称为实际参数，实参和形参的类型要一致或兼容，个数，顺序必须一致*///方法体//不可以在方法内部定义新方法（js python 可以 java不行）//传参机制/*值传递形参的改变不会影响实参 int引用传递传递的是地址，数组，形参变化会影响实参特殊String 和 null不会改变实参，因为没有改变元素数据指针指向的地址，而是新创建的对象。*/ 静态属性（类属性）和实例属性（对象属性） 静态属性使用static 所以对象公用的的属性，可以直接通过类名直接调用，或者对象调用修改 实例属性，必须通过对象来调用修改 在静态方法中不能调用实例属性和方法 实例方法中可以调用静态属性和方法 抽象类 abstract 修饰类和方法 抽象类，抽象方法 父类进行抽象子类实现功能 public abstract class A();抽象类不能被实例化，因为没东西给他实例。 继承抽象类必须实现抽象类的所以方法 不能使用private，final，static来修饰","link":"/2023/10/22/java4/"},{"title":"Java基础(五)","text":"访问修饰符 封装 重载 可变参数 变量作用域 访问修饰符 public 本类 同包 子类 不同包 protected 本类 同包 子类 没修饰符 本类 同包 private 本类 修饰符可以用来修饰类中的属性，成员方法以及类 只有默认和public才能修饰类 封装 通过隐藏对象属性和方法实现细节，仅对外公开用于操作内部数据的接口，控制程序中属性的读和修改的访问级别。 使用set，get方法验证传入数据的合理性 重载 同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型（参数顺序）不同即可 相同名字，与返回值无关，只看参数类型，顺序 js，python 中会覆盖前面的同名12345678910111213public class Hello { @SuppressWarnings(&quot;all&quot;) public static void main(String[] args) throws Exception { test(&quot;Hello&quot;); test(1); } static void test(String a){ System.out.println(&quot;String&quot;+a); } static void test(int a){ System.out.println(&quot;int&quot;+a); }} 可变参数 可变参数本质就是数组，实参可以为0个或任意多个 可变参数的实参可以为数组（只能传一个数组） 形参列表中只能出现一个可变参数 可变参数和普通类型参数放在一起要保证可变参数为最后一个12345678910111213141516171819202122232425public class Hello { @SuppressWarnings(&quot;all&quot;) public static void main(String[] args) throws Exception { add(1,2,3,4,5); int i[] = {1,2,3,4,5}; add(&quot;hello&quot;,i); } static void add(int... a){ int reverse = 0; for(int i=0; i&lt;a.length; i++){ System.out.println(a[i]); reverse += a[i]; } System.out.println(reverse); } static void add(String name,int... a){ System.out.println(name); int reverse = 0; for(int i=0; i&lt;a.length; i++){ System.out.println(a[i]); reverse += a[i]; } System.out.println(reverse); }} 变量作用域 全局变量 属性（成员变量），可以被本类或其他类使用 可以加访问修饰符 有默认值，可以不赋值直接使用 生命周期长，伴随着对象的创建而创建，伴随着对象的销毁而销毁 局部变量 除了属性之外的其他变量，只能在对象代码块中使用 不可以加访问修饰符 没有默认值，必须赋值后才能使用 生命周期短，伴随着代码块的执行而创建，伴随着代码块的结束而销毁 块级作用域 静态代码块，构造代码块，方法代码块，局部代码块，语句代码块 执行顺序上静态代码块优先级高 属性和局部变量可以重名，优先使用局部变量 在同一个作用域中，两个局部变量，不能重名 this java虚拟机会给每个对象分配this，代表当前对象 哪个对象调用方法，this就指向哪个对象 this本质存放的是内存地址 this可以用来区分当前对象的属性和局部变量 this不能在类外部使用，只能在类内部实例方法中使用 this可以在类内部赋值和获取实例属性 this在类内部调用方法 this.方法名，this.实参列表 this方法 this() 用于构造方法之间访问，必须是构造器的第一语句 包 实际上是创建不同的文件夹/目录来保存类文件 控制访问范围，便于管理，区分相同名字的类 声明当前类所在包，需要放在最上面，一个类中只能有一个package 基本语法 package com.xxx.app; package 关键字 命名规范与变量命名相同，一般字母全小写 package导入到类名 package使用同名类时，用com.xxx.app app = new com.xxx.app();创建对象","link":"/2023/10/22/java5/"},{"title":"Java基础(六)","text":"继承 代码块 继承 提高代码复用性 语法 class 子类 extends 父类{} 父类又叫超类/基类，子类又叫派生类 当多个子类存在相同的属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所以子类不需要在定义这些属性和方法，只需要通过extends继承父类 子类自动拥有父类的所以属性和方法，但受访问修饰符的影响，子类访问父类私有属性和方法通过set，get 继承只能继承一个，python可以多个 所以类的父类都是object 父类构造器 当创建子类对象时，不管使用哪个子类构造器，默认情况下都会去调用父类的无参构造器，也就是子类默认在首句加上super（） 如果父类自定义了构造器没有重写默认构造器，则会报错，可以使用super(参数列表)来指定父类的构造器，super和this方法都必须放在构造器第一行，因此两个方法不能存在一个构造器。 父类构造器的调用不限于父类，一直往上到object类 super 子类和父类具有相同名字属性和方法时，默认调用子类，要想使用父类的属性和方法，使用super.属性名/方法名（受访问修饰符影响） 访问父类构造器super（参数），必须写在子类构造器第一行 super和this this访问自身的属性和方法，没找到才去找父类的 super找父类的属性和方法，没有找爷爷类 this()构造器，super()访问父类构造器 方法重写 方法重写也叫方法覆盖 子类方法名称参数与父类完全相同 子类方法的返回类型和父类方法的返回类型一致，或者是其子类 ，父类Object子类可以返回String类型 访问权限只能扩大不能缩小，父类private子类protected 重写和重载区别 重载：同一个类中方法名相同，参数不同，与返回值无关，与访问修饰符无关 子类方法的返回类型和父类方法的返回类型一致，或者是其子类 ，父类Object子类可以返回String类型 代码块 静态代码块 可以定义多个，和静态属性优先级一样，按定义顺序执行 随着类的加载而执行，只执行一次，执行时机比普通代码块早 普通代码块 可以定义多个，和实例属性优先级一样，按定义顺序执行 随着对象创建而执行 类的加载 创建对象实例 创建子类对象实例，父类也会被加载 使用类的静态成员时 使用子类的静态成员时，父类也会被加载 静态代码块只能调用静态成员，普通代码块可以调用任意成员 执行顺序，先父类静态属性和方法，在子类静态属性和方法，在父类普通代码-&gt;构造器，在子类普通代码-&gt;构造器123456789101112131415161718192021222324public class demo1 { public static void main(String[] args){ new Test(); }}class Demo { Demo(String s){ System.out.println(s); } Demo(){ System.out.println(&quot;无参构造器&quot;); }}class Test { Demo demox = new Demo(&quot;demox初始化&quot;); static Demo demo2 = new Demo(&quot;demo2初始化&quot;); static { System.out.println(&quot;static块执行&quot;); } Test () { System.out.println(&quot;Test无参构造器&quot;); }}","link":"/2023/10/22/java6/"},{"title":"Java基础(七)","text":"多态 类方法 接口 多态 多态的前提是两个对象存在继承关系 参数定义为父类型，就可以将任意子类型传入 向上转型语法 父类类型 引用名 = new 子类类型(); 父类引用指向子类对象 编译类型看左边，运行类型看右边 属性的值看编译类型 编译类型是给编译器看，因为在编译器看类父类中没有子类特有的属性，所以不能调用子类中特有的成员 方法看运行类型，属性看编译类型 instanceOf 判断运行类型是否存在继承关系 可以调用父类中的所有成员（受访问修饰符影响） 调用的时候，子类有就用子类成员，子类没有就找父类（就近原则） 不能调用子类中特有的成员 要调用子类中特有的成员，需要向下转型（强制转换）转回实际类型 多态数组 数组的定义类型为父类类型，里面保存的实际元素类型为子类类型 要调用子类中特有的成员，需要向下转型（强制转换）转回实际类型 动态绑定机制 当调用对象方法时，该方法会和该对象的内存地址/运行类型进行绑定,不管是子类方法还时返回的函数，都先从子类开始找。 当调用对象属性时，没有动态绑定机制，就近原则1234567891011121314151617181920public class test { public static void main(String[] args){ B b = new B(); System.out.println(b.count); b.display(); A a = b; System.out.println(a == b); System.out.println(a.count); a.display(); }}class A { int count = 100; public void display(){System.out.println(this.count);}}class B extends A { int count = 200; public void display(){System.out.println(this.count);}} 1234567891011121314151617181920public class demo1 { public static void main(String[] args){ A a = new B(); System.out.println(a.sum()); System.out.println(a.sum1()); }}class A { public int i =10; public int sum(){return geti();} public int sum1(){return i+10;} public int geti(){return i;}}class B extends A { public int i =20; public int sum(){return i+20;} public int sum1(){return i+10;} public int geti(){return i;}} 类方法 equals == 判断基本类型判断值，判断引用类型判断地址 equals推荐判断字符串，可以判断引用类型 Object中的方法，只会去判断引用类型的地址是否相等 子类（String，Integer）会重写equals方法，判断内容是否相等 toString 默认返回 ：全类名+@+hash值 子类重写toString方法，返回对象的属性 直接输出一个对象时默认调用toString finalize 释放资源 某个对象没有任何引用时垃圾回收机制会销毁该对象，销毁前先调用finalize方法 也可以主动使用System.gc()立即回收（不一定能立刻回收） final 不希望类被继承 不希望属性/方法被修改 使用注意 final修饰属性，必须初始化（或者在构造器中赋值，普通代码块中，但只能赋值一次），修改后不能再改 包装类都是final类 final修饰的类不能被继承但可以实例化对象 final和static搭配使用时，不会加载类 接口 基本语法 接口文件 接口不能被实例化 继承：提高代码的复用性和可维护性 接口：设计好各种规范，让其他类去实现这些方法，是对单继承的一种补充123456789public interface 接口名{ //属性 //方法（一般是抽象方法） //也可以使用静态方法static 可以有具体实现 //也可以使用默认方法default 可以有具体实现}class Jieko implements jieko{ //必须实现接口的所以抽象方法} 接口不能被实例化 接口的修饰符只能是public和默认（默认不写也是public） 接口不能继承类，但可以继承多个接口，用逗号隔开 默认接口方法都是public abstract 默认接口属性都是public static final 一个普通类实现接口，必须将该接口的所有方法都实现 抽象类实现接口，可以不实现该接口的所有方法 一个类可以实现多个接口 接口中属性的访问形式：接口名.属性名，必须指定接口名或类名","link":"/2023/10/22/java7/"},{"title":"Java基础(八)","text":"内部类 枚举类 注解 内部类 定义在外部类的成员位置上，并且没有static修饰 可以直接访问外部类的所有成员，包含私有的，静态的 可以添加任意访问修饰符去修饰成员内部类，因为他相当于一个成员 成员内部类不能定义静态成员 作用域与其他成员一样 外部类可以访问成员内部类 外部其他类也可以访问成员内部类 new Test（）. new Inner（） 在外部类里定义一个方法，返回内部类的对象 外部类和内部类成员重名，遵循就近原则，想要访问外部类成员使用 外部类名.this.成员 去访问 获取内部类名 getClass jeb 静态内部类 定义在外部类的成员位置上，并且有static修饰 可以直接访问外部类的所有静态成员，包含私有的 可以添加任意访问修饰符去修饰静态内部类，因为他相当于一个成员 作用域与其他成员一样 外部类可以访问静态内部类 外部其他类可以访问静态内部类 new Test.Inner(); 在外部类里定义一个方法，返回内部类的对象 外部类和内部类成员重名，遵循就近原则，想要访问外部类成员使用 外部类名.静态成员 去访问 局部内部类局部内部类 定义在外部类的局部位置上，比如方法中，并且有类名 可以直接访问外部类的所有成员，包含私有的，静态的 如果定义在静态方法中，则只能访问外部类的静态成员 不能添加访问修饰符，可以使用final修饰，因为他就是一个局部变量 作用域仅在定义他的代码块中，与局部变量一致 外部类和内部类成员重名，遵循就近原则，想访问外部类的成员，可以使用 外部类名.this.成员 去访问实例方法中。如果定义在静态方法中，可以使用 外部类名.静态成员 去访问 外部类不能访问局部内部类 匿名内部类 基于接口的匿名内部类 基于类（抽象类）的匿名内部类 可以直接访问外部类的所有成员，（受访问修饰符影响），包括静态的 匿名内部类不能定义静态成员 匿名内部类只能创建一个实例 匿名内部类实际也是有名字的，系统按照顺序自动分配 外部类和内部类成员重名，遵循就近原则，想访问外部类的成员，如果是静态成员，可以使用 外部类名.静态成员名 去访问，如果是实例成员，只有当匿名内部类处于外部类里面的时候，才能使用 外部类名.this.成员名 去访问 外部类不能访问匿名内部类 匿名内部类在定义的同时直接创建对象，并当作实参传递，代码简洁 枚举类 enum类概念：枚举是一种特殊的类，里面包含一组有限的只读对象，枚举是一组常量的集合 自定义枚举类 构造器私有化 定义 public static final 修饰的属性 枚举对象通常全部大写 使用enum代替class 简化定义属性 使用无参构造器创建枚举对象，则小括号可以省略 枚举对象可以有多个属性 enum类重写了toString方法12345678910111213141516171819202122232425262728293031323334353637public class demo1 { @SuppressWarnings({&quot;all&quot;}) public static void main(String[] args){ System.out.println(Test.SPRING); System.out.println(Test.WINTER); System.out.println(Test2.SPRING); }}class Test{ public String name = null; public static final Test SPRING = new Test(&quot;SPRING&quot;); public static final Test SUMMER = new Test(&quot;SUMMER&quot;); public static final Test AUTUMN = new Test(&quot;AUTUMN&quot;); public static final Test WINTER = new Test(&quot;WINTER&quot;); private Test(String name) { this.name = name; } @Override public String toString() { return name; }}enum Test2 { xxx,SPRING(&quot;SPRING&quot;); public String name = null; private Test2(){ } private Test2(String name) { this.name = name; } @Override public String toString() { return name; }} 1234567891011121314public class demo1 { @SuppressWarnings({&quot;all&quot;}) public static void main(String[] args){ Test3 spring1 = Test3.SPRING; Test3 spring2 = Test3.SPRING; System.out.println(spring1); System.out.println(spring1 == spring2); }}enum Test3{ SPRING,SUMMER;}//SPRING//true 注解 安卓逆向中retrofit中常用 @Override: 验证某个方法为重写父类方法，该注解只能用在方法 @Depercated：用于表示某个程序元素已过时，有一个横杠在上面 @SuppressWarnings({“all”})：用于抑制编译器警告 注解类 @Target 指定注解修饰范围，修饰注解的注解，称为元注解 @interface","link":"/2023/10/22/java8/"},{"title":"Java基础(九)","text":"异常 包装类 字符串String Arrays方法 System方法 异常 Error：严重错误，程序会崩溃，StackOverflowError，OutOfMemoryError等 Exception 编译时异常 使用try-catch或throws处理 运行时异常 程序中如果没有处理，默认使用throws方式 try-catch-finally try块中包含可能出错的代码，catch块用于处理try块中发生的异常 try块中的代码出现异常，则异常发生后面的代码不会执行，直接跳到catch块中执行 try块中的代码无异常，则不执行catch块中的代码 无论try块中的代码是否异常，即使碰到return，finally块中代码都会执行 可以有多个catch语句，根据异常不同，进行不同的义务处理，要求父类异常在后，子类异常在前 比如Exception在后，NullPointerException在前，如果发生异常只会匹配一个catch try { } catch (NullPointerException e) { // TODO: handle exception }catch(Exception e){ }finally{ } 12345678910111213141516171819202122232425262728293031323334353637- throws - 如果发生异常，将这些异常丢给该方法的调用者处理 - throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类 - 子类重写父类方法时，抛出异常类型要和父类抛出异常类型一致，或是父类抛出异常类型的子类型 - 被调用的方法抛出运行时异常，调用的方法不处理也没有问题，因为默认有throws方式- 常见的运行时异常 - NullPointerException 空指针异常 - ArithmeticException 算数运算异常 - ArrayIndexOutOfBoundsException 数组下标越界异常 - ClassCastException 类型转换异常 - NumberFormatException 数字格式不正确异常- throw - throw用在方法体中，手动生成异常对象，throw后面跟的事异常对象 - throws事写在方法声明处的一种异常处理方式，throws后面跟的事异常类型### 包装类- 八种基本数据类型对应的引用类型，包装成类就可以调用类中的方法 - boolean Boolean - char Character - byte Byte - short Short - int Integer - long Long - float Float - double Double- 包装类型和基本类型的转换，以int和Integer为例 - jdk5之前为手动装箱和拆箱 - jdk5之后自动调用valueOf方法 - 在传入-128到127时不会new```javapublic static Integer valueOf(int i) {if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)];return new Integer(i);} 包装类转String类 1234Integer i = 10;String s1 = i.toString();String s2 = String.valueOf(i)String s3 = i + &quot;&quot;; String类转包装类 1234String s1 = &quot;100&quot;;Integer i1 = new Integer(s1);Integer i2 = Integer.valueOf(s1);Integer i3 = Integer.parseInt(s1); 三元运算符是一个整体，会进行整体变量提升 Object obj1 = true?new Integer(1):new Double(1);返回结果为Double 凡事new出来的对象都不相等 字符串String 字符串常量是用双引号括起的字符序列 String是final类，不能被其他的类继承 String类有属性private final char value[];用于存放字符串内容 String对象创建方式：直接赋值，调用构造器 String类的构造器有很多 直接赋值和调用构造器，创建的字符串是有区别的123456String a = &quot;a&quot;;String b = new String(&quot;b&quot;);String c = new String(&quot;a&quot;);System.out.println(a == b);//FSystem.out.println(a.equals(b));//FSystem.out.println(a.equals(c));//T 1234567String a = &quot;hello&quot;;//在常量池中String b = &quot;world&quot;;//在常量池中String c = a+b;//不在常量池中String d = &quot;helloworld&quot;;//在常量池中System.out.println(c == d);//FString e = &quot;hello&quot;+&quot;world&quot;;//在常量池中System.out.println(d == e);//T 12345678910111213141516public class demo1 { @SuppressWarnings({&quot;all&quot;}) public static void main(String[] args){ String str = new String(&quot;hello&quot;); final char[] ch = {'h', 'e','l', 'l', 'o'}; change(str, ch);//值传递不会改变原来的值，引用传递会改变 System.out.println(str); System.out.println(ch);} public static void change(String str,char ch[]){ str = &quot;world&quot;; ch[0] = 'w'; } }//hello//wello 字符串编码 原先字符串是显示正常的，输出时是乱码，排除加密的可能，那就是编码的问题 字符串的字符在内存中使用的是unicode编码，一个字符占两个字节，在进行显示输出时会转化成其他编码123456789101112131415161718192021import java.nio.charset.StandardCharsets;import com.sun.org.apache.xerces.internal.impl.dv.util.HexBin;import java.util.Arrays;public class demo1 { @SuppressWarnings({&quot;all&quot;}) public static void main(String[] args){ String str_iso = new String(&quot;你好123&quot;.getBytes(StandardCharsets.UTF_8), StandardCharsets.ISO_8859_1); String str_utf8 = new String(str_iso.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8); System.out.println(str_iso);//ä½ å¥½123 System.out.println(str_utf8);//你好123 byte[] iso_bytes = str_iso.getBytes(StandardCharsets.ISO_8859_1); byte[] utf8_bytes = str_utf8.getBytes(StandardCharsets.UTF_8); System.out.println(Arrays.toString(iso_bytes));//[-28, -67, -96, -27, -91, -67, 49, 50, 51] System.out.println(Arrays.toString(utf8_bytes));//[-28, -67, -96, -27, -91, -67, 49, 50, 51] String HexEncoding = HexBin.encode(utf8_bytes); System.out.println(HexEncoding);//E4BDA0E5A5BD313233 byte[] HexDecoding = HexBin.decode(HexEncoding); System.out.println(Arrays.toString(HexDecoding));//[-28, -67, -96, -27, -91, -67, 49, 50, 51]} } StringBuffer String 不可变字符序列，效率低，复用率高，在常量池 StringBuffer可变字符序列，效率高，加锁线程安全，在堆中 只会new一次 是一个final类，不能被继承 父类是AbstractStringBuilder AbstractStringBuilder有属性char[] value;存放字符串内容，放在堆中 StringBuilder 可变字符序列，效率最高，线程不安全，在堆中 方法 append,toString,delete,replace,indexOf,insert,length,reverse String 和 StringBuffer 转化 123456StringBuffer stringBuffer = new StringBuffer(&quot;hello world&quot;);stringBuffer.append(&quot;nihao&quot;);String s = stringBuffer.toString();String ss = new String(stringBuffer);System.out.println(s);System.out.println(ss); Arrays 中的静态方法123456789101112int[] i = new int[]{1,2,3,4,5,6,7};Arrays.sort(i);//从大到小排序Arrays.toString(i);//转换为字符串// 拷贝int[] j = Arrays.copyOf(i, i.length);System.arraycopy(i, 0, j, 0, i.length);// 数组转换为listList&lt;int[]&gt; k = Arrays.asList(i);//填充Arrays.fill(j, 2, 3, 100);//二分查找System.out.println(Arrays.binarySearch(i,1)); System方法1234System.exit(0);//退出程序System.arraycopy(s, 0, s, 0, 0);//复制数组System.currentTimeMillis();//返回时间戳System.gc(); //run垃圾回收机制","link":"/2023/10/23/java9/"},{"title":"JavaScript基础（一）","text":"数据类型 操作符 显示输出 数据类型数据类型 值类型 String Number Boolean （true,false） Null Undefined 表示这个变量不含有值 Symbol（ES6：表示独一无二的值） 对象类型（引用数据类型） Object {} Array [] Function {} RegExp（正则） Date 使用 typeof 查看类型 声明新的变量时可以使用new &lt;变量类型&gt; 类型隐式转换 +- 转换为Number，如果无法转换返回NaN +- 字符串时 强制转换为字符串拼接 &gt;&lt; 比较时非数值转换为数值，字符串比较时转换为Unicode编码 常量 使用const const a = 0; 命名：大驼峰AppleApple 小驼峰appleApple 下划线apple_Apple 区分小写 Myfunction != myFunction 常数 Number 0123 字符串 String ‘a’ “ab” ‘asd’ 数组 Array [1,2,3,’a’,’’bsda] 对象 Object {name:adb,age:123} 函数 Function function myfn(a,b){} 变量 使用var声明1234var length = 6var length1 = 6,length2 = 6,length3 = '6'var length4 //未赋值的变量默认为undefined//允许重复声明后声明的覆盖前面的 let和var区别 let是ES6新增的语法声明变量作用在块级作用域 let 声明的变量不会提前，var会提前作用在整个window let不能重复定义 操作符 + - * / = ==(比较时先转换类似后比较) ===(全等包括数据类型) != 不等 &lt; &gt; &lt;&lt; &gt;&gt; 位运算 &amp;&amp; || 有0则0，有1则1 ?? 和 || 的用法相同，都是前后是值，中间用符号连接，根据前面的值来判断最终是返回前面的值还是后面的值 One ?? Two 使用 ?? 时，只有One为 null 或者 undefined 时才会返回 two; One || Two 使用 || 时，One会先转化为布尔值判断，为true时返回One , false 返回Two NaN 不等于 NaN 三元运算符 表达式1？表达式2:表达式3 表达式1成立返回2，否则返回3 特殊错误 12345let age = 100;// 写法有问题但不会报错let retval = 10 &lt; age &lt; 50;console.log(retval);结果为true 显示输出 浏览器环境 window.alert(‘弹出警告框’); document.write() console.log() innerHTML document.getElementById(‘demo’).innerHTML = ‘nihao’ //向id为demo的Html元素输出nihao","link":"/2023/10/26/js1/"},{"title":"JavaScript基础（二）","text":"分支结构 函数 分支结构if 同绝大数语言的if结构 if后如果只有一句可以省略{} 1234567const a = 2;if (a===3){ console.log('yes');}else { console.log('no')} switch 对比if，switch没法做区间判断 case 用于选择，case在做比较的时候进行===的比较不做类型转换。 switch case后要加break，不然会发生穿透效应 case语句顺序无所谓 default 用于没有case匹配的结果 case 结果类型可以是string number boolean object array 1234567891011121314const a = 8;switch (a) { case 1: console.log(1); break; case 2: console.log(2); break; case 3: console.log(3); break; default: console.log(4)} 循环结构while while先判断后循环12345let a = 8;while (a){ console.log(a); a--;} do…while先循环一边再判断12345let a = 8;do{ console.log(a); a--;}while (a) for123456- for(变量初始化;循环条件表达式;循环后操作)- ';'不能省略，条件可以写到别处- 循环条会转换为booleanfor(let i = 0;i&lt;10;i++){ console.log(i);} 数组遍历使用 for in for of 结束循环关键字 break 跳出当前循环 continue 跳过本次循环 return 跳出整个函数返回一个任意类型的值（也可以什么都不返回） 函数函数定义方式 函数声明1function fu(){} 函数表达式1const fn1 = function(){} 箭头函数1const fn2 = ()=&gt;{} 在（）内传参，只有一个时可以省略括号 返回值const fn2 = ()=&gt;a+b 只有函数声明可以提前，其他不能提前。 函数参数 形参 形式上的参数，写在定义函数时 实参 实际传入的参数，写在调用时 默认值 一般指定最后一个参数默认值 function fu(a,b=100){} 没有对应参数传入时使用默认值 a为undefined b为100 传参数量 实参多于形参，多余的不会使用 形参多于实参，多余的按照默认undefined 函数返回值 return 单独使用跳出循环结束函数 后根返回值（任意类型）只能有一个 返回多个返回值，先放入数组或对象中再返回 匿名函数 定义 1let fn = function(){} 作用 赋值给变量、赋值给对象的属性 作为参数传入函数，类似回调函数 作为返回值返回 作为命名空间，定义完直接调用 调用三种方式 匿名函数如果不赋值给变量，也不作为返回值或者参数传入，则必须在声明时直接调用，且只能调用一次。 一般使用时用前两中方式调用 12345678function fn1(){var a = 1;} fn1();//调用三种方式//加个（）表示调用;(function(){})();;(function(){}());!function(){}();//传参!function(a,b){console.log(a+b);}(100,200); 作用域 全局作用域 不包含在任何函数内部的代码，都在全局作用域中 全局作用域在程序启动时创建，程序结束时销毁 定义在全局作用域中的变量，就是全局变量，在任何地方都能访问它 函数作用域 定义在函数作用域的变量参数就是局部变量，函数外不能访问 函数作用域在调用函数时创建，函数执行完毕时销毁 每调用一次函数就会创建一个新的作用域，相互独立 没有以关键词定义的变量，在任何位置都是全局变量，不建议不写关键词去定义全局变量 在函数中还可以定义函数 使用函数声明方式定义的函数，没有块级作用域，会声明提前到作用域开始处 使用var来接收函数或箭头函数，该函数没有块级作用域 使用let来接收函数或箭头函数，该函数具有块级作用域 块级作用域 指作用域范围在局部代码块中 使用let声明变量 块级作用域可以嵌套在全局作用域、函数作用域或者其他块级作用域中 作用域链 函数嵌套时，各个作用域嵌套为一条作用域链，访问变量时先在当前作用域找，找不到就去上一级找 同一个作用域中let不能重名，使用var可以重名（本质是修改同一个变量）","link":"/2023/10/26/js2/"},{"title":"JavaScript基础（三）","text":"对象Object window对象 Object 对象的创建123let obj = new Object();let obj = Object();let obj = {};//隐式创建 对象属性的相关操作 对象中可以存储各种类型数据，对象中存储的数据称为属性。1234567891011//对象属性的创建obj.name = 'abc';obj.age = 2;//对象的属性可以随时创建，并且前面不能加let/var//对象属性的访问let nn = obj.name;//对象属性的修改obj.name = 'def';//对象属性的删除delete obj.name; 属性的两种访问方式12345678//点语法访问obl.name = &quot;nihao&quot;;//中括号访问obj[&quot;name&quot;] = &quot;nihao&quot;;let a = 'y';obj[&quot;x&quot;+a]=&quot;nihao&quot;;//中括号访问时，属性名就是个字符串，因此可以拼接//属性名与关键字重名，需要使用上述方式定义，否则在IE6，7引擎上会报错 使用symbol作为属性名12345678//使用Symbol()创建唯一标识，可以用来防止冲突//每次创建的都不一样，因此创建时需要赋值给变量保存，否则后续无法访问let s1 = Symbol();let s2 = Symbol();obj[s1] = 100;obj[s2] = 200;console.log(obj,obj[s1],obj[s2]);//使用symbol作为属性名无法被遍历 属性的值可以是任意的，也可以是一个对象123456let obj ={};obj.xxx = 100;obj.yyy = {};obj.yyy.zzz = 200;//检查对象中是否包含某个属性console.log(&quot;name&quot; in obj); 对象字面量12345//结构：{属性名：属性值，属性名：属性值}let obj = {x:1,y:1};let obj2 ={&quot;x&quot;:1,&quot;y&quot;:2};//两个一样的console.log(obj,obj2); 对象属性的遍历 for in123456let obj = {x:1,y:1};let i = 0;for(i in obj){ console.log(i);};//不是所有属性都可以变量，使用符号作为属性名的属性，属性描述符设置为不可枚举的属性（symbol） 对象的方法123456789101112131415//函数以赋值的形式给对象时，通常将该函数称为对象方法//定义obj.test = function(a,b){ console.log(a+b);};//调用obj.test(100,100);function fn(){};let obj = { //三种写法 test:function(){}, //ES6简写 fn, abc(){}} 对象的解构1234567891011121314//对象解构：其实就是利用 JS 解构赋值的特性，使用与对象匹配的结构来实现对象的属性赋值（即将对象的属性值提取出来）let obj ={name:&quot;nihao&quot;,age:40};//分开写let name,age;({name,age}=obj);let {name,age} = obj;console.log(name,age);//nihao 40//解构使用的变量名与属性名不一致时使用如下写法let {name:a,age:b} = obj;console.log(a,b);//nihao 40 对象作为函数参数 传参机制 原始类型（值传递）：形参的任何改变不影响实参 对象类型（引用传递）：对形参指向的对象进行改变，会影响实参 1234567function test(obj){ obj.name=&quot;buhao&quot;;};let obj1 = {name:&quot;nihao&quot;};test(obj1);console.log(obj1);//{ name: 'buhao' } 1234567//对象作为函数返回值function test(){ return{x:100,y:200};};console.log(test().x);console.log(test().y); window对象window对象 浏览器提供的一个全局对象，可以直接访问 window对象代表的是浏览器窗口，通过该对象可以对浏览器窗口进行各种操作 window对象还存储Js中的内置对象和浏览器的宿主对象 window对象的属性可以通过window对象访问，也可以直接访问 在浏览器环境中，window就是全局对象 在浏览器环境中的全局作用域中，可以使用this引用window 全局对象的特点 在全局作用域中，var声明的变量（不使用关键字声明），function声明的函数都是全局对象的属性和方法 在全局作用域中，使用let声明变量，不会存在window中","link":"/2023/10/26/js3/"},{"title":"JavaScript基础（四）","text":"globalThis this call方法，apply方法 bind方法 严格模式 globalThis 在window环境中全局对象为this 在nodejs环境中全局对象为global，this指代空对象 在V8引擎中全局对象为this globalThis：提供一个标准的方式来获取不同环境下的全局对象 this 在全局作用域中引用this，this是全局对象 以函数形式调用，this是全局对象 以方法形式调用，this是调用方法的对象 箭头函数没有自己的this，由外层作用域决定，无法通过call，apply，bind修改this，对象的方法、事件回调一般不使用箭头函数 通过call和apply调用的函数，第0个参数就是this（无法修改） 构造函数中this是新建的对象 call方法，apply方法 bind方法 作用：调用函数 xxx.call() xxx.apply() call和apply的第0个参数就是函数中this call的第一个参数是可变参数，可以将函数的实参一个个传递进去 apply的第一个参数是数组，可以将函数的实参放入数组后传递 bind方法创建一个新函数 bind可以为新函数绑定this 改变this指向 12345function fn(a,b){console.log(this,a,b);};//此时this为windowfn(100,200);let obj = {xxx:100};let newFn = fn.bind(obj);//此时this为objnewFn(300,400); 12let newFn = fn.bind(obj,100);//可以绑定第0个参数newFn(400);//前面绑定了参数只要传一个就行 严格模式 在代码签名加一行 &quot;use strict&quot; 变量声明不可以没有关键字 this 在全局作用域中指代window function函数中this，以函数形式调用，this为indefined function函数中this，以方法形式调用，谁调用它this就指代谁 隐藏属性方法全局调用123456789101112131415161718192021222324252627//全局作用域内可以访问test函数（不可以使a和test暴露在全局作用域中）(function(){ let a = 5; function test(){ console.log(a); }})();//第一种let _test;(function(){ let a = 5; function test(){ console.log(a); } _test = test;})();_test();//第二种let _test = (function(){ let a = 5; function test(){ console.log(a); } return test;})();_test(); 123456789101112131415161718192021222324252627282930313233//全局作用域内可以访问a和test函数（不可以使a和test暴露在全局作用域中）(function(){ let a = 5; function test(){ console.log(a); }})();//第一种使用objlet obj ={};//或者直接用window var window = globalThis；(function(){ let a = 5; function test(){ console.log(a);}obj.num = a;obj._test = test})();console.log(obj.num);obj._test();//第二种let obj = (function(){ let a = 5; function test(){ console.log(a);}return{ a:a, test:test}})();console.log(obj.a);obj.test();","link":"/2023/10/26/js4/"},{"title":"JavaScript基础（五）","text":"类，类的属性和方法 类 为什么需要类 使用Object创建对象，无法区分出不同类型的对象 使用Object创建对象，不方便批量创建对象 类的作用 类是对象模版，可以将对象中的属性和方法定义在类中 通过类来创建对象，创建出来的对象自动拥有类中的属性和方法，无需额外赋值 类的声明 class Person{} const Person = class {} 通过类创建对象 new Person(); new Person; 使用instanceof来检查一个对象是否由某个类创建 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 123let Dog = class{};let dog = new Dog;console.log(dog instanceof Dog); 类的属性和方法 在类的代码块中，JS以严格模式运行。 属性 12345class Person { name;//实例属性，通过对象来访问，每个对象都有一份 age = 20;//可以指代默认值 static abc = 100;//静态属性/类属性，通过类来访问} 方法 123456789101112131415class Person { name=&quot;nihao&quot;; test = function(){ console.log(this); console.log(this.name); };//实例方法，通过实例调用，this指代当前实例 static fn2(){ console.log(this);//打印这个this指向 console.log(this.name);//打印这个类名 };//类方法，通过类来调用，this指代当前类 }let a = new Person();a.test();Person.fn2(); 1234Person { name: 'nihao', test: [Function: test] }nihao[class Person]Person 构造函数1234567891011class Person { name;age;//可以省略 constructor(name,age){//可以不传参 this.name = name; this.age = age; //this指代创建出来的新对象 //不用写返回值，写了也没有用 //构造函数有且只有一个 }}const p1 = new Person(&quot;nihao&quot;,15);","link":"/2024/01/18/js5/"},{"title":"JavaScript基础（六）","text":"类的三大特性 封装 对象就像是一个用来存储不同属性的容器 数据直接赋值给对象的属性，并不安全，对象创建后可以被任意修改 将属性私有化，提供getter，setter方法操作属性，对传入的值进行检查或者控制属性读写权限 12345678910111213141516171819class Person{ #name;#age; //私有属性必须先声明，不可省略 constructor(name,age){ this.#name = name; this.#age = age; } getname(){ return this.#name; } setname(name){ this.#name = name; }}const p1 = new Person(&quot;nihao&quot;,23);console.log(p1.name);//私有属性不可访问console.log(p1.getname());//使用getname方法获取属性p1.setname(&quot;buhao&quot;);console.log(p1.getname()); 继承 继承可以提高代码复用性，避免书写很多重复的代码 1234567891011121314class Person{ #name;#age; //私有属性必须先声明，不可省略 constructor(name,age){ this.#name = name; this.#age = age; } getname(){ return this.#name; }}class Teacher extends Person{};class Student extends Person{}; 重写Object的toString方法 Object是所有类的基类，任何类都会继承Object，因此任何类都可以使用Object类里的方法 每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中 type 是对象的类型。 方法的重写/覆盖 子类使用同名方法重写父类方法，重写后调用的就是自类自己的方法 super super代表父类对象的引用，用于访问父类对象的实例方法、构造方法 在类内部，可以通过this.xxx访问自身实例方法 在类内部，可以通过super.xxx访问父类实例方法 使用super访问方法，如果父类没有则会像爷爷类找 在类内外都可以通过 类名.xxx访问静态方法 重写构造函数 重写构造函数时，第一行代码必须是super(),否则无法创建父类对象 多态 多态就是指同一个方法，由于对象不同会有不同的行为 1234567891011class Demo { sayHello(){console.log(&quot;nihao&quot;);}}class Test extends Demo{ sayHello(){console.log(&quot;buhao&quot;);}}function abc(obj){ obj.sayHello();}abc(new Demo);abc(new Test); 多态主要体现在灵活，传入对象需要类型一致，Js解释器不做类型检查，任意类型都可以作为实参传入，Js中需要自己做额外检查。 123456789function abc(obj){ obj &amp;&amp; obj.sayHello &amp;&amp; obj.sayHello();}function abc(obj){ if(obj instanceof Demo){ obj.sayHello(); }}","link":"/2024/01/18/js6/"},{"title":"JavaScript基础（七）","text":"原型对象，原型链，旧类 原型对象 作用：每次实例化一个对象都要新开辟空间创建方法，将这些方法定义在原型链上，就不用开辟新空间。新创建的对象原型都是一致的，直接调用原型对象上的即可。 调用 实例名.proto Object.getPrototypeOf(obj) 类名.prototype 对象中储存属性的区域 自身 obj.xxx 添加属性 类中：xxx =y 添加属性 原型对象 类中通过xxx(){} 添加方法 原型链 最终都指向null demo.__protp__.__protp__.__protp__.__protp__ 使用demo.prototype 查看原型类型 旧类 ES6以前，如果直接调用xxx（），就是一个普通函数，如果通过new xxx（），就是一个构造函数。 类的定义 12345function People(name){this.name = name}//构造函数中可以添加自身函数People.prototype.xxx =function(){}//原型对象中添加方法,实例调用People.xxx = xxx;//类上添加静态属性People.xxxx = function(){}//类上添加静态方法let p1 = new People(); 类的继承 1234function Animal(){}function People(){}People.prototype = new Animal();let p1 = new People();","link":"/2024/01/18/js7/"},{"title":"Js密码学(一)","text":"介绍常见的编码方式。使用CryptoJS包进行Hex，Base64编码操作。 编码方式 ASCII 128个字符，每个占1个字节 UTF8 字母数字1个字节，汉字3-4个字节 Unicode 字母数字汉字都2个字节 GBK 字母1个字节，汉字2个字节 ANSI win通用字符，根据地区不同改变 Hex 密钥和密文的编码 用0123456789abcdef表示 可以进行修改 4个bit位对应一个字符，2个十六进制字符代表一个字节 ，结果原文2倍 URL 本质是Hex编码，在每一个字节前面加了% 主要是对汉字进行编码 一个汉字转换为%xx%xx%xx Base64 用64个字符表示任意二进制数据 6个bit位对应一个字符，结果比原文多1/3 RSA密钥，图片，密文 为了数据传输安全，通常会将Base64数据进行URL编码，或将+/替换位-_（+服务器接收到后会变成一个空格） A-Z a-z 0-9 +/ 共64 Hex编码 utf8转Hex后长度变为两倍123456789//导文件let CryptoJS = require('./CryptoJS');//不能直接传string 要转换为wordArray//每四个字符转换为wrods中一个数字let ninao = CryptoJS.enc.Utf8.parse('nihaonihao');console.log(ninao)console.log(CryptoJS.enc.Hex.stringify(ninao))//还原 tostring默认hex编码，可以指定为utf8console.log(CryptoJS.enc.Hex.parse('6e6968616f6e6968616f').toString(CryptoJS.enc.Utf8)); Base64编码 utf8转base64 大概5/812345678//hex和b64编码之间的转换都要先转换位wordArray，再进行编码let CryptoJS = require('./CryptoJS');let nihao_wordArray = CryptoJS.enc.Utf8.parse('nihaonihao');let nihao_b64 = CryptoJS.enc.Base64.stringify(nihao_wordArray)console.log(nihao_b64);let nihao_wordArray2 = CryptoJS.enc.Base64.parse(nihao_b64);let nihao_hex = CryptoJS.enc.Hex.stringify(nihao_wordArray);console.log(nihao_hex);","link":"/2023/08/01/jsencrypt1/"},{"title":"Js密码学(二)","text":"介绍消息摘要算法,MD5，SHA，HMAC（MD5，SHA）SM3使用。 消息摘要算法 MD5 SHA1，256，512 HmacMD5 HmacSHA1 HmacSHA256 HmacSHA512 RIPEMD160 HmacRIPEMD160 PBKDF2 EvpKDF SM3 单向散列，哈希算法（rename） 输入长度不固定，输出长度固定，密文不可逆 散列后结果唯一（绝大多数）（MD5，sh1有这问题） 用于校验数据完整性，签名 MD5 SHA MD5 散列后为16个字节，转换为Hex后为32个字符 输入无限长度 1234567let CryptoJS = require('./CryptoJS');//直接用，可以转换为wordArray也可以不转换let nihao_MD5 = CryptoJS.MD5('nihaonihao');//默认输出Hexconsole.log(nihao_MD5+ '');//转Base64console.log(nihao_MD5.toString(CryptoJS.enc.Base64)); SHA sha1散列后为20个字节，转换为Hex后为40个字符 sha1，sha2输入为有限长度 sha3输入为无限长度1234let CryptoJS = require('./CryptoJS');let wordArray = CryptoJS.enc.Utf8.parse('nihaonihao');console.log(CryptoJS.SHA1(wordArray)+'');console.log(CryptoJS.SHA256(wordArray)+''); 1234567891011 //第二种写法//创建一个MD5或SHA，压入数据，加密let md5 = CryptoJS.algo.MD5.create();md5.update('nihaonihao');//分段压入md5.update('nihao');//清空压入数据md5.reset();md5.update('nihao');let cipherText = md5.finalize()+'';console.log(cipherText); HMAC 多了个密钥 密文长度和对应的MD5，SHA一致 123456let CryptoJS = require('./CryptoJS');//默认Hex编码console.log(CryptoJS.HmacMD5('nihao','key')+'');console.log(CryptoJS.HmacSHA1('nihao','key')+'');//转Base64console.log(CryptoJS.HmacSHA1('nihao','key').toString(CryptoJS.enc.Base64)); 1234//第二种写法let hmacSHA1 = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA1.create(),'key');hmacSHA1.update('nihao');console.log(hmacSHA1.finalize()+'') SM3类似于SHA256算法密文长度32个字节，hex编码后64导入sm3文件 1234567//这一步是先将输入数据转成utf-8编码的字节流，然后再转成16进制可见字符var dataBy = Hex.utf8StrToBytes('nihao');var sm3 = new SM3Digest();sm3.update(dataBy,0,dataBy.length); //数据很多的话，可以分多次updatevar sm3Hash = sm3.doFinal(); //得到的数据是个byte数组var sm3HashHex = Hex.encode(sm3Hash,0,sm3Hash.length); //编码成16进制可见字符console.log(sm3HashHex);","link":"/2023/08/01/jsencrypt2/"},{"title":"Js密码学(三)","text":"介绍对称加密算法，DES，3DES，AES，SM4的使用，以及加密模式和填充方式。 对称加密算法 DES，3DES，AES，SM4 加密解密使用相同密钥 可以还原 加密方式（密钥位数） 序列加密 RCA 1-256字节 分组加密 DES 8字节 3DES 24字节 AES 16 24 32字节 SM4 16字节 加密模式和填充方式 加密模式 ECB模式 8个字符加密一次，再拼接起来 CBC模式（包括一个iv向量） 前8个字符和iv异或一次再加密，再和下一段异或，最后拼接起来 填充方式 填充的是字节不是字符，再不满足一个分组时填充满一个分组，刚好满一个分组时在填充一个分组 NoPaddding PKcs7（5） DES 密钥长度64bit 分组长度64bit 实际使用的56个字节 每一个密钥转换为8bit的最后一位不用 1234567891011121314151617181920212223let CryptoJS = require('./CryptoJS');let text = CryptoJS.enc.Utf8.parse('nihao');let key = CryptoJS.enc.Utf8.parse('12345678');let iv = CryptoJS.enc.Utf8.parse('12345678');//没有传cfg默认使用CBC模式Pkcs7填充var cfg ={ iv:iv, //ECB不用iv mode:CryptoJS.mode.CBC, //mode:CryptoJS.mode.ECB, padding:CryptoJS.pad.Pkcs7};let cipherObj = CryptoJS.DES.encrypt(text,key,cfg);console.log(cipherObj.toString())//Base64console.log(cipherObj.ciphertext.toString())//Hex// 9bb1965d9e71548c//解密 只能接受Base64数据let en_text = CryptoJS.enc.Hex.parse('9bb1965d9e71548c').toString(CryptoJS.enc.Base64);let cipherobj = CryptoJS.DES.decrypt(en_text,key,cfg).toString(CryptoJS.enc.Utf8);console.log(cipherobj); 3DES 密钥 24位 前八位加密，中间八位解码，后八位加密 使用方法和DES一样 把DES替换为TrioleDES AES 密钥长度不同 AES128， AES192，AES156 iv长度128位 使用方和DES一样改一下key和iv format和自动生成key iv format 密文/明文的自定义输出（cfg种指定format） CryptoJS自动生成key iv salt ，不需要传iv，cfg，只需要传key，他会自动生成iv 每次生成的key iv salt 均不同 12345678910111213let CryptoJS = require('./CryptoJS');//加密let cipherObj = CryptoJS.AES.encrypt('nihao','12345678');console.log(cipherObj);let cipherText = cipherObj.toString();console.log(cipherText);console.log(cipherObj.key.toString());console.log(cipherObj.iv.toString());console.log(cipherObj.salt.toString());//解密let plainObj = CryptoJS.AES.decrypt(cipherText,'12345678');console.log(plainObj.toString(CryptoJS.enc.Utf8)); SM4 国密算法 密钥128位16字节 使用SM4文件调用SM4算法 123456789101112131415161718function sm4_encrypt_ecb() { let inputBytes = Hex.decode('0123456789abcdeffedcba9876543210'); let key = Hex.decode('0123456789abcdeffedcba9876543210'); let sm4 = new SM4(); let cipher = sm4.encrypt_ecb(key, inputBytes); console.log(Hex.encode(cipher, 0, cipher.length));}function sm4_encrypt_cbc() { let inputBytes = Hex.decode('0123456789abcdeffedcba9876543210'); let key = Hex.decode('0123456789abcdeffedcba9876543210'); let iv = Hex.decode('0123456789abcdeffedcba9876543210'); let sm4 = new SM4(); let cipher = sm4.encrypt_cbc(key, iv, inputBytes); console.log(Hex.encode(cipher, 0, cipher.length));}sm4_encrypt_ecb();sm4_encrypt_cbc(); 其他算法 RIPEMD160 and HmacRIPEMD160(多个密钥) PBKDF2 文本 密钥 keySize iterations（迭代次数） EvpKDF 同上 RC4 RC4Drop 同AES Rabbit RabbitLegacy 流密码","link":"/2023/08/01/jsencrypt3/"},{"title":"Js密码学(四)","text":"介绍非对称加密算法，RSA，SM2和数字加密算法库的使用。 非对称加密算法 RSA SM2 加密解密使用不同密钥的算法 用于加密比较短的数据 公钥和私钥成对生成 公钥加密私钥解密，私钥加密公钥解密 常用1024位，2048位 私钥内包含公钥 密钥格式 PKCS1格式的密钥 前缀 —–BEGIN RSA PRIVATE KEY—– 后缀 —–END RSA PRIVATE KEY—– PKCS8格式的密钥 前缀 —–BEGIN PRIVATE KEY—– 后缀 —–END PRIVATE KEY—– 填充方式 PKCS1Padding 明文最大字节数为密钥字节数-11 密文和密钥是等长的 每次填充不一样结果不一样 NOPadding 明文最大字节数为密钥字节数 密文和密钥是等长的 填充字节为0，加密后密文不变 RSA加密库使用 使用jsencrypt.js文件 使用python可以生成公钥和私钥1234567891011121314151617function getEncrypt(password, publickey){ //实例化一个JSEncrypt对象 var jsEncrypt = new JSEncrypt(); //调用setPublicKey设置公钥 jsEncrypt.setPublicKey(publickey); //调用encrypt方法加密明文 return jsEncrypt.encrypt(password);}var publicKeyBase64 = &quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDxRQHxL/8xZ1EaNmQBGZnpMiCY&quot; + &quot;7gRzog6nDjfBJacytEiVJnJRuq1V/D+JKaXDwetsCnSUaz65LCFHU09OSEYee5oC&quot; + &quot;iI0ql21EA306c91oT/fQpPngQGZHLUtDOUdJVlAKnicCvmR24NqyNKFuY8L0cnB1&quot; + &quot;zcax73Rf+Ctf/lxAOwIDAQAB&quot;;console.log(getEncrypt(&quot;nihaonihaonihaonihaonihaonihaonihaonihaonihaonihaonihaonihaonihao&quot;, publicKeyBase64));//采用PKCS1Padding填充，每次填充不同，结果会变化 返回的是Base64编码的结果 使用RSA.js文件 12345678910111213let password = 'a12345678';function test(password) { setMaxDigits(129); //传入加密指数和加密模数，中间一般没有 var key_to_encode = new RSAKeyPair(&quot;010001&quot;, &quot;&quot;, &quot;978C0A92D2173439707498F0944AA476B1B62595877DD6FA87F6E2AC6DCB3D0BF0B82857439C99B5091192BC134889DFF6&quot;\\ &quot;0C562EC54EFBA4FF2F9D55ADBCCEA4A2FBA80CB398ED501280A007C83AF30C3D1A142D6133C63012B90AB26AC60C898FB6&quot;\\ &quot;6EDC3192C3EC4FF66925A64003B72496099F4F09A9FB72A2CF9E4D770C41&quot;); //传入密钥和明文返回Hex编码的结果动态变化 return encryptedString(key_to_encode, password);}console.log(test(password)); SM2算法库 sm2Test.html vscode安装live serve 右下角Go live运行html文件 数字加密算法（多种算法结合） 随机生成AES密钥AESKey AESKey密钥用于AES加密数据，得到数据密文cipherText 使用RSA对AESKey加密，得到密钥密文cipherKey 提交密钥密文cipherKey和数据密文cipherText给服务器 使用数字加密算法库jsshuziqianming.js1234567891011121314var signData = &quot;nihao&quot;;//PKCS1格式的密钥 前缀 -----BEGIN RSA PRIVATE KEY----- 后缀 -----END RSA PRIVATE KEY-----//PKCS8格式的密钥 前缀 -----BEGIN PRIVATE KEY----- 后缀 -----END PRIVATE KEY-----//必须将完整的密钥传入告诉他是那种密钥格式var privateKeyBase64 = &quot;-----BEGIN PRIVATE KEY-----MIICdwIBADANBgkq&quot; + &quot;此处省略密钥内容&quot;+ &quot;FAmhvYQwwLnifrw=-----END PRIVATE KEY-----&quot;;//使用私钥进行签名，结果不变function doSign() { var signature = KEYUTIL.getKey(privateKeyBase64); var hSig = signature.signString(signData, &quot;sha256&quot;);//小写sha256 return hex2b64(hSig);}console.log(doSign());","link":"/2023/08/01/jsencrypt4/"},{"title":"Js逆向分析(一)","text":"一般Js逆向分析调试思路 首先明确需要逆向的数据是什么类型，一般登陆类型的数据大多以login名为首的数据包，而网页内容数据加密往往可以通过下一页等进行请求，观察数据包，找到数据包是第一步。 观察数据包载荷内容和请求方式 载荷内容 多次尝试对比各个数据变化情况 有部分数据被藏在html页面中 有部分数据是每次请求新的页面中自带的 部分点击登陆前要验证码，验证码验证成功后会产生一个新的数据在点击登陆时一起提交 sign加密算法 token一般是在前面验证码post请求后返回的 请求方式 xhr 下xhr断点，查看调用堆栈，一个一个往前找 点击启动器找可疑的程序（xhr启动器的第一个一般都是sent()不用考虑） 部分提交后密码框会将加密的数据再次提交到密码框，可以在密码框照绑定事件 document 在页面中找点击登陆或者密码框元素进行检查，找到绑定事件，进行搜索 找登陆，密码框元素的id进行全局搜索下断点 搜submit( script 点击启动器找可疑的程序 找到加密代码处理 扒加密代码进行改写 加密代码不一定都在一个文件中，有可能吧部分拆了放在其他文件中，通过单步调试可以找到 如果加密代码中明显定义了4个10字符的数，大概率是hash算法 改写匿名函数，导出全局接口 rsa加密方式，找实例对象函数，设置公钥函数，加密函数一般在一起 使用本地加密包 加密和解密 加密数据在sent()函数之前找 解密函数在sent()函数之后找 注意传入数据的编码格式是Hex还是Base42，也可能是wordArray","link":"/2024/01/18/jsfx/"},{"title":"Js混淆(一)","text":"常见混淆手法，编码混淆、异或混淆、数组混淆 利用Js调用函数的两种形式12console.log(&quot;hello world&quot;);console['log'](&quot;hello world&quot;); 将字符串使用十六进制编码表示12345678910function hexEnc(code){ for(var hexStr = [],i=0,s;i&lt;code.length;i++){ s = code.charCodeAt(i).toString(16); hexStr += &quot;\\\\x&quot;+s; } return hexStr;}console.log(hexEnc('log'));// \\x6c\\x6f\\x67console['\\x6c\\x6f\\x67'](&quot;hello world&quot;); 将字符串使用Unicode编码表示1234567891011function unicodeEnc(str){ var value = ''; for (var i = 0; i &lt; str.length; i++){ value += '\\\\u' + (&quot;0000&quot; + parseInt(str.charCodeAt(i)).toString(16)).substr(-4); } return value;}console.log(unicodeEnc('console'));// \\u0063\\u006f\\u006e\\u0073\\u006f\\u006c\\u0065//console.log(&quot;hello world&quot;);就变成这样了\\u0063\\u006f\\u006e\\u0073\\u006f\\u006c\\u0065['\\x6c\\x6f\\x67'](&quot;hello world&quot;); 将字符串使用ASCII码表示12345678910111213141516171819function stringToByte(str) { var byteArr = []; for(var i = 0; i &lt; str.length; i++) { byteArr.push(str.charCodeAt(i)); } return byteArr;}console.log(stringToByte('console.log(&quot;hello&quot;)'));// [// 99, 111, 110, 115, 111, 108,// 101, 46, 108, 111, 103, 40,// 34, 104, 101, 108, 108, 111,// 34, 41// ]console.log('x'.charCodeAt(0));console.log(String.fromCharCode(120,121));console.log(String.fromCharCode(99, 111, 110, 115, 111, 108,101, 46, 108, 111, 103, 40,34, 104, 101,108, 108, 111,34, 41));//使用eval将代码运行eval(String.fromCharCode(99, 111, 110, 115, 111, 108,101, 46, 108, 111, 103, 40,34, 104, 101,108, 108, 111,34, 41)); 字符串base64加密123456789101112console.log(btoa(&quot;hello&quot;));//aGVsbG8=console.log(atob(&quot;aGVsbG8=&quot;));//字符串拼接console.log(btoa(&quot;hello&quot;));console.log(btoa(&quot;world&quot;));//aGVsbG8=//d29ybGQ=var a = 'aGVsbG8=';var b = 'd29ybGQ=';console.log(atob(a)+atob(b)); 异或加密常量1234console.log(10086^10000);// 118// 当我们要输出10086可以console.log(118^10000); 使用数组进行混淆123var arr = ['console','log','hello','world',118];globalThis[arr[0]][arr[1]](arr[2]+arr[3],arr[4]^10000);//helloworld 10086 打乱数组123456789101112131415161718192021222324252627var arr = ['console','log','hello','world',118];//打乱数组(function(arr,num) { var shuffle = function(num) { while(--num) { arr.unshift(arr.pop()); } }; shuffle(++num);}(arr,0x20));console.log(arr);//还原数组(function(arr,num) { var shuffle = function(num) { while(--num) { arr.push(arr.shift()); } }; shuffle(++num);}(arr,0x20));console.log(arr);globalThis[arr[0]][arr[1]](arr[2]+arr[3],arr[4]^10000);//[ 'world', 118, 'console', 'log', 'hello' ]//[ 'console', 'log', 'hello', 'world', 118 ]//helloworld 10086","link":"/2023/08/21/jshunxiao1/"},{"title":"Js混淆(二)","text":"常见混淆手法，花指令、jsfuck、流程平坦化、逗号表达式混淆、eval处理 花指令 添加一些无用代码123456789var a = 100;var b = 200;function test(a,b){ return func(a,b);}function func(a,b){ return a+b;}console.log(test(a,b)); jsfuck 使用、+！[]表示任意字符 根据()分段放入浏览器中运行测试，再将运行结果进行替换 流程平坦化 使用switch case语句123456789function test(){ var a = 100; var b = a+200; var c = b+300; var d = c+400; var e = d+500; return e;}console.log(test()); 使用switch case改写12345678910111213141516171819202122232425function test2(){var index = 0;while(true){ switch(++index){ case 3: var c = b+300; break; case 1: var a = 100; break; case 5: var e = d+500; break; case 2: var b = a+200; break; case 4: var d = c+400; break; case 6: return e; }}}console.log(test2()); 定义arr数组切割传入switch1234567891011121314151617181920212223242526function test3(){ var arr = 'd|e|q|g|h|c'.split('|'); var index = 0; while(true){ switch(arr[index++]){ case 'q': var c = b+300; break; case 'd': var a = 100; break; case 'h': var e = d+500; break; case 'e': var b = a+200; break; case 'g': var d = c+400; break; case 'c': return e; } }}console.log(test3()); 逗号表达式混淆12345678910function test(a,b,c,d,e){//return 只会返回最后一个表达式的值 return a = 100,b = a+200,c = b+300,d = c+400,e = d+500,e;}console.log(test());function test2(a,b,c,d,e){ return e=(e=(d=(c=(b=(a=100,a+200),b+300),c+400),d+500));}console.log(test2()); return 不光可以返回一个值，还可以返回一个函数 123var a = 100;var b = (b=200,add)(a,b);console.log(b); eval加密 加密字符串放入eval中解密后执行 解密将eval改为console.log就可以了 检测代码是否格式化 原理：利用正则匹配，检测代码是否被格式化，当检测到代码被格式化后进行内存爆破 内存爆破：利用死循环不断写入内存知道内存溢出","link":"/2023/08/22/jshunxiao2/"},{"title":"混淆处理思路","text":"一般混淆处理思路，快速定位关键代码 分析混淆代码12_0x5bd8cd[_0x1bcb4d(0x60d, ')XMs')](_0x3a0095[_0x1bcb4d(0xfb, 'acaL')], _0x304f48[_0x1bcb4d(0x115, 'WwBk')], !![]), _0x5bd8cd['send'](_0x366b73); 将_0x1bcb4d(0x60d, ')XMs')输入控制台得到open 同样的方法处理后就得到 12XMLHttpRequest['open'](&quot;post&quot;, &quot;https://api.superbed.cn/upload&quot;,true);XMLHttpRequest['send'](FormData{}); 处理_0x3a0095加密取值函数中包含大量明文数据 1234567891011121314_0x3a0095 = { &quot;DPbSh&quot;: &quot;上传结束&quot;, &quot;iXJWT&quot;: &quot;/token&quot;, &quot;BkkNb&quot;: &quot;.login&quot;, &quot;KiFgN&quot;: &quot;vggaa&quot;, &quot;RhRik&quot;: &quot;upload&quot;, &quot;sXvtO&quot;: &quot;IGeNd&quot;, &quot;RgDgb&quot;: &quot;LDuyL&quot;, &quot;VBgTQ&quot;: &quot;token&quot;, &quot;ahVPu&quot;: &quot;-*-&quot;, &quot;YFkhX&quot;: &quot;nonce&quot;, &quot;tcFUl&quot;: &quot;sign&quot;, &quot;weBfW&quot;: &quot;_xsrf&quot;} 可以看出它将加密的字符串解密后存入一个对象中，然后根据对象的key获取对应的值 &quot;tcFUl&quot;: &quot;sign&quot; 找到对应的加密字符串 定位到字符串加密函数，在return处下条件断点 根据条件断点进行单步调试找关键加密代码 通过加密字符串全局去找在那使用过下断点 注意关键词CryptoJS、AES、encrypt、decrypt、append…","link":"/2024/01/20/jshunxiao3/"},{"title":"ajax","text":"ajax发送请求,在不刷新网页的情况下发送异步http请求 请求方式 jQuery封装好的get post ajax fetch 浏览器自带的请求方式 axios第三方ajax框架 Jsonp script 进行get跨越请求 缓存，同源策略，与跨域请求 同源策略，不允许跨域请求 用户输入地址，服务端通过 response.sendFile()发送html页面给前端，此时前端和后端同源 跨域请求要在后台设置 response.setHeader(‘Access-Control-Allow-Origin’,’*’); get12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;!--注意最后保存文档时的编码 --&gt; &lt;title&gt;这是标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;let xmlHttpRequest = new XMLHttpRequest();xmlHttpRequest.open(&quot;GET&quot;,&quot;url&quot;);xmlHttpRequest.setRequestHeader('name')xmlHttpRequest.send();//onreadystatechange请求状态变化后调用xmlHttpRequest.onreadystatechange=function(){//0未初始化，1open方法调用完成，2send方法调用完成，3服务器返回部分结果，4服务端返回所有结果if(xmlHttpRequest.readyState===4 &amp;&amp; xmlHttpRequest.status &gt;= 200 &amp;&amp; xmlHttpRequest.status &lt;300){ console.log(xmlHttpRequest.response); console.log(xmlHttpRequest.responseText); console.log(xmlHttpRequest.getAllResponseHeaders()); console.log(xmlHttpRequest.getResponseHeader('content-type'));}}&lt;/script&gt;&lt;/body&gt; &lt;/html&gt; post12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;!--注意最后保存文档时的编码 --&gt; &lt;title&gt;这是标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;let xmlHttpRequest = new XMLHttpRequest();xmlHttpRequest.open(&quot;POST&quot;,&quot;url&quot;);xmlHttpRequest.setRequestHeader('name');xmlHttpRequest.send('data');//onreadystatechange请求状态变化后调用xmlHttpRequest.onreadystatechange=function(){//0未初始化，1open方法调用完成，2send方法调用完成，3服务器返回部分结果，4服务端返回所有结果if(xmlHttpRequest.readyState===4 &amp;&amp; xmlHttpRequest.status &gt;= 200 &amp;&amp; xmlHttpRequest.status &lt;300){ console.log(xmlHttpRequest.response); console.log(xmlHttpRequest.responseText); console.log(xmlHttpRequest.getAllResponseHeaders()); console.log(xmlHttpRequest.getResponseHeader('content-type'));}}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2024/01/16/jsx1/"},{"title":"Promise","text":"解决用于解决连续异步请求导致的回调地狱 then方法 12345678new Promise(function(resolve, reject){ resolve('调用成功时调用第一个函数')// reject('调用失败时调用第二个函数')}).then(function(data){ console.log('success')}).catch(function(err){ console.log('err')}) 三种状态 pending reject fufilled 状态一旦确定就不能更改 状态随着每次调用时Promise改变而改变 实际中看不懂走resolve还是reject可用下断点调试 同一个Promise可以有多个then方法，当resolve被调用时所有的then方法传入的回调函数都会被执行 catch方法可以给每个then方法后面自动加上相同的reject函数 总结请求方式 form表单 ajax —&gt; 原生ajax（不支持跨域请求 ），jQuery封装的ajax，axios fetch Jsonp（原理script 原生支持跨域请求） get.json callback函数处理返回结果","link":"/2024/01/16/jsx2/"},{"title":"Mongodb(一)","text":"Mongodb安装 基本操作 安装 brew tap mongodb/brew brew install mongodb-community 安装信息： 配置文件：**/usr/local/etc/mongod.conf** 日志文件路径：**/usr/local/var/log/mongodb** 数据存放路径：**/usr/local/var/mongodb** brew 启动： 1brew services start mongodb-community 查看http://127.0.0.1:27017/ 显示It looks like you are trying to access MongoDB over HTTP on the native driver port.表示开启 brew 停止： 1brew services stop mongodb-community 一个数据库包含多个集合，一个集合包含多个文档，一个文档为一句JSON键值对 数据类型：null，布尔型，数字，字符串，数组，二进制，日期，代码 基本操作 进入数据库：1mongosh 创建数据库：1use datademo 展示数据库：1show dbs 展示数据库集合：1show collections 删除数据库：1db.dropDatabase() 插入数据：1db.datatest.insert({&quot;name&quot;:&quot;test&quot;}) 插入多条数据：1db.datatest.insertMany([{&quot;name1&quot;:&quot;test1&quot;},{&quot;name2&quot;:&quot;test2&quot;}]) 读取数据：123db.datatest.findOne()db.datatest.find()db.datatest.find().pretty() 美化 更新数据库：12db.datatest.updateOne({&quot;name&quot;:&quot;test&quot;},{$set:{&quot;name&quot;:&quot;test3&quot;}})db.datatest.updateOne(db.datatest.findOne({&quot;name&quot;:&quot;test&quot;}),{$set:{&quot;name&quot;:&quot;test3&quot;}}) 删除数据：1db.datatest.remove({&quot;name&quot;:&quot;test3&quot;}) 删除所有符合条件的数据 删除数据库：1db.datatest.drop()","link":"/2023/11/13/mongo1/"},{"title":"Mongodb(二)","text":"mongodb的ID 特殊查询 pymongo mongodb的ID 每插入一条文档都有一个默认ID，而且必须存在 属于Objectid类型，有12个字节空间，共24个十六进制数字 0 1 2 3 时间戳，提供秒级别的唯一，能够按照时间顺序插入 4 5 6 机器标识符 7 8 不同进程PID 9 10 11 计数器：相同进程累加 mongdb查询 全部返回 1db.datatest.find() 查询条件小于等于5的 lt小于gt大于 1db.datatest.find({_id:{$lt:10}}) 查询条件在1，2，3里面的 1db.datatest.find({_id:{$in:[1,2,3]}}) 查询存在某项条件的 1db.datatest.find({id:{$exists:true}}) 查询显示：0为不显示，1为显示 1db.datatest.find({},{_id:0}) pymongo123456789101112131415161718192021222324252627282930313233343536import pymongo# link to mongodbclient=pymongo.MongoClient(&quot;mongodb://127.0.0.1:27017&quot;)# select databasedb=client['datademo']# select collectioncol=db['test']mydict={&quot;name&quot;:&quot;python&quot;}# insert datares=col.insert_one(mydict)print(res)# insert_many datamylist=[ {&quot;name&quot;:&quot;C++&quot;},{&quot;name&quot;:&quot;Lua&quot;}]# res=col.insert_many(mylist)# print(res)for num,i in enumerate(mylist): i['id']=num col.insert_one(i)# findres=col.find({},{&quot;_id&quot;:0})for r in res: print(r)# updatacol.update_one(mydict,{&quot;$set&quot;:{&quot;name&quot;:&quot;python3&quot;}})# deletecol.delete_many({})","link":"/2023/11/13/mongo2/"},{"title":"异步爬虫使用","text":"异步爬虫爬取图片 异步验证proxy 异步爬虫爬取图片 调用DownloadImage，List形式传入要下载的图片url 对于图片后缀suffix默认jpg 需要其他的再加12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import asyncioimport aiohttpfrom aiohttp import TCPConnectorimport osdef DownloadImage(urls='',address='',suffix='jpg',): async def download_image(url,address,suffix,tmp,): async with aiohttp.ClientSession(connector=TCPConnector(ssl=False)) as session: print('正在下载{}'.format(url)) response = await session.get(url) tmps = str(tmp) if response.status == 200: image_data = await response.read() if address =='': if not os.path.exists('images'): os.makedirs('images') print(&quot;文件夹已成功创建！&quot;) else: pass # 将获取到的图片数据保存为文件 if suffix == 'jpg': file_path = 'images'+'/'+url.split('/')[-1]+tmps+'.jpg' # 设置保存路径及名称 elif suffix == 'png': file_path = 'images'+'/'+url.split('/')[-1]+tmps+'.png' elif suffix == 'jpeg': file_path = 'images'+'/'+url.split('/')[-1]+tmps+'.jpeg' with open(file_path, 'wb') as f: f.write(image_data) print('{}图片已保存'.format(file_path)) else : if not os.path.exists(address): os.makedirs(address) print(&quot;文件夹已成功创建！&quot;) else: pass if suffix == 'jpg': file_path = address + '/'+url.split('/')[-1]+tmps+'.jpg' # 设置保存路径及名称 elif suffix == 'png': file_path = address + '/'+url.split('/')[-1]+tmps+'.png' elif suffix == 'jpeg': file_path = address + '/'+url.split('/')[-1]+tmps+'.jpeg' with open(file_path, 'wb') as f: f.write(image_data) print('{}图片已保存'.format(file_path)) else: print('无法下载图片') # 定义要下载的图片URL列表 urls = urls loop = asyncio.get_event_loop() tasks = [] tmp = 1 for url in urls: task = loop.create_task(download_image(url,address,suffix,tmp)) tasks.append(task) tmp += 1 loop.run_until_complete(asyncio.wait(tasks)) loop.close() 异步验证proxy1234567891011121314151617181920212223def Proxy_test(proxies): tasks = [] enable_proxy = [] test_url = 'https://httpbin.org/ip' async def get_status_code(test_url,my_proxy): async with aiohttp.ClientSession(connector=TCPConnector(ssl=False),) as session: try: response = await session.get(url=test_url,proxy=my_proxy,timeout=10) if response.status == 200: print('{}代理可用'.format(my_proxy)) enable_proxy.append(my_proxy) except: print('{}代理不可用'.format(my_proxy)) pass loop = asyncio.get_event_loop() for my_proxy in proxies: task = loop.create_task(get_status_code(test_url,my_proxy)) tasks.append(task) loop.run_until_complete(asyncio.wait(tasks)) loop.close()","link":"/2024/01/16/myaio/"},{"title":"MySql(一)","text":"MySql在mac上启动不了执行命令 数据库基本用法 MySql启动不了执行命令-sudo chown -RL root:mysql /usr/local/mysql-sudo chown -RL mysql:mysql /usr/local/mysql/data-sudo /usr/local/mysql/support-files/mysql.server start 关闭MySql mysql.server stop mysql -uroot -p 登陆 修改密码为root ALTER USER 'root'@'localhost' IDENTIFIED BY 'root'; 数据库操作 显示数据库mysql&gt; show databases; 创建数据库mysql&gt; create database test1; 使用数据库mysql&gt; use test1; 先使用数据库再展示数据库的表mysql&gt; use test1; 删除数据库mysql&gt; drop database test1; 表操作 创建表 创建表名为user 内有name age date属性mysql&gt; create table user(name varchar(10),age int(2),date date); 查看表格式mysql&gt; desc user; 查看详细描述mysql&gt; show create table user; 修改表 修改 修改name为varchar（20）mysql&gt; alter table user modify name varchar(20); 改名 修改age为age1 int（4）mysql&gt; alter table user change age age1 int(4); 新增 新增test行mysql&gt; alter table user add column test varchar(10); 删除 删除test行mysql&gt; alter table user drop column test; 表名 修改整个表名mysql&gt; alter table user rename user1; 删除表mysql&gt; drop table user;","link":"/2023/10/25/mysql1/"},{"title":"MySql(二)","text":"表操作 数据类型 表操作 插入数据 insert into user1 values(“nihao”,”20”,”2021-01-29”); 向user1插入(“nihao”,”20”,”2021-01-29”) insert into user1(name) values(“buhao”),(“test”); 向user1的name属性插入(“buhao”),(“test”)，其他属性为NULL 查询数据 select * from user1; 查询全部user1数据 select * from user1 where age1=”20”; 查询全部user1数据中age1条件为20的所有数据 select name,age1 from user1; 查找user1数据中所有name，age1的数据 更新数据 update user1 set age1=30 where name=”buhao”; 更新name条件为buhao的数据的age1为30 删除数据 delete from user1 where age1=30; 删除age1条件为30的全部数据 数据类型 tinyint int bigint float double bit int(5)指的是具体宽度显示，插入超过数据宽度不会被截断 默认int宽度为10，使用zerofill 用0填充 alter table t1 modify id2 int(5) zerofill; 如果用int会直接改为10宽度 修改查询bit数据的显示方式，以hex显示，以bin显示 select id3,hex(id3),bin(id3) from t1; 字符串类型 char 0-255 varchar 0-65535 text 0-65535字节 mediumtext 0-167772150字节 longtext 0-4294967295字节 二进制字符串 binary varbinary（大一些） 检索时char会删除尾部空格 length（）计算长度 concat（）查询时连接一个标志 mysql&gt; select length(v1),concat(“biaozhi”) from vc; 日期类型 类型 date 年月日 datetime 年月日时分秒 默认 now() timestamp 年月日时分秒 默认 current_timestamp() time 时分秒 year 年份 插入默认 now() current_timestamp() mysql&gt; insert into dd values(now(),now(),now(),now(),now()); 设置默认 mysql&gt; alter table dd modify d2 datetime default now(); mysql&gt; alter table dd modify d3 timestamp default current_timestamp(); date time year 没有默认值，但是可以自行设置一个固定的默认值方法同上。","link":"/2023/11/07/mysql2/"},{"title":"MySql(三)","text":"存储引擎 MySQL事务 表连接 存储引擎 MySql的存储引擎是插件式的，支持多种引擎 5.0支持 MyISAM InnoDB BDB MEMORY等 InnoDB BDB是事务性安全表 5.5之后默认为InnoDB，之前均为MyISAM mysql&gt; show engines;查看支持引擎 mysql&gt; alter table xx engine=myisam;修改引擎 MyISAM 不支持事务，优点是速度快 如果主要以select，insert为主的可以使用 InnoDB 提供事务（提交，回滚，崩溃恢复） 比MyISAM速度慢，磁盘占用多 MEMORY 使用内存中的数据来建表，数据放在内存中，速度很快，服务关闭时数据丢失 MySQL事务 四大特性 原子性：一个事务中的所有操作，要么全部完成要么全部不完成，出现错误会回滚到事务开始之前。 一致性：在事务开始之前和结束之后，数据库的完整性没有被破坏，表示写入数据必须完全符合所有预设规则。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的操作，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。 持久性：事务结束后，对数据的修改是永久的。 操作 mysql&gt; start transaction; 开启事务 mysql&gt; commit; 提交内容 mysql&gt; rollback; 回滚 mysql&gt; commit and chain; 提交并开启新事务 表锁：进行表锁后只能有一个线程去操作表，其他线程会被阻塞 mysql&gt; lock table xxx write；xxx表的写权限上锁，其他不受影响 mysql&gt; unlock tables; 解锁 表连接 通常多个表之间的数据会有联系，同时选择多个关联的表 内连接：选出两张表中相匹配的记录，本质上是找两个表的相同部分 select xxx,xxx,xxx from 表1，表2 where 表1.xxx=表2.xxx; 外连接：本质上是包含某一个表的全部信息 左外链接：包含所有左边表的记录，右表没有和他匹配的为NULL select xxx,xxx,xxx from 表1 left join 表2 on 表1.xxx=表2.xxx; 右外连接：包含所有右边表的记录，左表没有和他匹配的为NULL select xxx,xxx,xxx from 表2 right join 表1 on 表1.xxx=表2.xxx; 子查询 当进行查询的时候，查询条件需要另一个SQL命令的结果 子查询需要两张表的字段名字一致 alter table 表1名 change xxx yyy int 把表1中xxx改为yyy select * from 表1 where xxx in (select xxx from xxx); in可以用=替代 select * from 表1 where xxx = (select xxx from xxx limit 1);","link":"/2023/11/07/mysql3/"},{"title":"MySql(四)","text":"pymysql 使用python多线程操作数据库 使用python操作MySql1234567891011121314151617181920212223242526import pymysqldb = pymysql.connect(host='localhost', user='root', password='root', database='test1', port=3306)# 游标cursor = db.cursor()# 搜索数据cursor.execute('show tables')data = cursor.fetchall()print(data)# 插入数据 如果你的表的引擎是Innodb事务# 默认吧事务开起来 所以需要提交try: cursor.execute(&quot;insert into vc values('123','123')&quot;) cursor.execute(&quot;select * from vc&quot;) data = cursor.fetchall() print(data) #提交 #cursor.execute(&quot;commit&quot;) db.commit()except: db.rollback()cursor.close()db.close() 使用多线程操作数据库 pymysql不支持并发，需要使用锁123456789101112131415161718192021222324252627282930313233343536373839404142import pymysqlimport threadingfrom threading import Locklock = Lock()db = pymysql.connect(host='localhost', user='root', password='root', database='test1', port=3306)# 写入数据def write_con(): try: print(&quot;写入数据&quot;) # 获取游标 cursor = db.cursor() lock.acquire() cursor.execute(&quot;insert into vc values('321','321')&quot;) db.commit() lock.release() except: db.rollback()# 查询数据def read_con(): try: print(&quot;查询数据&quot;) cursor = db.cursor() lock.acquire() cursor.execute(&quot;select * from vc&quot;) data = cursor.fetchall() print(data) lock.release() except: db.rollback()t1 = threading.Thread(target=write_con)t2 = threading.Thread(target=read_con)t1.start()t2.start()t1.join()t2.join()print(&quot;over&quot;)db.close()","link":"/2023/11/07/mysql4/"},{"title":"MySql(五)","text":"sqlalchemy使用 基础使用方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, Integer, String,Date,UnicodeTextfrom sqlalchemy.orm import sessionmakerfrom sqlalchemy import create_enginefrom datetime import datetime# 引擎engine = create_engine(&quot;mysql+pymysql://root:root@127.0.0.1:3306/test1&quot;)#创建表Base = declarative_base()class User(Base): __tablename__ = 'user' id = Column(Integer, primary_key=True)#主键 索引 不需要你添加 id 自增 name = Column(String(32)) age = Column(Integer,nullable=True)#可以为空 date=Column(Date,default=datetime.now())#默认 desc=Column(UnicodeText,nullable=True)#定义初始化数据库函数def init_db(): Base.metadata.create_all(engine)#顶固删除数据库函数def drop_db(): Base.metadata.drop_all(engine)drop_db()init_db()Session = sessionmaker(bind=engine) #创建sessionsession = Session()# 增obj = User(name=&quot;nihao&quot;, age=30,desc=&quot;nihao&quot;) #添加单条session.add(obj) #加入到队列session.add_all([ #添加多条 User(name=&quot;lry&quot;), User(name=&quot;abu&quot;),])session.commit() # 添加到sql#删session.query(User).filter(User.id &gt;1).delete()session.commit()#改 修改内容为字典session.query(User).filter(User.name=='xjb').update({&quot;name&quot; : &quot;xjb2&quot;,&quot;age&quot;:100})session.commit()#查ret = session.query(User).all() # 查询所有print(ret[0].name,ret[0].desc)ret = session.query(User.name, User.age).all()ret = session.query(User).filter(User.age&gt;10).all()ret = session.query(User).filter(User.age&gt;10).first()# ret是一个对象列表。这个对象可以通过 “对象[索引].字段”来获取对应的值ret = session.query(User).all() #查询列表所有数据#print(ret[0].name) #结果为元组，可通过下标的形式for i in ret: #循环元组， print(i.name,i.age,i.desc,i.date) 多线程数据库连接池1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import threadingfrom sqlalchemy.orm import sessionmakerfrom sqlalchemy import create_engine# User表from User import Userfrom threading import Threadengine = create_engine( &quot;mysql+pymysql://root:root@127.0.0.1:3306/test1&quot;, max_overflow=3, # 超过连接池大小外最多创建的连接 pool_size=10, # 连接池大小 pool_timeout=30, # 池中没有线程最多等待的时间，否则报错)Session = sessionmaker(bind=engine)def task_add(): # 去连接池中获取一个连接 session = Session() try: # 向表内添加线程信息 user=User(name=threading.currentThread().getName()) session.add(user) session.commit() print(threading.currentThread().getName()) except: session.rollback() # 将连接交还给连接池 session.close()def task_query(): # 去连接池中获取一个连接 session = Session() try: user=session.query(User).all() print(threading.currentThread().getName(),user) except: session.rollback() # 将连接交还给连接池 session.close()threads=[]for i in range(10): t=Thread(target=task_add) threads.append(t)for j in range(10): t=Thread(target=task_query) threads.append(t)for t in threads: t.start() t.join() 储存json123456789101112131415161718192021222324252627282930313233343536373839404142from sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy import Column, Integer, String,Date,UnicodeText,JSONfrom sqlalchemy.orm import sessionmaker,relationshipfrom sqlalchemy import create_engine,ForeignKeyfrom datetime import datetimeengine = create_engine(&quot;mysql+pymysql://root:root@127.0.0.1:3306/test1&quot;)#创建表Base = declarative_base()class JData(Base): __tablename__ = 'jdata' id = Column(Integer, primary_key=True)#主键 索引 不需要你添加 id 自增 data=Column(JSON)#定义初始化数据库函数def init_db(): Base.metadata.create_all(engine)#顶固删除数据库函数def drop_db(): Base.metadata.drop_all(engine)drop_db()init_db()Session = sessionmaker(bind=engine) #创建sessionsession = Session()# 增# 以字典的形式添加session.add_all([ #添加多条 JData(data={&quot;name&quot;:&quot;python&quot;,&quot;time&quot;:1}), JData(data={&quot;name&quot;:&quot;go&quot;,&quot;time&quot;:2}),])session.commit() # 添加到sqlret = session.query(JData).all() #查询列表所有数据for i in ret: #循环元组， print(i.id,i.data) 通过外键进行多表查询 通过（ForeignKey）外键关联两张表 通过relationship定义两表相互访问时的名字123456789101112131415161718192021222324252627from sqlalchemy.orm import sessionmaker,relationshipfrom sqlalchemy import create_engine,ForeignKeyclass Myclass(Base): __tablename__ = 'class' id = Column(Integer, primary_key=True)#主键 索引 不需要你添加 id 自增 name = Column(String(32)) #通过relationship定义两表相互访问时的名字 students=relationship('User',back_populates='myclass') def __str__(self): return f'id{self.id} name:{self.name}'class User(Base): __tablename__ = 'user' id = Column(Integer, primary_key=True)#主键 索引 不需要你添加 id 自增 name = Column(String(32)) age = Column(Integer,nullable=True) date=Column(Date,default=datetime.now()) desc=Column(UnicodeText,nullable=True) # 通过外键关联ForeignKey class_id=Column(Integer,ForeignKey(Myclass.id)) myclass=relationship(&quot;Myclass&quot;,back_populates='students')ret = session.query(Myclass).all() #查询列表所有数据for i in ret: #循环元组， print(i.id,i.name,i.students)","link":"/2023/11/07/mysql5/"},{"title":"Python密码学(一)","text":"介绍使用python实现消息摘要算法，MD5，SHA，HMAC（MD5，SHA）和SM3算法 消息摘要算法 消息摘要算法是一种可以将文本或其他信息压缩成简短的字符串的算法。这些字符串被称为消息摘要算法或散列值。 作用：验证文件的完成性，在加密数据库中存储密码 MD和SHA（哈希函数） 给定输入，返回相同的输出 输出长度固定，输入长度不同 不可逆 MD51234567from Crypto.Hash import MD5word = MD5.new(b'nihao')print(word.hexdigest())word2 = MD5.new()word2.update(b'ni')word2.update(b'hao')print(word2.hexdigest()) SHA1234567from Crypto.Hash import SHA256,SHA3_256word3 = SHA256.new(b'nihao')word4 = SHA256.new()word4.update(b'ni')word4.update(b'hao')print(word3.hexdigest())print(word4.hexdigest()) HMAC hash算法的进阶版，在hash计算过程中混入了key（加盐），防止彩虹表破解 选择一种hash函数，SHA1，SHA256 生成密钥，并将其与消息一起输入 12345678910111213import hmacfrom Crypto.Random import get_random_bytesfrom Crypto.Hash import MD5,SHA512data = '你好'.encode()key = get_random_bytes(16)#key = b'123456789'#加盐后的res = hmac.new(key,msg=data,digestmod=MD5).hexdigest()print('hmac',res)# 原版md5res2 = MD5.new(data).hexdigest()print('md5',res2) SM3 SM国密算法 SM31234567#sm3的使用 约等于SHA256from gmssl import sm3data = 'nihao'.encode()result = sm3.sm3_hash(sm3.bytes_to_list(data=data))print(result)print(len(result))","link":"/2023/08/01/pycrypt1/"},{"title":"Python密码学(二)","text":"介绍使用python实现对称加密算法，DES，3DES，AES，RC4和SM4算法。 对称加密算法 加密mode ECB模式：将明文简单的按照128bit为一个分块进行切割，在把每个分块进行AES加密，然后将密文拼接，如果长度不足128位，则会补全。 CBC模式：先对第一个明文块加密，之后每一个与前一个密文进行异或后再加密，每个密文块都依赖前面所以明文块。第一个明文块要用到IV，在CBC模式下IV要先与第一个明文块进行异或得到第一个明文块，在对后续加密。 OFB模式 CTR模式 CFB模式 DES，3DES DES 对称加密 64bit 8个字节（有效长度为56bit） 16轮迭代加密 56位密钥对64位明文进行加密 不安全 使用的模式mode和AES一致5种 12345678910111213141516171819202122232425from Crypto.Cipher import DESfrom Crypto.Util.Padding import pad,unpadfrom Crypto.Random import get_random_byteskey = get_random_bytes(8)def encrypt_des(data): # 模式和AES一样的用法 des = DES.new(key,DES.MODE_ECB) res = des.encrypt(pad(data,8)) print('加密结果',res) return resdef decrypt_des(data): # 模式和AES一样的用法 des = DES.new(key,DES.MODE_ECB) res = des.decrypt(data) print('解密结果',unpad(res,8).decode()) return unpad(res,8)if __name__ == '__main__': data = '你好'.encode() res = encrypt_des(data) decrypt_des(res) 3DES 三倍56位加密 前56位加密，中间56位解密，后56位加密 123456789101112131415161718192021222324from Crypto.Cipher import DES,DES3from Crypto.Util.Padding import pad,unpadfrom Crypto.Random import get_random_byteskey = get_random_bytes(24)def encrypt_des(data): # 模式和AES一样的用法 des = DES3.new(key,DES3.MODE_ECB) res = des.encrypt(pad(data,8)) print('加密结果',res) return resdef decrypt_des(data): # 模式和AES一样的用法 des = DES3.new(key,DES3.MODE_ECB) res = des.decrypt(data) print('解密结果',unpad(res,8).decode()) return unpad(res,8)if __name__ == '__main__': data = '你好'.encode() res = encrypt_des(data) decrypt_des(res) AES AES是一种常用的对称加密算法，使用密钥加密，使用密钥解密 特点： 速度快，安全 长度128位，192位，256位 模式 ECB模式：将明文简单的按照128bit为一个分块进行切割，在把每个分块进行AES加密，然后将密文拼接，如果长度不足128位，则会补全。 1234567891011121314151617181920212223242526from Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad,unpadfrom base64 import b64decode,b64encodekey = get_random_bytes(16)# 加密def encrypt_ecb(data): aes=AES.new(key,AES.MODE_ECB) res=aes.encrypt(pad(data,16)) print(b64encode(res).decode()) return b64encode(res).decode()# cBUc8RKHih7RkWRG2e9C2Q==# 解密def decrypt_ecb(data): aes=AES.new(key,AES.MODE_ECB) res=aes.decrypt(b64decode(data.encode())) print(unpad(res,16).decode()) if __name__=='__main__': data = '你好'.encode() res=encrypt_ecb(data) decrypt_ecb(res) CBC模式：先对第一个明文块加密，之后每一个与前一个密文进行异或后再加密，每个密文块都依赖前面所以明文块。第一个明文块要用到IV，在CBC模式下IV要先与第一个明文块进行异或得到第一个明文块，在对后续加密 12345678910111213141516171819202122232425from Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad,unpadfrom base64 import b64decode,b64encodekey = get_random_bytes(16)iv = get_random_bytes(16)# 加密def encrypt_cbc(data): aes=AES.new(key,AES.MODE_CBC,iv=iv) res=aes.encrypt(pad(data,16)) print(b64encode(res).decode()) return b64encode(res).decode()# R3jIvRc7SZx88iRa3yEMfw==# 解密def decrypt_cbc(data): aes=AES.new(key,AES.MODE_CBC,iv=iv) res=aes.decrypt(b64decode(data.encode())) print(unpad(res,16).decode()) if __name__=='__main__': data = '你好'.encode() res=encrypt_cbc(data) decrypt_cbc(res) OFB模式 12345678910111213141516171819202122232425from Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad,unpadfrom base64 import b64decode,b64encodekey = get_random_bytes(16)iv = get_random_bytes(16)# 加密def encrypt_ofb(data): aes=AES.new(key,AES.MODE_OFB,iv=iv) res=aes.encrypt(pad(data,16)) print(b64encode(res).decode()) return b64encode(res).decode()# SoNsyX8HqZrHxAlUtFA34w==# 解密def decrypt_ofb(data): aes=AES.new(key,AES.MODE_OFB,iv=iv) res=aes.decrypt(b64decode(data.encode())) print(unpad(res,16).decode()) if __name__=='__main__': data = '你好'.encode() res=encrypt_ofb(data) decrypt_ofb(res) CTR模式 1234567891011121314151617181920212223242526from Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad,unpadfrom base64 import b64decode,b64encodekey = get_random_bytes(16)nonce = get_random_bytes(8)# 加密def encrypt_ctr(data): aes=AES.new(key,AES.MODE_CTR,nonce=nonce) res=aes.encrypt(pad(data,16)) print(b64encode(res).decode()) return b64encode(res).decode()# UW9GRltpxIrUF1M80gI/sw==# 解密def decrypt_ctr(data): aes=AES.new(key,AES.MODE_CTR,nonce=nonce) res=aes.decrypt(b64decode(data.encode())) print(unpad(res,16).decode()) if __name__=='__main__': data = '你好'.encode() res=encrypt_ctr(data) decrypt_ctr(res) CFB模式 12345678910111213141516171819202122232425from Crypto.Cipher import AESfrom Crypto.Random import get_random_bytesfrom Crypto.Util.Padding import pad,unpadfrom base64 import b64decode,b64encodekey = get_random_bytes(16)iv = get_random_bytes(16)# 加密def encrypt_cfb(data): aes=AES.new(key,AES.MODE_CFB,iv=iv) res=aes.encrypt(pad(data,16)) print(b64encode(res).decode()) return b64encode(res).decode()# nwqQbIwBjQ/VfumOJk6KEg==# 解密def decrypt_cfb(data): aes=AES.new(key,AES.MODE_CFB,iv=iv) res=aes.decrypt(b64decode(data.encode())) print(unpad(res,16).decode()) if __name__=='__main__': data = '你好'.encode() res=encrypt_cfb(data) decrypt_cfb(res) RC4 字节流加密—-以此加密明文中每一个字节，解密也是如此 RC4密钥长度1-256字节，最好128位以上，安全 12345678910111213141516171819from Crypto.Cipher import ARC4from Crypto.Random import get_random_bytesdata = '你好'.encode()key = get_random_bytes(16)def encrypt_arc4(data,key): arc = ARC4.new(key) res = arc.encrypt(data) print(res) return resdef decrypt_arc4(data,key): arc = ARC4.new(key) res = arc.decrypt(data) print(res.decode()) return resif __name__ == '__main__': res = encrypt_arc4(data,key) decrypt_arc4(res,key) SM4 SM4对称加密算法 123456789101112131415161718192021222324#ecb模式from gmssl import sm4from Crypto.Random import get_random_bytes#加密mode = 0def encrypt_sm4(data): SM4 = sm4.CryptSM4() SM4.set_key(key,mode=0) res = SM4.crypt_ecb(data) print('加密结果',res) return res#解密mode =1def decrypt_sm4(data): SM4 = sm4.CryptSM4() SM4.set_key(key,mode=1) res = SM4.crypt_ecb(data) print('解密结果',res.decode()) return resif __name__ == '__main__': key = get_random_bytes(16) data = '你好'.encode() res = encrypt_sm4(data) decrypt_sm4(res) 12345678910111213141516171819202122232425#cbc模式from gmssl import sm4from Crypto.Random import get_random_bytes#加密mode = 0def encrypt_sm4(data): SM4 = sm4.CryptSM4() SM4.set_key(key,mode=0) res = SM4.crypt_cbc(iv,data) print('加密结果',res) return res#解密mode =1def decrypt_sm4(data): SM4 = sm4.CryptSM4() SM4.set_key(key,mode=1) res = SM4.crypt_cbc(iv,data) print('解密结果',res.decode()) return resif __name__ == '__main__': key = get_random_bytes(16) iv = get_random_bytes(16) data = '你好'.encode() res = encrypt_sm4(data) decrypt_sm4(res)","link":"/2023/08/01/pycrypt2/"},{"title":"Python密码学(三)","text":"介绍使用python实现非对称加密算法，RSA，SM2，数字签名算法。 非对称加密算法RSA 两个不同密钥，一个用来加密一个用来解密 安全性强与AES但速度慢 先生成密钥对在调用加密器PKCS1_OAEP再进行加密 1234567891011121314151617181920212223242526from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEP#生成密钥key = RSA.generate(2048)public_key = key.public_key().export_key()private_key = key.export_key()#加密def encrypt_rsa(data): my_key = RSA.import_key(public_key) rsa = PKCS1_OAEP.new(my_key) res = rsa.encrypt(data) print('加密结果',res) return res#解密 def decrypt_rsa(data): my_key = RSA.import_key(private_key) rsa = PKCS1_OAEP.new(my_key) res = rsa.decrypt(data) print('解密结果',res.decode()) return resif __name__=='__main__': data = &quot;你好&quot;.encode() print(data) res = encrypt_rsa(data) de_res = decrypt_rsa(res) 将密码存入文件中读写 1234567891011from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEP#生成密钥key = RSA.generate(2048)with open('python/public.pem','wb')as f: public_key = key.public_key().export_key() f.write(public_key)with open('python/private.pem','wb')as f: private_key = key.export_key() f.write(private_key) 12345678910111213141516171819202122from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEP#加密def encrypt_rsa(data): my_key = RSA.import_key(open('python/public.pem','rb').read()) rsa = PKCS1_OAEP.new(my_key) res = rsa.encrypt(data) print('加密结果',res) return res#解密 def decrypt_rsa(data): my_key = RSA.import_key(open('python/private.pem','rb').read()) rsa = PKCS1_OAEP.new(my_key) res = rsa.decrypt(data) print('解密结果',res.decode()) return resif __name__=='__main__': data = &quot;你好&quot;.encode() print(data) res = encrypt_rsa(data) de_res = decrypt_rsa(res) SM2 密钥对需要专门的SM密钥生成器生成 使用gmsll库进行加密 12345678910111213141516171819202122from gmssl import sm2private_key = 'f379721d08cc34bcbb37f76343043ca3c614ce39a23c7cacd0b9ab75fbddf301'public_key = 'be4bea1224719c10ebf550ee66a24c7e7fbe94329749ce32651b666a32474e0953b5f29'\\ '6c14d29d853e85e8f724de20028050d69409de13e6b42f1f2107e3e3e'key=sm2.CryptSM2(private_key,public_key)# 加密def encrypt_sm2(data): res = key.encrypt(data) print('加密结果',res) return res#解密def decrypt_sm2(data): res = key.decrypt(data) print('解密结果',res.decode()) return resif __name__ == '__main__': data = '你好'.encode() res = encrypt_sm2(data) de_res = decrypt_sm2(res) 也可以实现数字签名算法 12345678910111213141516171819202122232425262728#签名from gmssl import sm2private_key = 'f379721d08cc34bcbb37f76343043ca3c614ce39a23c7cacd0b9ab75fbddf301'public_key = 'be4bea1224719c10ebf550ee66a24c7e7fbe94329749ce32651b666a32474e0953b5f296c14d29d'\\ '853e85e8f724de20028050d69409de13e6b42f1f2107e3e3e'key=sm2.CryptSM2(private_key,public_key)# 加密def encrypt_sm2(data): res = key.encrypt(data) signature = key.sign(data,private_key) print('加密结果',res) print('签名',signature) return res,signature#解密def decrypt_sm2(data,signature): res = key.decrypt(data) print('解密结果',res.decode()) verify = key.verify(signature,res) print('签名结果',verify) return res,if __name__ == '__main__': data = '你好'.encode() res,signature = encrypt_sm2(data) de_res = decrypt_sm2(res,signature) 数字签名算法 公钥用于签名验证，私钥用于签名生成 过程如下 签名过程：消息的Hash值被用作数字签名，然后使用私钥加密，生成数字签名。 验证过程：将数字签名用于公钥解密，并与消息的Hash值比较，如果两个值相同，则证明数字签名是合法的 数字签名的目的是为了保证数据的完整性和发送者的身份验证 保证数据在传输过程中没有被篡改 身份验证 不可抵赖性，认证 12345678910111213141516171819202122232425262728293031323334353637383940from Crypto.PublicKey import RSA,DSA,ECCfrom Crypto.Cipher import PKCS1_OAEPfrom Crypto.Signature import pkcs1_15from Crypto.Hash import SHA512myPublic_key = RSA.import_key(open('python/public.pem','rb').read())myPrivate_key = RSA.import_key(open('python/private.pem','rb').read())#加密def encrypt_rsa(data): digest = SHA512.new(data) signature = pkcs1_15.new(myPrivate_key).sign(digest) rsa = PKCS1_OAEP.new(myPublic_key) res = rsa.encrypt(data) print('加密结果',res) return res,signature#解密 def decrypt_rsa(data,signature): rsa = PKCS1_OAEP.new(myPrivate_key) res = rsa.decrypt(data) print('解密结果',res.decode()) digeat = SHA512.new(res) try: pkcs1_15.new(myPublic_key).verify(digeat,signature) print('签名以通过') except: print('签名未通过') return resif __name__=='__main__': data = &quot;你好&quot;.encode() print(data) res,signature = encrypt_rsa(data) de_res = decrypt_rsa(res,signature)","link":"/2023/08/01/pycrypt3/"},{"title":"Python基础(一)","text":"多线程，多进程，进程间数据通信 Python多线程 一个进程至少包含一个主线程（守护线程），也可以包含许多子线程（非守护线程）。 Python程序为了线程安全，每一个进程设有一个全局解释器锁，不同的操作系统对线程的占用时间时有限的，当Python程序执行时每一个线程都需要排队去申请解锁，在有限的占用时间后还锁，这就造成Python多线程程序同一时刻只能有一个线程在运行，但由于操作系统切换线程速度太快，就看似是一种并发的状态，但其实是伪并发。 Python要实现真并发，可以使用多进程。 对于爬虫来说主要在等待I/O的请求时间，所以多线程完全可以使用。 threading，多线程包 基础使用 设置线程 开启线程 其他：设置守护线程，查看线程状态 12345678910111213141516171819202122232425262728293031323334import threadingdef print1(): for i in range(100): print(&quot;1&quot;)def print2(): for i in range(100): print(&quot;2&quot;)#target=函数名，args=传入参数x1=threading.Thread(target=print1,args=())x2=threading.Thread(target=print2,args=())#设置为守护线程# x1.daemon=True# x2.daemon=True#开启线程#主线程接受不影响非守护线程x1.start()x2.start()#判断是否为守护线程# print('x1',x1.daemon)# print('x2',x2.daemon)print(&quot;主线程结束&quot;)#查看线程状态#print(threading.current_thread())#查理主线程状态#print(threading.main_thread()) 上锁 使用 threading.Lock() 进行上锁等待，上文说到在有限的的时间内会将锁还回去（但保留运行数据，再次轮到后继续进行），任务开始使用 .acquire获取锁，可以强制等待任务执行完毕后使用 .release 再还锁。 .join()的作用，主线程任务结束后进入阻塞状态，会一直等待调用了join子线程任务执行结束后主线程才会终止。 用时间换安全 使用一个循环加一减一的例子说明 1234567891011121314151617181920212223242526272829303132import threadingLock=threading.Lock()num = 0def print1(): global num for i in range(100): Lock.acquire() num+=1 Lock.release()def print2(): global num for i in range(100): Lock.acquire() num-=1 Lock.release()#target=函数名，args=传入参数x1=threading.Thread(target=print1)x2=threading.Thread(target=print2)x1.start()x2.start()x1.join()x2.join()print(num) Python多进程 multiprocessing包 基本使用 设置线程–启动线程–给每个线程添加等待 12345678910111213141516171819202122import multiprocessingimport time# 查看电脑线程数# print(multiprocessing.cpu_count())def num(name): print('run process{}'.format(name)) time.sleep(3) print('end process{}'.format(name))if __name__ == '__main__': # 设置线程--启动线程--给每个线程添加等待 processes=[] for i in range(5): p1=multiprocessing.Process(target=num,args=(i,)) processes.append(p1) p1.start() for i in processes: i.join() print('进程结束') 进程池构建 在一开始创建一个进程池，那个空闲用那个，用完自动还回去 123456789101112if __name__ == '__main__'： Pools=multiprocessing.Pool(3) for i in range(9): #Pools.apply(func=num,args=(i,))#apply同步 Pools.apply_async(func=num,args=(i,))#apply_async异步(主要使用异步) Pools.close()#使用结束后关闭全部进程池 Pools.join() print('进程结束') 多进程数据共享 原理：使用代理 Manager 使用代理复制一份数据进行同步更改 不是共享内存 123456789101112131415161718192021222324252627282930import multiprocessingimport timedef push(li): print(id(li)) while True: print(&quot;存数据&quot;) li.append('a') time.sleep(1)def pop(li): print(id(li)) while True: if li: print('拿数据'+str(li.pop())) time.sleep(1)def main(): #设置代理Manager（列表） li = multiprocessing.Manager().list() print(id(li)) p1 = multiprocessing.Process(target=push,args=(li,)) p2 = multiprocessing.Process(target=pop, args=(li,)) p1.start() p2.start() p1.join() p2.join()if __name__ == '__main__': main()","link":"/2023/08/06/python1/"},{"title":"Python基础(二)","text":"异步协程 异步:在单线程中利用IO等待时间去执行其他任务 携程:一个个没有并发起来的任务，协程本身不会多个并发需要我们包装成任务 注意: 如果不加await 则任务只是一个声明不会运行，await + 等待执行的任务 在等待程序前面加上asyncio表示这是个异步程序 123456789101112131415161718192021222324import asyncioasync def num(name): print('{}start'.format(name)) await asyncio.sleep(2) print('{}end'.format(name))async def main(): t1=[asyncio.create_task(num(1)), asyncio.create_task(num(2)), asyncio.create_task(num(3))] await asyncio.wait(t1)#两种写法效果一样# async def main():# t1 = [num(1),# num(2),# num(3)]# await asyncio.gather(*t1)if __name__ == '__main__': #声明协程对象 并不会直接运行 #await运行协程任务 等待 会一直阻塞到任务结果返回 asyncio.run(main())","link":"/2023/08/06/python2/"},{"title":"Python基础(三)","text":"python基础语法 python编译原理 .py文件—编译器—pyCodeObject(内存)/.pyc(磁盘)—虚拟机VM—解释执行—机器码PC 数据类型 str int float bool list dict tuple set str “”12345#字符串 和引号无关str_a='nihao'str_b=&quot;nihao&quot;str_c=&quot;&quot;&quot;nihao&quot;&quot;&quot;print(str_a,str_b,str_c) int float1234int_a=123456float_a=3.1415926print(int_a,float_a)print(type(int_a)) bool123bool_a=Trueprint(type(bool_a),bool_a)print(0==False) list []1234567list_a=[1,2,3,3.14,'nihao','buhao',[5,6,7]]print(list_a)list_a[4]='你好'print(list_a)#删除del list_a[0]print(list_a) dict {key:value}123456dict_a={'name':'xxx','age':100,'port':8000}print(dict_a['name'])dict_a['name']='nihao'print(dict_a)del dict_a['age']print(dict_a) tuple ()1234#类似列表 不能更改 ()tuple_a=('human',99,55,22)print(tuple_a,type(tuple_a))print(tuple_a[0]) set {}123456#集合，过滤重复元素 {}list_b=[1,2,3,5,4,2]set_a=set()for i in list_b: set_a.add(i)print(set_a) 基本语法 break 跳出当前循环 ,continue 继续下一次循环 if else123456username=input(&quot;请输入用户名：&quot;)if username=='nihao': print('登陆成功') breakelse: print('用户名错误,请重新输入') 循环123456789#while死循环-结束条件while True: username=input(&quot;请输入用户名：&quot;) if username=='xjb': print('登陆成功') break else: print('用户名错误,请重新输入')print('程序结束') 123456789#for计次for i in range(10): username=input(&quot;请输入用户名：&quot;) if username=='xjb': print('登陆成功') break else: print('用户名错误,请重新输入')print('程序结束') 循环计数123456789# 循环时候计数enumerateli=['nihao','nihao2','nihao3']for num,item in enumerate(li): print(num+1,item)# 1 nihao# 2 nihao2# 3 nihao3 1234567891011#多个序列打包循环 zipli=[1,2,3,4]li2=[4,5,6,7]li3=[4,5,6,7]for i,j,z in zip(li,li2,li3): print(i,j,z)# 1 4 4# 2 5 5# 3 6 6# 4 7 7 定义函数1234567def add(a,b): print(a+b) # 不写return默认返回None return a+b tmp=add(5,3)print(tmp) 错误处理123456789101112def add(a,b): try: c=a+b print('a+b=',c) # except：可以指定错误类型 except Exception as e: print('发生错误了！',e) finally: #不管正确与否都执行finally print('执行finally')add(1,3)","link":"/2023/08/07/python3/"},{"title":"Python基础(四)","text":"类，装饰器，文件操作 类123456789101112131415161718192021222324252627282930#参数叫属性#函数叫方法class Human: # 初始化 def __init__(self,name): # 指针指向self内存地址 # self 放在内存里的一个Human对象 self.name=name print('self-&gt;',self) # 像调用函数一样调用类 def __call__(self, *args, **kwargs): print('call 被调用',args,kwargs) #call 被调用 (1, 2, 3, 'nihao') {'name': 'nihao', 'age': 9} #*args和*kwargs会把值解出来 #call 被调用 1 2 3 nihao name age print('call 被调用',*args,*kwargs) def speak(self): print('Human在讲话'+self.name)#实例化会自动调用init方法h1=Human(&quot;h1&quot;)print(h1.name)h1.speak()h2=Human(&quot;h2&quot;)print(h2.name)h2.speak()#像调用函数一样调用类#前面的数据会被*args接收，后面的两个赋值运算会被当作键值对被**kwargs接收h1(1,2,3,'nihao',name='nihao',age=9) 继承 封装 多态1234567891011121314151617181920212223242526272829303132class Human: def __init__(self,name,age): self.name=name #下划线开头代表私有 self.__age = age print('self-&gt;',self) def speak(self): print('Human在讲话'+self.name) #下划线开头代表私有 def __speak(self): print('Human在讲话'+self.name)#继承class nihao(Human): def __init__(self,name,age): self.nihao=name self.age = age #调用父类__init__方法 super(nihao, self).__init__(name,age) # 多态 重写父类 def speak(self): print('nihao') #在同名子类中调用父类 super(nihao, self).speak()def speak(obj): obj.speak()x1=nihao(&quot;nihao&quot;,2)x2=Human(&quot;nihao2&quot;,1)speak(x1)speak(x2) 12345678910111213141516171819202122#property 把类方法转化为类属性方式获取#classmethod 类方法表示属于类，不属于实例#staticmethod 静态方法 我当前的方法不属于类 是一个单独的函数class nihao: def __init__(self): self.age ='4' @property def _age(self): return self.age #设置属性 @_age.setter def _age(self,value): self.age=value #删除属性 @_age.deleter def _age(self): del self.agen = nihao()del n._agen._age = 5print(n._age) 装饰器12345678910111213141516171819202122#自制装饰器#高阶函数---把函数作为参数#参数是函数 返回内部函数 内部函数里边调用函数（传递参数）import timedef Timer(func): #start=time.time() def inner(*args,**kwargs): #print('传递的参数：',*args,**kwargs) func(*args,**kwargs) # end=time.time() # print('耗费时间：',end-start) return inner@Timerdef test(a,b,c): for i in range(100000): print(1)test(1,2,3) 文件操作12345678910111213141516171819202122&quot;&quot;&quot;w 写入 如果文件不存在我就创建 已经存在就会覆盖r 读取 读取文件内容a 追加 把内容写入文件末尾，不存在就创建，存在就直接写b 二进制 写入视频、音频、图片之类的就需要加这个with自开合 enter exit&quot;&quot;&quot;line=&quot;写入文件&quot;#第一种写法f=open('demo.txt','w',encoding='utf-8')f.write(line)f.close()#不关闭那就会导致内存泄漏（文本打开太多了，内存爆了）#第二种写法for i in range(10): with open('demo.txt','a',encoding='utf-8')as f: f.write(line+'\\n')# 读with open('demo.txt','r',encoding='utf-8')as fr: content=fr.read()print(content)","link":"/2023/08/08/python4/"},{"title":"Python基础(五)","text":"python三器 迭代器和生成器迭代器：标志是使用__iter__方法，返回一个迭代器对象使用__next__方法可以获取下一个值，如果没有下一个值则抛出StopIteration异常 迭代器是一个可以记住遍历的位置的对象，可以为序列、文件、集合、字典、字符串等对象 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束 迭代器只能往前不会后退 迭代器是有状态的，每次迭代都需要重新设置状态 生成器：生成器是一个特殊的迭代器，只能往后不会前进，标志是使用yield关键字，返回一个生成器对象 生成器是一个特殊的函数，只能用于迭代操作，返回迭代器对象 生成器是一个惰性计算的对象，只有在需要迭代的时候才会执行，节省内存 生成器可以不断返回下一个值，直到没有更多的值 装饰器装饰器是一个特殊的函数，它可以让其他函数增加额外的功能，其定义格式如下： 12345def decorator_name(func): def wrapper(*args, **kwargs): # 包装操作 return func(*args, **kwargs) return wrapper 装饰器的作用就是将原函数的内容包装起来，然后返回包装后的函数。 Python中如何实现单例模式 单例模式是一种常见的设计模式，它保证一个类只有一个实例，并提供一个访问它的全局访问点。123456789101112131415161718192021222324252627282930313233343536373839404142# 实现方式一：# 使用装饰器实现 判断是否已经实例化from functools import wrapsfrom typing import Anydef singleton(cls): &quot;&quot;&quot; 单列类装饰器 &quot;&quot;&quot; instance = {} @wraps(cls) def wrapper(*args, **kwargs): if cls not in instance: instance[cls] = cls(*args, **kwargs) return instance[cls] return wrapper@singletonclass Singleton: &quot;&quot;&quot; 单列类 &quot;&quot;&quot; passa = Singleton()b = Singleton()print(id(a), id(b))# 实现方式二：# 使用元类实现单例类(类这样的对象时通过元类来创建，默认元类为type)class Singleton2(type): &quot;&quot;&quot; 单列类元类 &quot;&quot;&quot; def __init__(cls,*arg,**kwargs): print('init') cls.__instance = None super().__init__(*arg,**kwargs) def __call__(cls,*arg,**kwargs): print('call') if cls.__instance is None: cls.__instance = super().__call__(*arg,**kwargs) return cls.__instanceclass President(metaclass=Singleton2): pass a = President()b = President()print(id(a), id(b))","link":"/2023/08/13/python5/"},{"title":"Redis(一)","text":"Redis安装使用 数据类型 设置自动过期时间 安装使用 安装 brew install redis key-value数据库，nosql非关系数据库 值可以时字符串、哈希、列表、集合、有序集合等 启动 redis-server 启动 redis-cli （-h 127.0.0.1 -p6379） 数据类型字符串类型 set “key” “value” get “key” 不存在返回nil strlen “key” 返回字符串长度 append “key” “追加内容” mset “key” “value” “key” “value” 存入多个数据 mget “key” “key” “key” 列表类型 能够让一个键对应多个值 插入 lpush “key” v1 v2 左端插入，结果为 v2 v1 rpush “key” v1 v2 右端插入，结果为 v1 v2 linsert “key” after v1 v3 中间插入 弹出内容 lpop “key” 删除左边第一个 rpop blpop/brpop key timeout 3 弹出内容-阻塞3秒 获取 lindex key 0 获取key中第0个元素 llen key 获取长度 lrange key start stop 获取从start到结束的元素，start/stop 为数字 哈希类型-和字典类似 hmset name key value key value 插入多个 hmget name key key 查询 hgetall name 获取name的全部key和value hexists name key 是否存在某个字段 hset name key value 修改或添加 hdel name key value 删除字段 一个哈希最多存2^32-1字段，字段为空自动释放内存 集合类型 去重 集合成员是唯一的，会自动去重 sadd key v1 v2 v1 添加 srem key v1 删除 scard key 获取长度 sismenber key v1 判断存在 members key 列出成员 设置自动过期时间 lpush “key” “url1” “url2” expire “key” 20 查看剩余过期时间 TTL “key” exists “spider cache”","link":"/2023/11/09/redis1/"},{"title":"Redis(二)","text":"事务 订阅模式 持久化RDB，AOF 事务 启动事务 multi 放弃事务 discard 提交事务 exec 监控键 watch（如果在事务exec之前修改了键，则取消事务） redis和sql事务的区别 没有回滚 语法错误，exec不会执行 原子性 执行过程中出错，后续命令还是会继续执行 打破原子性 redis发布订阅模式PubSub 经典消息传递机制，即频道把数据发送出去，订阅了该频道的用户受到消息 subscribe 用于订阅 publish 用于发布 pubsub channels 用于展示频道 unsubscribe 用于退订 当频道无订阅时会自动销毁，而且订阅消息不支持持久化 持久化 redis数据存储在内存中，重启后所有数据会被清空 为了保存数据，redis提供两种持久化类型RDB和AOF RDB默认自动保存也可以手动写入 保存文件名dump.rdb sava 同步写入，会阻塞线程 bgsave 异步方式，fork子进程处理 数据恢复：config get dir 修改 /usr/local/etc/redis.conf save 900 1 表示900秒内至少有1个key变化就自动保存，取消自动保存注释掉即可 stop-writes-on-bgsave-error:当启动RDB且最后一次保存数据失败，redis是否停止接受数据 rdbcompression：磁盘快照是否进行压缩 rdbchecksum：是否进行CRC64算法进行数据校验 dbfilename：设置快照文件名 dir：设置文件存放路径，是一个目录不是一个文件名 AOF记录写入命令的追加模式，每个写入命令都会被记录 修改redis.conf 文件 config set appendonly yes appendfsync always：每个写入都fsync appendfsync everysec：每一秒一次fsync appendfsync no：用于fsync，由系统时间决定 auto-aof-rewrite-percentage 100 当前AOF文件大小和上一次重写时AOF文件大小的比值 auto-aof-rewrite-min-size 64mb 文件最小体积 原理：redis先把写入命令写入到缓冲区，缓冲区的数据被fsync()之后刷到磁盘，redis关闭时自动调用一次fsync bgrewriteaof：重写会创建一个当前AOF文件的体积优化版本 如果只配置AOF，重启时加载AOF文件恢复数据 如果同时配置了RDB和AOF，启动时只加载AOF文件恢复数据 如果只配置RDB启动时加载dump文件恢复数据","link":"/2023/11/09/redis2/"},{"title":"Redis(三)","text":"Python操作redis redis主从复制 redis消息订阅 Python操作redis12345import redispool = redis.ConnectionPool(host='127.0.0.1', port=6379)r = redis.Redis(connection_pool=pool)r.set('name', 'tom')print(r.get('name')) 1234567891011import redispool = redis.ConnectionPool(host='127.0.0.1', port=6379)r = redis.Redis(connection_pool=pool)#事务try: pipe=r.pipeline() pipe.set(&quot;name&quot;,&quot;tom&quot;) # 提交 pipe.execute()except Exception as err: print(err) redis主从复制 生产环境中，单个服务器往往存在崩溃、宕机、网络故障。 提高容错，减轻单个服务器的压力，redis主从复制，能够讲一个服务器的数据，同时同步同步到多个备份服务器中。 操作 复制一份redis.windows.conf 修改文件名为redis.slave.conf 新建slave文件夹 修改文件： port 6389 dir ./slave slaveof 127.0.0.1 6379 启动命令：redis-cli -p 端口号 输入 info replications 可以查看当前主从关系 redis消息订阅1234567import redispool = redis.ConnectionPool(host='127.0.0.1', port=6379)r = redis.Redis(connection_pool=pool)while True: data = input(&quot;&gt;&gt;&gt;&quot;) r.publish('test', data) 1234567891011121314151617181920import redisimport timepool = redis.ConnectionPool(host='127.0.0.1', port=6379)r = redis.Redis(connection_pool=pool)pub=r.pubsub()pub.subscribe('test')pub.parse_response()while True: print(&quot;waiting for message...&quot;) msg = pub.parse_response() print(msg) print(msg[2].decode('utf-8')) time.sleep(3) if msg[2].decode('utf-8') == 'exit': m = pub.unsubscribe('test') print(m) print(&quot; &quot;) break","link":"/2023/11/12/redis3/"},{"title":"Scrapy框架(一)","text":"命令 框架结构 命令 pip3 install scrapy 安装 scrapy startproject study 创建一个名为study的项目 cd study scrapy genspider demo baidu.com 创建爬虫 scrapy crawl demo 运行爬虫 全局命令 scrapy runspider xxx.py 直接运行爬虫文件，无需创建项目 scrapy shell url 打开命令行请求网站 response.header response.xpath('//text') response.css('title::text')[0].get() scrapy fetch url 爬取主址 scrapy veiw url 打开浏览器 scrapy version 版本 项目内命令 scrapy list 列出当前爬虫 scrapy bench 测试scrapy运行速度 框架结构Scrapy主要包括了以下组件：1.引擎(Engine) 用来处理整个系统的数据流处理, 触发事务(框架核心) 2.调度器(Scheduler) 用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址 3.下载器(Downloader) 用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的) 4.爬虫(Spiders) 爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面 5.项目管道(Pipeline) 负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据。 6.中间件Middlewares 下载器中间件(Downloader Middlewares)介于Scrapy引擎和下载器之间的中间件，主要是处理Scrapy引擎与下载器之间的请求及响应。 爬虫中间件(Spider Middlewares)介于Scrapy引擎和爬虫之间的中间件，主要工作是处理蜘蛛的响应输入和请求输出。 调度中间件(Scheduler Middewares)介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应。 运行流程1.引擎到爬虫里边拿到start_urls，封装成Request请求对象（并没有真的去请求） 2.引擎将Request对象放入调度器队列 （先进先出 ）排队 3.引擎对队列挨个处理请求，交给下载中间件 4.下载中间件去请求Internet ，首先process_request，服务器返回process_response 5.引擎将响应交给爬虫处理parse，处理结果封装成items对象结合parse存储数据 6.引擎将item存储的数据交给管道进行存储","link":"/2023/08/11/scrapy1/"},{"title":"Scrapy框架(二)","text":"Scrapy 爬虫(Spiders) scrapy.Spider类 scrapy.Spider是所有爬虫的基类 123&quot;&quot;&quot;Base class for scrapy spiders. All spiders must inherit from this class.&quot;&quot;&quot; ‘init‘方法 每一个爬虫都应该有名字 ‘start_requests’方法 每个爬虫文件的起始请求方法 在爬虫文件中重写该方法，必须包含以下代码 12for url in self.start_urls: yield Request(url, dont_filter=True) 通过yield Request方法，将请求加入请求队列 Request方法传参 123456789url: str,callback: 回调函数,method: str = &quot;GET&quot;/&quot;POST&quot;,cookies: 当响应头中包含set cookies时，Scrapy会自动处理cookies,meta: 字典形式存放信息,encoding: str = &quot;utf-8&quot;,priority: int = 0,dont_filter: 默认不去重,flags: 列表形式存放信息, scrapy.Request 和 requests的区别 1.处理cookies:’scrapy.Request’通过’CookiesMiddleware’自动处理cookies,’requests’通过session处理cookies处理2.处理请求体方式:’scrapy.Request’通过’body.json.dumps(dict)’非请求体的参数只能拼接字符串处理url, ‘requests’通过’data’和’params’ ‘parse’方法 处理响应结果的方法","link":"/2024/03/23/scrapy2/"},{"title":"Scrapy框架(三)","text":"Scrapy 下载器中间件(Downloader Middlewares) 下载器中间件 下载器中间件是在引擎将请求推送到下载器时执行process_request 在下载器完成下载后将response对象返回给引擎的过程中执行process_response settings.py中开启，number越大，就先处理request，number越小，越先处理response 123456DOWNLOADER_MIDDLEWARES = { 'OpSpider.middlewares.OpspiderDownloaderMiddleware': 543, 'OpSpider.middlewares.StaryMiddleware':300, # 默认开启的下载中间件 None表示不启用 'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware':None,} 下载器中间件方法 process_request 发起请求前的方法，比如添加请求头，添加cookie等。 process_response 响应数据回来后的方法 prrocess_exception 发生异常后的方法 spider_opened 爬虫打开时的方法 随机ua处理 在url加入队列前处理请求头 在process_request方法中给resquest添加随机ua request.headers.setdefault('User-Agent','randomUa') 其他下载中间件 CookieMiddleware 在settings.py中开启 COOKIES_ENABLED = True 位置：scrapy.downloadermiddlewares.cookies 功能：检测到响应中有set cookie时，自动添加改变cookie 获取cookieprint(request.headers.get(&quot;Set-Cookie&quot;)) 爬虫中间件 当执行到yield Request()或者yield item时，引擎将请求交给爬虫中间件的process_spider_output方法 当执行 yield 的回调函数paesr_xxx()调用前执行process_spider_input方法 当运行start_requests()时，引擎将请求交给爬虫中间件的process_start_requests方法` 总体执行顺序 spider.py start_requests()开始 爬虫中间件的process_start_requests方法被yeild 下载中间件的process_request方法处理headers 下载中间件的process_response方法处理response 在进入回调函数paesr_xxx()进入爬虫中间件的process_spider_input方法 在运行yield Request()或yield item时，调用爬虫中间件的process_spider_output方法","link":"/2024/03/23/scrapy3/"},{"title":"Scrapy框架(四)","text":"Scrapy 调度器(Scheduler)### 调度器(Scheduler)- 位置：scrapy.core.scheduler","link":"/2024/03/23/scrapy4/"},{"title":"请求库","text":"介绍爬虫使用的请求库，requests，httpx，aiohttp。 requests 请求数据 get post 添加参数 user-agent 请求浏览器数据 date 数据 param 参数 cookie 防盗链 referer 请求超时 timeout=3 结果处理 二进制 文本text json数据 代码123456789101112131415161718192021222324252627282930313233343536import requestsurl = '这写上要爬的url'#添加头 headers = { &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)&quot;\\ &quot;Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.52&quot;,}#添加数据date = { &quot;kw&quot;: s}#添加参数（重新封装）params = { &quot;type&quot;: 20, &quot;interval_id&quot;: &quot;100:90&quot;, &quot;action&quot;: &quot;&quot;, &quot;start&quot;: 0, &quot;limit&quot;: 20,}#发起一个get请求resp = requests.get(url, headers=headers，data=data，params=params)#发起一个post请求resp = requests.post(url, headers=headers，data=data，params=params)#去掉安全验证resp = requests.get(url, verify=False)#设置编码格式resp.encoding = 'utf8'#状态码查看print(resp.status_code)#结果为二进制print(resp.content)#结果为json数据print(resp.json())#请求为文本print(resp.text) 中文解码12345678910import requestsfrom urllib.parse import quote,unquote#解码data='%E4%BD%A0%E5%A5%BD'print(unquote(data))#加码data2='你好'print(quote(data)) session会话 session对象 基于seesion发起的请求都会公用session内的参数。 session可以保存请求时的cookie12345678910import requestssession = requests.session()session.headers={ 'test':'test'}#请求是公用session中的参数，也可以自己添加，如果参数重合以自己的请求为主h1 =session.get('url',headers={'a':'b'})h2 =session.get('url') proxies代理123456import requestsproxies ={ 'http':'http://127.0.0.1:7890', 'https':'http://127.0.0.1:7890',}resp = requests.get('url',proxies=proxies) httpx 支持http2.0兼容http1.0 处理http1.0和requests一样的用法 12345import httpxheaders={}proies={}html = httpx.get('url',headers=headers,proies=proies)print(html.text) 处理http2.0和session用法相似 client=httpx.Client(http2.0=True,proxies=proxies) 异步请求 12345678910111213141516171819202122#第一中写法async def spider(num): print('run',num) client=httpx.AsyncClient(http2=True) html = await client.get('url') print(html) await client.aclose()#第二中写法async def spider(num): print('run',num) async with httpx.AsyncClient(http2=True) as client: html = await client.get('url') print(html)#建立队列async def main(): await asyncio.gather(*[spider(1),spider(2),spider(3)])#启动 if __name__ == '__main__': asyncio.run(main()) aiohttp 异步请求 123456789101112131415import aiohttpimport asyncioheaders={}#只支持http代理proxy='http://localhost:7890'async def main(): async with aiohttp.ClientSession(headers=headers) as client: html = await client.get('url') print(await html.text()) html.close()#使用loop启动程序loop = asyncio.get_event_loop()loop.run_until_complete(main()) 优缺点和区别 requests 同步 httpx 同步异步 aiohttp 只有异步","link":"/2023/08/01/spider1/"},{"title":"免费代理处理","text":"免费代理测试验证ip可用性 1.通过爬虫爬取免费代理ip和端口号2.对每个ip进行可用性验证，请求’https://httpbin.org/ip'判断状态码 12345678910111213141516171819#封装proxyproxies = { 'http': f'http://{IP}:{PORT}', 'https': f'http://{IP}:{PORT}',}url = 'https://httpbin.org/ip' headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'\\ 'AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36 Edg/109.0.1518.78' } try: html = requests.get(url, proxies=proxies, headers=headers, timeout=3) print('状态码：', html.status_code) print('IP：', html.text) #可用的代理放入列表种 proxies_list.append(proxies) except: print('代理不可用')","link":"/2023/08/01/spider2/"},{"title":"解析库","text":"使用bs4，xpath，re进行数据解析和提取。 bs4 BeautifulSoup 支持从HTML或XML文件中提取数据的python库 Beautiful Soup自动将输入文档转换为Unicode编码，输出文档转换为utf-8编码。 select方法需要使用css选择器 css选择器 class 使用·代替 id使用#代替 find方法是找到第一个满足条件的标签后就立即返回，只返回一个元素。 find_all方法是把所有满足条件的标签都选到，然后返回回去。 12345678910111213141516171819202122232425262728293031323334import requestsfrom bs4 import BeautifulSoup# 从bs对象中查找数据# find(标签，属性=值)# find_all(标签，属性-值（如果遇到python关键字用class_或者一个字典代替）)url = &quot;https://www.umei.cc/bizhitupian/diannaobizhi/&quot;resp = requests.get(url)resp.encoding = 'utf-8'#把爬下来的网站给bs并指定html解析# find(标签，属性=值)# find_all(标签，属性-值（如果遇到python关键字用class_或者一个字典代替）)main_page = BeautifulSoup(resp.text, &quot;html.parser&quot;)#main_page = BeautifulSoup(resp.text, &quot;lxml&quot;)a_list = main_page.find(&quot;div&quot;, class_=&quot;listlbc_cont_l&quot;).find_all(&quot;a&quot;)a_list = main_page.find(&quot;div&quot;, class_=&quot;item_list infinite_scroll&quot;).find_all(&quot;a&quot;)for a in a_list: href = a.get('href') print(href)#使用css选择器 调用select方法b_list = main_page.select('div.img div.btns a')#第一种写法for b in b_list: href = b.get('href') print(href)#第二种写法for b in b_list: print(b['href']) xpath //div找全部的div /div找第一个div @＋属性 严格匹配 鼠标右键复制完整xpath再元素控制台调试直到合适 12345678910111213141516import requestsfrom lxml import etreeurl = &quot;https://www.umei.cc/bizhitupian/diannaobizhi/&quot;resp = requests.get(url)resp.encoding = 'utf-8'soup = etree.HTML(resp.text)#text() @href @属性results=soup.xpath('/html/body/div[5]/div[1]/div[2]/div[1]/div/div/div[1]/div/a/img/@alt')results=soup.xpath('/html/body/div[5]/div[1]/div[2]/div[1]/div/div/div[1]/div/a/img/text()')for i in results: print(i) re re在爬虫种主要处理复杂的数据 使用正则设置一个匹配规则 得到一个list，使用group方法取出 1234567import re# （？P&lt;分组名字&gt;正则）可以单独从正则匹配的内容中进一步提取内容#re.S使.也可以匹配换行符obj = re.compile(r&quot;&lt;div class='.*?'&gt;&lt;span id='.*?'&gt;(?P&lt;分组&gt;.*?)&lt;/span&gt;&lt;div&gt;&quot;, re.S)result = obj.finditer(resp.text)for it in result: print(it.group(&quot;分组&quot;)) 总结爬虫解析页面主要使用bs4和xpath，如果遇到较为复杂的页面使用re即可。","link":"/2023/08/01/spider3/"},{"title":"纯净的V8环境","text":"在Node.js中提供相对纯净的v8环境 构建纯净v8环境 自己编译v8引擎 Node.js中删除多余对象 123let _process = process//删之前保存一下，以便后续使用delete process;//能删掉的删掉module = undefined;//不能删掉的定义为underfined 在vm2中修改12345678910111213141516171819202122232425//1.导入vm2模块 ，进行解构const {VM, VMScript} = require(&quot;vm2&quot;);const fs = require(&quot;fs&quot;);//2.创建虚拟机const vm = new VM();//7.传入一些对象const vm = new VM({ sandbox:{setTimeout,_require}});//3.读取一个js文件const code = fs.readFileSync(&quot;/Users/po/Desktop/网站逆向/vm2/input.js&quot;);//4.创建脚本const script = new VMScript(code);//4.5指定调试文件（尝试未成功）//const script = new VMScript(code,&quot;./debugJS.js&quot;);//5.运行脚本，返回结果//6.在运行之前执行删除一些对象的命令//vm.run(`['global','SharedArrayBuffer','GLOBAL','root','VMError','Buffer'].forEach(v=&gt;delete this[v])`);const result = vm.run(script);console.log(result);","link":"/2024/01/18/v8/"},{"title":"验证码处理(一)","text":"dddocr处理验证码。 dddocr 一个免费好用的验证码处理包 找到验证码图片接口 下载验证码 将验证码传入进行识别 返回验证码 处理数字文字验证码123456789import ddddocrdef get_ocr(): ocr = ddddocr.DdddOcr() with open(&quot;1.png&quot;, 'rb') as f: image = f.read() res = ocr.classification(image) print(f'验证码识别结果:{res}') return res","link":"/2023/08/01/yanzheng1/"},{"title":"验证码处理(二)","text":"图片切片混淆原理，和还原处理思路。 原理 Css背景定位，通过控制背景图片坐标的位置来还原图片。 background-position，坐标代码决定了图片应该从哪个位置去取 还原图片 请求一张打乱的图片，前端通过Css将其还原成一张完整的图片，在开发者工具中找到打乱的验证码图片并保存下来。 找到前端图片还原的Css代码 复制样式代码到vscode 创建新style，复制原来的样式，更改图片请求地址为本地 修改Css代码，使用Canvas手动输入坐标重绘验证码图片 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;!--注意最后保存文档时的编码 --&gt; &lt;title&gt;这是标题&lt;/title&gt;&lt;/head&gt;&lt;!-- 使用canvas画布重绘制图片 --&gt;&lt;canvas id=&quot;myCanvas&quot; width=&quot;260&quot; height=&quot;116&quot; style=&quot;border: red 1px solid;&quot; &gt;&lt;/canvas&gt;&lt;script&gt; let img = new Image(); img.src = &quot;./css图片.png&quot;; // 绑定事件 图片加载完成时运行 img.onload = function(){ console.log(&quot;图片加载完成&quot;); let cv = document.getElementById(&quot;myCanvas&quot;); let ctx = cv.getContext('2d'); // drawImage(ImgUrl,pxX（网站混淆的坐标）,pxY,styleX（原本设定的样式）,styleY,绘画横坐标,绘画纵坐标,styleX,styleY) // 手动添加坐标，后续使用for处理坐标 ctx.drawImage(img,234,25,13,25,0,0,13,25); ctx.drawImage(img,143,25,13,25,13,0,13,25); ctx.drawImage(img,65,75,13,25,26,0,13,25); console.log(cv); }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用re处理坐标还原图片 可以使用js的re表达来取1let arr = str.matchAll(/&quot;background-position:-?(\\d+)px\\s+-?(\\d+)px;&quot;/igs); 也可以使用python中re库来取12re.compile()finditer() 验证码切片混淆后使用python进行还原 处理坐标中的负号，abs取绝对值123456# 处理坐标def coordinates(data): data = [[abs(int(pos[0].replace(' ',''))), abs(int(pos[1].replace(' ','')))] for pos in data] return data 还原图片123456789101112131415161718192021222324252627# 还原图片# 传入处理好的坐标def reduction_img(positions): # 打开混淆切片的图片 my_image = Image.open('code.jpg') crop_list = [] for pos in positions: if pos[1]==0: crop_list.append(my_image.crop((pos[0],0,pos[0]+13,25))) if pos[1]==25: crop_list.append(my_image.crop((pos[0],25,pos[0]+13,50))) if pos[1]==50: crop_list.append(my_image.crop((pos[0],50,pos[0]+13,75))) if pos[1]==75: crop_list.append(my_image.crop((pos[0],75,pos[0]+13,100))) new_img = Image.new('RGB',(260,100)) x_offset = 0 y_offset = 0 for crop in crop_list: if x_offset == 260: x_offset = 0 y_offset += 25 new_img.paste(crop, (x_offset,y_offset)) x_offset+=13 new_img.save('code2.jpg')","link":"/2023/08/01/yanzheng2/"},{"title":"验证码处理(三)","text":"验证码切片混淆后使用python进行还原","link":"/2024/01/20/yanzheng3/"}],"tags":[{"name":"安卓逆向","slug":"安卓逆向","link":"/tags/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"刷机","slug":"刷机","link":"/tags/%E5%88%B7%E6%9C%BA/"},{"name":"Spider","slug":"Spider","link":"/tags/Spider/"},{"name":"Charles","slug":"Charles","link":"/tags/Charles/"},{"name":"Proxifie","slug":"Proxifie","link":"/tags/Proxifie/"},{"name":"Css","slug":"Css","link":"/tags/Css/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"SQlite","slug":"SQlite","link":"/tags/SQlite/"},{"name":"TinyDB","slug":"TinyDB","link":"/tags/TinyDB/"},{"name":"Js逆向","slug":"Js逆向","link":"/tags/Js%E9%80%86%E5%90%91/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Debugger","slug":"Debugger","link":"/tags/Debugger/"},{"name":"Fiddler","slug":"Fiddler","link":"/tags/Fiddler/"},{"name":"RPC","slug":"RPC","link":"/tags/RPC/"},{"name":"Html","slug":"Html","link":"/tags/Html/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Jscipher","slug":"Jscipher","link":"/tags/Jscipher/"},{"name":"Js混淆","slug":"Js混淆","link":"/tags/Js%E6%B7%B7%E6%B7%86/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"Mongodb","slug":"Mongodb","link":"/tags/Mongodb/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"aiohttp","slug":"aiohttp","link":"/tags/aiohttp/"},{"name":"MySql","slug":"MySql","link":"/tags/MySql/"},{"name":"cipher","slug":"cipher","link":"/tags/cipher/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"验证码","slug":"验证码","link":"/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"},{"name":"滑块","slug":"滑块","link":"/tags/%E6%BB%91%E5%9D%97/"}],"categories":[{"name":"3.Android逆向","slug":"3-Android逆向","link":"/categories/3-Android%E9%80%86%E5%90%91/"},{"name":"1.Android基础","slug":"3-Android逆向/1-Android基础","link":"/categories/3-Android%E9%80%86%E5%90%91/1-Android%E5%9F%BA%E7%A1%80/"},{"name":"1.爬虫","slug":"1-爬虫","link":"/categories/1-%E7%88%AC%E8%99%AB/"},{"name":"5.编程基础","slug":"5-编程基础","link":"/categories/5-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"4.数据库","slug":"4-数据库","link":"/categories/4-%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"2.Js逆向","slug":"2-Js逆向","link":"/categories/2-Js%E9%80%86%E5%90%91/"},{"name":"4.抓包工具","slug":"1-爬虫/4-抓包工具","link":"/categories/1-%E7%88%AC%E8%99%AB/4-%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/"},{"name":"2.Java","slug":"5-编程基础/2-Java","link":"/categories/5-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/2-Java/"},{"name":"4.Html+Css","slug":"5-编程基础/4-Html-Css","link":"/categories/5-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/4-Html-Css/"},{"name":"3.JavaScript","slug":"5-编程基础/3-JavaScript","link":"/categories/5-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/3-JavaScript/"},{"name":"1.轻量级数据库","slug":"4-数据库/1-轻量级数据库","link":"/categories/4-%E6%95%B0%E6%8D%AE%E5%BA%93/1-%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"3.Js混淆","slug":"2-Js逆向/3-Js混淆","link":"/categories/2-Js%E9%80%86%E5%90%91/3-Js%E6%B7%B7%E6%B7%86/"},{"name":"1.密码学","slug":"2-Js逆向/1-密码学","link":"/categories/2-Js%E9%80%86%E5%90%91/1-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"3.Mongodb","slug":"4-数据库/3-Mongodb","link":"/categories/4-%E6%95%B0%E6%8D%AE%E5%BA%93/3-Mongodb/"},{"name":"1.爬虫基础","slug":"1-爬虫/1-爬虫基础","link":"/categories/1-%E7%88%AC%E8%99%AB/1-%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/"},{"name":"2.MySql","slug":"4-数据库/2-MySql","link":"/categories/4-%E6%95%B0%E6%8D%AE%E5%BA%93/2-MySql/"},{"name":"1.Python","slug":"5-编程基础/1-Python","link":"/categories/5-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/1-Python/"},{"name":"4.Redis","slug":"4-数据库/4-Redis","link":"/categories/4-%E6%95%B0%E6%8D%AE%E5%BA%93/4-Redis/"},{"name":"2.Scrapy","slug":"1-爬虫/2-Scrapy","link":"/categories/1-%E7%88%AC%E8%99%AB/2-Scrapy/"},{"name":"3.验证码处理","slug":"1-爬虫/3-验证码处理","link":"/categories/1-%E7%88%AC%E8%99%AB/3-%E9%AA%8C%E8%AF%81%E7%A0%81%E5%A4%84%E7%90%86/"}],"pages":[{"title":"","text":"Title *{ margin: 0; padding: 0; font-family: \"Poppins\", sans-serif; box-sizing: border-box; } .mycontainer .mycard .face{ position: absolute; top: 0; left: 0; width: 100%; height: 100%; transition: 0.5s; } .mycontainer .mycard .face.face1{ background: transparent; display: flex; justify-content: center; align-items: center; z-index: 1; transform-origin: bottom; } .mycontainer .mycard .face.face1 img{ max-width: 150px; } .mycontainer .mycard .face.face1 h3{ margin: 10px 0 0; color: #fff; text-align: center; font-size: 1.5em; } .mycontainer .mycard .face.face2 a{ color: rgb(0, 191, 255); text-align: center; font-size: 1.5em; } 1-爬虫基础 2-Scrapy 3-验证码处理 4-抓包工具 1-密码学 2-AST还原 3-Js混淆 4-Js补环境 1-Android基础 1-轻量级数据库 2-MySql 3-Mongodb 4-Redis","link":"/classification/index.html"},{"title":"","text":"/* *{ margin: 0; padding: 0; font-family: \"Poppins\", sans-serif; box-sizing: border-box; } */ mybody{ height: 500px; display: flex; justify-content: center; background-color: transparents } .mycontainer{ width: 700px; height: 520px; position: relative; /* display: flex; */ justify-content: space-between; /* 开启网格布局 */ display: grid; grid-template-rows: 300px 300px ; grid-template-columns: 300px 300px ; } .mycontainer .mycard{ position: relative; width: 300px; height: 200px; } /* .mycontainer .mycard .face{ position: absolute; top: 0; left: 0; width: 100%; height: 100%; transition: 0.5s; } */ /* .mycontainer .mycard .face.face1{ background: #333; display: flex; justify-content: center; align-items: center; z-index: 1; transform-origin: bottom; } */ /* .mycontainer .mycard .face.face1 h3{ margin: 10px 0 0; color: #fff; text-align: center; font-size: 1.5em; } */ .mycontainer .mycard:hover .face.face1{ transform: translateY(-100%) rotateX(90deg); background: transparent; } .mycontainer .mycard .face.face2{ background: transparent; display: flex; justify-content: center; align-items: center; padding: 20px; transform-origin: top; transform: translateY(100%) rotateX(90deg); } .mycontainer .mycard:hover .face.face2{ transform: translateY(0%) rotateX(0deg); }","link":"/classification/style.css"},{"title":"","text":"Title :root { --fontColor: white; --one1: #c39edc; --one2: white; --two1: #3dbbc7; --two2: white; --three1: #21bbfe; --three2: white; --four1: #122c9e; --four2: white; --levelShadow: #22325480; } .levels { position: relative; top: 50%; left: 50%; margin-left: -140px; margin-top: 100px; transform-style: preserve-3d; user-select: none; } .levels .level { width: 400px; height: 210px; border-radius: 12px; color: var(--fontColor); cursor: pointer; transition: all 0.4s ease; transform: rotateX(37deg) rotateY(-20deg) rotate(15deg); opacity: 0.9; margin-top: -70px; } .levels .level.one { background: linear-gradient(135deg, var(--one1), var(--one2)); box-shadow: 20px 20px 60px var(--levelShadow), 1px 1px 0px 1px var(--one2); z-index: 4; } .levels .level.two { background: linear-gradient(135deg, var(--two1), var(--two2)); box-shadow: 20px 20px 60px var(--levelShadow), 1px 1px 0px 1px var(--two2); z-index: 3; } .levels .level.three { background-image: linear-gradient(135deg, var(--three1), var(--three2)); box-shadow: 20px 20px 60px var(--levelShadow), 1px 1px 0px 1px var(--three2); z-index: 2; } .levels .level.four { background-image: linear-gradient(135deg, var(--four1), var(--four2)); box-shadow: 20px 20px 60px var(--levelShadow), 1px 1px 0px 1px var(--four2); z-index: 1; } .levels .level .title { color: white; position: absolute; top: 80px; right: 80px; font-size: 40px; font-weight: bold; } .levels .level .content { position: absolute; font-weight: 700; bottom: 15px; left: 15px; font-size: 16px; } .levels .level:hover { transform: rotateX(37deg) rotateY(-20deg) rotate(18deg) translate(-25px, 50px); opacity: 0.6; } .levels .level:hover:after { transform: translateX(100%); transition: all 2s ease-in-out; } .levels .level::after { content: ''; position: absolute; top: 0px; left: 0; width: 100%; height: 100%; transform: translateX(-100%); background: linear-gradient(60deg, rgba(255,255,255,0) 20%, rgba(255,255,255,0.1), rgba(255,255,255,0) 80%); } Python 爬虫开发 Java Android逆向 后端开发 JavaScript Js逆向 Html+Css 前端开发","link":"/codebase/index.html"},{"title":"","text":"碎碎念 h2{ text-align: center; } p{ text-align: center; } 碎碎念 一路有陌路人陪你这一生","link":"/about/index.html"}]}